#include "animationdata.h"

AnimationData::AnimationData()
{
    horizontalFrameNumber = 1;
    verticalFrameNumber = 1;
    horizontalSpacing = 0;
    verticalSpacing = 0;
    order = 0;
    velocity = 50;
    hasLoop = true;
    frameLoop = 0;

    hasColorkey = false;
    colorkey_b = 0;
    colorkey_g = 0;
    colorkey_r = 0;

    activated = false;

    startX = 1;
    startY = 1;
    endX = 1;
    endY = 1;
}

void AnimationData::setHorizontalFrameNumber(int number) {
    horizontalFrameNumber = number;
    endX = horizontalFrameNumber;
}

void AnimationData::setVerticalFrameNumber(int number) {
    verticalFrameNumber = number;
    endY = verticalFrameNumber;
}

int AnimationData::getHorizontalFrameNumber() {
    return horizontalFrameNumber;
}

int AnimationData::getVerticalFrameNumber() {
    return verticalFrameNumber;
}

QImage AnimationData::getIconImage() {
    GameData *gameData = GameData::getInstance();
    std::string directory;

    directory = gameData->getProjectDirectory().append("/").append(this->fileName);

    QImage image = QImage(QString(directory.c_str()));

    int stepX, stepY;
    stepX = image.width()/this->getHorizontalFrameNumber();
    stepY = image.height()/this->getVerticalFrameNumber();



    QImage image2 = image.copy((this->startX - 1)*stepX, (this->startY - 1)*stepY, stepX, stepY);

    return image2;
}
#include "animationgraphicsitem.h"

AnimationGraphicsItem::AnimationGraphicsItem(std::string fileName, int horizontalFrameNumber, int verticalFrameNumber, int order,
                                             int startX, int startY, int endX, int endY)
{
    GameData *gameData = GameData::getInstance();

    std::string directory =  gameData->getProjectDirectory().append("/").append(fileName);

    image = new QImage(QString(directory.c_str()));

    this->horizontalFrameNumber = horizontalFrameNumber;
    this->verticalFrameNumber = verticalFrameNumber;
    this->order = order;
    this->startX = startX;
    this->startY = startY;
    this->endX = endX;
    this->endY = endY;

    if(startX > horizontalFrameNumber) {
        startX = horizontalFrameNumber;
    }

    if(startY > verticalFrameNumber) {
        startY = verticalFrameNumber;
    }

    if(endX > horizontalFrameNumber) {
        endX = horizontalFrameNumber;
    }

    if(endY > verticalFrameNumber) {
        endY = verticalFrameNumber;
    }

    stepX = image->width()/horizontalFrameNumber;
    stepY = image->height()/verticalFrameNumber;

    animX = startX - 1;
    animY = startY - 1;

    animationRect.setRect(0, 0, stepX, stepY);

    isAnimation = true;

    this->setRect(0, 0, stepX, stepY);


}

AnimationGraphicsItem::AnimationGraphicsItem(std::string fileName) {
    GameData *gameData = GameData::getInstance();

    std::string directory =  gameData->getProjectDirectory().append("/").append(fileName);

    image = new QImage(QString(directory.c_str()));

    isAnimation = false;

    this->setRect(0, 0, image->width(), image->height());
}

void AnimationGraphicsItem::doStep() {
    if(order == 0) {
        animX++;
        if(animX >= endX) {
            animX = startX - 1;
            animY++;
            if(animY >= endY) {
                animY = startY - 1;
            }
        }
    } else {
        animY++;
        if(animY > endY) {
            animY = startY - 1;
            animX++;
            if(animX > endX) {
                animX = startX - 1;
            }
        }
    }

    animationRect.setRect(animX*stepX, animY*stepY, stepX, stepY);

}


void AnimationGraphicsItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) {
    if(isAnimation) {
        painter->drawImage(QRectF(0, 0, stepX, stepY), *image, QRect(animX*stepX, animY*stepY, stepX, stepY), NULL);
    } else {
        painter->drawImage(QRectF(0, 0, image->width(), image->height()), *image, QRect(0, 0, image->width(), image->height()), NULL);
    }

}
#include "animationgraphicsscene.h"

AnimationGraphicsScene::AnimationGraphicsScene(QGraphicsView *graphicsView)
{
    animationGraphicsItem = NULL;
    this->graphicsView = graphicsView;
    graphicsView->setBackgroundBrush(QBrush(QColor(255 , 255, 255, 255)));
    timerId = -1;

    QImage background = QImage(20, 20, QImage::Format_RGB32);

    for(int i = 0; i < 10; i++) {
        for(int j = 0; j < 10; j++) {
            background.setPixel(i, j, QColor(255, 255, 255, 255).rgb());
            background.setPixel(i + 10, j + 10, QColor(255, 255, 255, 255).rgb()) ;

            background.setPixel(i, j + 10, QColor(180, 180, 180, 255).rgb());
            background.setPixel(i + 10, j, QColor(180, 180, 180, 255).rgb());
        }
    }

    QBrush brush = QBrush(Qt::TexturePattern);
    brush.setTexture(QPixmap::fromImage(background));

    graphicsView->setBackgroundBrush(brush);
    setBackgroundBrush(brush);

    crossLine1 = NULL;
    crossLine2 = NULL;
}

AnimationGraphicsScene::~AnimationGraphicsScene() {
    if(timerId >= 0) {
        killTimer(timerId);
    }
}

void AnimationGraphicsScene::addAnimationData(AnimationData *animationData) {
    if(animationGraphicsItem != NULL) {
        removeItem(animationGraphicsItem);

        delete animationGraphicsItem;
    }

    animationGraphicsItem = new AnimationGraphicsItem(animationData->fileName, animationData->getHorizontalFrameNumber(),
                                                      animationData->getVerticalFrameNumber(), animationData->order,
                                                      animationData->startX, animationData->startY,
                                                      animationData->endX, animationData->endY);

    animationGraphicsItem->setFlag(QGraphicsItem::ItemIsMovable);
    animationGraphicsItem->setFlag(QGraphicsItem::ItemIsSelectable);


    addItem(animationGraphicsItem);

    if(timerId >= 0) {
        killTimer(timerId);
        timerId = -1;
    }

    int animationFrames = (100 - animationData->velocity);


    timerId = startTimer(animationFrames*4);
}

void AnimationGraphicsScene::addSpriteData(std::string sprite) {

    if(animationGraphicsItem != NULL) {
        removeItem(animationGraphicsItem);

        delete animationGraphicsItem;
    }

    animationGraphicsItem = new AnimationGraphicsItem(sprite);

    animationGraphicsItem->setFlag(QGraphicsItem::ItemIsMovable);
    animationGraphicsItem->setFlag(QGraphicsItem::ItemIsSelectable);


    addItem(animationGraphicsItem);

    if(timerId >= 0) {
        killTimer(timerId);
        timerId = -1;
    }

}

void AnimationGraphicsScene::removeGraphics() {
    if(animationGraphicsItem != NULL) {
        removeItem(animationGraphicsItem);

        delete animationGraphicsItem;

        animationGraphicsItem = NULL;

        update();
        graphicsView->update();



        if(timerId >= 0) {
            killTimer(timerId);
            timerId = -1;
        }

    }
}

void AnimationGraphicsScene::timerEvent(QTimerEvent *) {
    if(animationGraphicsItem != NULL) {
        animationGraphicsItem->doStep();

        animationGraphicsItem->update();
        update();
        graphicsView->update();
    }


}

void AnimationGraphicsScene::setAdjustPoint(int x, int y) {
    if(crossLine1 != NULL) {
        removeItem(crossLine1);
        delete crossLine1;

        crossLine1 = NULL;
    }

    if(crossLine2 != NULL) {
        removeItem(crossLine2);
        delete crossLine2;

        crossLine2 = NULL;
    }

    crossLine1 = addLine(x - 2, y, x + 2, y, QPen(QColor(0, 0, 0, 255)));
    crossLine2 = addLine(x, y - 2, x, y + 2, QPen(QColor(0, 0, 0, 255)));
}


#include "background.h"

Background::Background()
{
    layerList = new std::vector<BgLayer*>();
}
#include "backgroundlayer.h"

BgLayer::BgLayer()
{


    displacementX = 0;
    displacementY = 0;
    repeatsHorizontally = false;
    repeatsVertically = false;
    behavior = 1;
    vx = 0;
    vy = 0;
}
#include "backgroundpickerdialog.h"
#include "ui_backgroundpickerdialog.h"

BackgroundPickerDialog::BackgroundPickerDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::BackgroundPickerDialog)
{
    ui->setupUi(this);

    backgroundGraphicsScene = new BackgroundsGraphicsScene();
    ui->graphicsView->setScene(backgroundGraphicsScene);

    chosenBackground = NULL;

    populaListaFundos();
}

BackgroundPickerDialog::~BackgroundPickerDialog()
{
    delete ui;
}

void BackgroundPickerDialog::populaListaFundos() {
    GameData *gameData = GameData::getInstance();

    ui->listWidget->clear();

    for(std::vector<Background*>::iterator it = gameData->backgroundList->begin(); it != gameData->backgroundList->end(); ++it) {
        Background *background = *it;

        QListWidgetItem *item = new QListWidgetItem(QString(background->name.c_str()));
        item->setData(Qt::UserRole, QVariant::fromValue((void*) background));
        ui->listWidget->addItem(item);
    }

    if(ui->listWidget->count() != 0) {
        ui->listWidget->setCurrentRow(0);
    }
}

void BackgroundPickerDialog::on_listWidget_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    if(current != NULL) {
        Background *bg = (Background*) current->data(Qt::UserRole).value<void*>();

        backgroundGraphicsScene->setBackground(bg);
    }

}

void BackgroundPickerDialog::on_buttonBox_accepted()
{
    if(ui->listWidget->currentItem() != NULL) {
        chosenBackground = (Background*) ui->listWidget->currentItem()->data(Qt::UserRole).value<void*>();
    } else {
        chosenBackground = NULL;
    }

}

void BackgroundPickerDialog::on_buttonBox_rejected()
{
    chosenBackground = NULL;
}

Background* BackgroundPickerDialog::exec() {
    QDialog::exec();

    return chosenBackground;
}

void BackgroundPickerDialog::on_buttonBox_clicked(QAbstractButton* button)
{

}
#include "backgroundsgraphicsscene.h"

BackgroundsGraphicsScene::BackgroundsGraphicsScene()
{
    background = NULL;
}

void BackgroundsGraphicsScene::setBackground(Background *background) {
    GameData *gameData = GameData::getInstance();
    this->background = background;


    if(background != NULL) {
        for(std::vector<QGraphicsPixmapItem*>::iterator it = pixmapItems.begin(); it != pixmapItems.end(); ++it) {
            QGraphicsPixmapItem *graphisPixmapItem = *it;
            delete graphisPixmapItem;
        }

        pixmapItems.clear();

        for(std::vector<BgLayer*>::iterator it = background->layerList->begin(); it != background->layerList->end(); ++it) {
           BgLayer *bgLayer = *it;

           std::cout << "pixmapitem dir: " << gameData->getProjectDirectory().append("/").append(bgLayer->fileName).c_str() << std::endl;

           QGraphicsPixmapItem *graphicsPixmapItem = new QGraphicsPixmapItem(QPixmap(QString(gameData->getProjectDirectory().append("/").append(bgLayer->fileName).c_str())));
           pixmapItems.push_back(graphicsPixmapItem);

           graphicsPixmapItem->setPos(bgLayer->displacementX, bgLayer->displacementY);

           addItem(graphicsPixmapItem);
       }

        this->update();
    }



}

void BackgroundsGraphicsScene::reloadBackground() {
    setBackground(background);
}
#include "builder.h"

Builder::Builder()
{
}

MainController* Builder::build()
{
    MainController* mainController;
    EventsEditorController *eventsEditorController;
    MapEditorController *mapEditorController;
    OptionsController *optionsController;
    WizardController *wizardController;

    mainController = new MainController();
    eventsEditorController = new EventsEditorController();
    mapEditorController = new MapEditorController();
    optionsController = new OptionsController();
    wizardController = new WizardController();

    mainController->setEventsEditorController(eventsEditorController);
    mainController->setMapEditorController(mapEditorController);
    mainController->setOptionsController(optionsController);
    mainController->setWizardController(wizardController);


    eventsEditorController->setMainController(mainController);
    mapEditorController->setMainController(mainController);
    optionsController->setMainController(mainController);
    wizardController->setMainController(mainController);

    optionsController->setEventsEditorController(eventsEditorController);

    return mainController;
}
#include "configsanimations.h"
#include "ui_configsanimations.h"

ConfigsAnimations::ConfigsAnimations(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ConfigsAnimations)
{
    ui->setupUi(this);

    ui->lineEditName->setEnabled(false);
    ui->groupBoxDadosFrames->setEnabled(false);
    ui->groupBoxVisualizacao->setEnabled(false);

    currentAnimationData = NULL;

    animationsGraphicsScene = new AnimationGraphicsScene(ui->graphicsView);


    populaListaAnimation();
}

ConfigsAnimations::~ConfigsAnimations()
{
    delete ui;
}

void ConfigsAnimations::setOptionsController(OptionsController *optionsController) {
    this->optionsController = optionsController;
}

void ConfigsAnimations::populaListaAnimation() {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::vector<AnimationData*> *animationDataList;


    animationDataList = gameData->animationDataList;

    ui->listWidget->clear();

    for(std::vector<AnimationData*>::iterator it = animationDataList->begin(); it != animationDataList->end(); ++it) {
        AnimationData *iterationItem;

        iterationItem = *it;
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString(iterationItem->name.c_str()));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) iterationItem));
        ui->listWidget->addItem(newItem);

    }
}

void ConfigsAnimations::populaCampos() {
    ui->lineEditName->setText(QString(currentAnimationData->name.c_str()));

    ui->spinBoxFrameLoop->setValue(currentAnimationData->frameLoop);
    ui->spinBoxHorizontalFramesNumber->setValue(currentAnimationData->getHorizontalFrameNumber());
    ui->spinBoxHorizontalSpacing->setValue(currentAnimationData->horizontalSpacing);
    ui->spinBoxVerticalFrameNumber->setValue(currentAnimationData->getVerticalFrameNumber());
    ui->spinBoxVerticalSpacing->setValue(currentAnimationData->verticalSpacing);

    ui->horizontalSliderVelocity->setValue(currentAnimationData->velocity);

    ui->checkBox->setChecked(currentAnimationData->hasLoop);

    ui->comboBoxOrder->setCurrentIndex(currentAnimationData->order);

    ui->spinBoxColunaInicial->setValue(currentAnimationData->startX);
    ui->spinBoxLinhaInicial->setValue(currentAnimationData->startY);
    ui->spinBoxColunaFinal->setValue(currentAnimationData->endX);
    ui->spinBoxLinhaFinal->setValue(currentAnimationData->endY);

    ui->spinBoxColunaInicial->setMaximum(currentAnimationData->getHorizontalFrameNumber());
    ui->spinBoxColunaFinal->setMaximum(currentAnimationData->getHorizontalFrameNumber());
    ui->spinBoxLinhaInicial->setMaximum(currentAnimationData->getVerticalFrameNumber());
    ui->spinBoxLinhaFinal->setMaximum(currentAnimationData->getVerticalFrameNumber());
}


void ConfigsAnimations::on_pushButtonAddAnimation_clicked()
{
    ConfigsImportDialog *configsImportDialog;
    configsImportDialog = new ConfigsImportDialog(optionsController, ConfigsImportDialog::IMPORT_ANIMATIONS,
                                                  this);

    configsImportDialog->exec();
}

void ConfigsAnimations::on_listWidget_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    if(current != NULL) {
        currentAnimationData = (AnimationData*) current->data(Qt::UserRole).value<void*>();
        ui->lineEditName->setEnabled(true);
        ui->groupBoxDadosFrames->setEnabled(true);
        ui->groupBoxVisualizacao->setEnabled(true);
        ativaMudancas = false;
        populaCampos();
        ativaMudancas = true;

        animationsGraphicsScene->addAnimationData(currentAnimationData);

        ui->graphicsView->setScene(animationsGraphicsScene);
        ui->graphicsView->setMouseTracking(true);
    }








}


void ConfigsAnimations::on_spinBoxHorizontalFramesNumber_valueChanged(int value)
{
    if(ativaMudancas) {
        currentAnimationData->setHorizontalFrameNumber(value);
        ui->spinBoxColunaInicial->setMaximum(currentAnimationData->getHorizontalFrameNumber());
        ui->spinBoxColunaFinal->setMaximum(currentAnimationData->getHorizontalFrameNumber());
        ui->spinBoxColunaFinal->setValue(value);
        animationsGraphicsScene->addAnimationData(currentAnimationData);
    }



}

void ConfigsAnimations::on_spinBoxVerticalFrameNumber_valueChanged(int value)
{
    if(ativaMudancas) {
        currentAnimationData->setVerticalFrameNumber(value);
        ui->spinBoxLinhaInicial->setMaximum(currentAnimationData->getVerticalFrameNumber());
        ui->spinBoxLinhaFinal->setMaximum(currentAnimationData->getVerticalFrameNumber());
        ui->spinBoxLinhaFinal->setValue(value);
        animationsGraphicsScene->addAnimationData(currentAnimationData);
    }



}

void ConfigsAnimations::on_spinBoxHorizontalSpacing_valueChanged(int value)
{
    currentAnimationData->horizontalSpacing = value;
    animationsGraphicsScene->addAnimationData(currentAnimationData);
}

void ConfigsAnimations::on_spinBoxVerticalSpacing_valueChanged(int value)
{
    currentAnimationData->verticalSpacing = value;
    animationsGraphicsScene->addAnimationData(currentAnimationData);
}

void ConfigsAnimations::on_horizontalSliderVelocity_valueChanged(int value)
{
    currentAnimationData->velocity = value;
    animationsGraphicsScene->addAnimationData(currentAnimationData);
}

void ConfigsAnimations::on_checkBox_toggled(bool checked)
{
    currentAnimationData->hasLoop = checked;
    animationsGraphicsScene->addAnimationData(currentAnimationData);
}

void ConfigsAnimations::on_spinBoxFrameLoop_valueChanged(int value)
{
    currentAnimationData->frameLoop = value;
    animationsGraphicsScene->addAnimationData(currentAnimationData);
}

void ConfigsAnimations::on_comboBoxOrder_currentIndexChanged(int index)
{
    currentAnimationData->order = index;
    animationsGraphicsScene->addAnimationData(currentAnimationData);
}

void ConfigsAnimations::on_spinBoxColunaInicial_valueChanged(int value)
{
    if(value > currentAnimationData->getHorizontalFrameNumber()) {
        value = currentAnimationData->getHorizontalFrameNumber();
        ui->spinBoxColunaInicial->setValue(value);
    }
    currentAnimationData->startX = value;
    animationsGraphicsScene->addAnimationData(currentAnimationData);


}

void ConfigsAnimations::on_spinBoxLinhaInicial_valueChanged(int value)
{
    if(value > currentAnimationData->getVerticalFrameNumber()) {
        value = currentAnimationData->getVerticalFrameNumber();
        ui->spinBoxLinhaInicial->setValue(value);
    }
    currentAnimationData->startY = value;
    animationsGraphicsScene->addAnimationData(currentAnimationData);


}

void ConfigsAnimations::on_spinBoxColunaFinal_valueChanged(int value)
{
    if(value > currentAnimationData->getHorizontalFrameNumber()) {
        value = currentAnimationData->getHorizontalFrameNumber();
        ui->spinBoxColunaFinal->setValue(value);
    }
    currentAnimationData->endX = value;
    animationsGraphicsScene->addAnimationData(currentAnimationData);

}

void ConfigsAnimations::on_spinBoxLinhaFinal_valueChanged(int value)
{
    if(value > currentAnimationData->getVerticalFrameNumber()) {
        value = currentAnimationData->getVerticalFrameNumber();
        ui->spinBoxLinhaFinal->setValue(value);
    }
    currentAnimationData->endY = value;
    animationsGraphicsScene->addAnimationData(currentAnimationData);
}
#include "configsbackgrounds.h"
#include "ui_configsbackgrounds.h"

ConfigsBackgrounds::ConfigsBackgrounds(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ConfigsBackgrounds)
{
    ui->setupUi(this);
    backgroundsGraphicsScene = new BackgroundsGraphicsScene();

    ui->graphicsView->setScene(backgroundsGraphicsScene);

    populaListaBackgrounds(true);
}

ConfigsBackgrounds::~ConfigsBackgrounds()
{
    delete ui;
}

void ConfigsBackgrounds::populaListaBackgrounds(bool firstTime = false) {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::vector<Background*> *backgroundList;


    backgroundList = gameData->backgroundList;

    ui->listWidgetBgs->clear();

    for(std::vector<Background*>::iterator it = backgroundList->begin(); it != backgroundList->end(); ++it) {
        Background *iterationItem;

        iterationItem = *it;
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString(iterationItem->name.c_str()));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) iterationItem));
        ui->listWidgetBgs->addItem(newItem);


    }

    if(ui->listWidgetBgs->count() > 0) {
        if(firstTime) {
            ui->listWidgetBgs->setCurrentRow(0);
        } else {
            ui->listWidgetBgs->setCurrentRow(ui->listWidgetBgs->count() - 1);
        }

    }
}

void ConfigsBackgrounds::populaListaLayers() {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::vector<BgLayer*> *layerList;


    layerList = ((Background*) ui->listWidgetBgs->currentItem()->data(Qt::UserRole).value<void*>())->layerList;

    ui->listWidgetLayers->clear();

    for(std::vector<BgLayer*>::iterator it = layerList->begin(); it != layerList->end(); ++it) {
        BgLayer *iterationItem;

        iterationItem = *it;
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString(iterationItem->fileName.c_str()));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) iterationItem));
        ui->listWidgetLayers->addItem(newItem);

    }

    if(ui->listWidgetLayers->count() > 0) {
        ui->listWidgetLayers->setCurrentRow(0);
    }
}

void ConfigsBackgrounds::setOptionsController(OptionsController *optionsController) {
    this->optionsController = optionsController;
}

void ConfigsBackgrounds::on_pushButtonAddBg_clicked()
{
    ConfigsImportDialog *configsImportDialog = new ConfigsImportDialog(optionsController, ConfigsImportDialog::IMPORT_BACKGROUND);
    configsImportDialog->exec();
}

void ConfigsBackgrounds::on_listWidgetBgs_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    if(current != NULL) {
        populaListaLayers();
        ui->groupBoxBg->setEnabled(true);
        preencheCamposBg();

        Background *bg = ((Background*) ui->listWidgetBgs->currentItem()->data(Qt::UserRole).value<void*>());

        backgroundsGraphicsScene->setBackground(bg);
    }


}

void ConfigsBackgrounds::preencheCamposBg() {
    Background *bg = ((Background*) ui->listWidgetBgs->currentItem()->data(Qt::UserRole).value<void*>());
    ui->lineEditName->setText(QString(bg->name.c_str()));
}

void ConfigsBackgrounds::preencheCamposLayer() {
    ui->groupBoxLayer->setEnabled(true);
    ui->groupBoxVisual->setEnabled(true);

    BgLayer *bgLayer = ((BgLayer*) ui->listWidgetLayers->currentItem()->data(Qt::UserRole).value<void*>());

    ui->checkBoxRepeatHor->setChecked(bgLayer->repeatsHorizontally);
    ui->checkBoxRepeatVer->setChecked(bgLayer->repeatsVertically);
    ui->spinBoxDx->setValue(bgLayer->displacementX);
    ui->spinBoxDy->setValue(bgLayer->displacementY);
    ui->spinBoxVx->setValue(bgLayer->vx);
    ui->spinBoxVy->setValue(bgLayer->vy);
    ui->comboBoxBehavior->setCurrentIndex(bgLayer->behavior);
    ui->lineEditImageFile->setText(QString(bgLayer->fileName.c_str()));

    if(ui->comboBoxBehavior->currentIndex() < 2) {
        ui->spinBoxVx->setEnabled(false);
        ui->spinBoxVy->setEnabled(false);
    } else {
        ui->spinBoxVx->setEnabled(true);
        ui->spinBoxVy->setEnabled(true);
    }
}

void ConfigsBackgrounds::on_lineEditName_textChanged(QString text)
{
    Background *bg = ((Background*) ui->listWidgetBgs->currentItem()->data(Qt::UserRole).value<void*>());
    if(!text.isEmpty()) {
        bg->name = text.toStdString();
        ui->listWidgetBgs->currentItem()->setText(text);
    }

}

void ConfigsBackgrounds::on_listWidgetLayers_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    if(current != NULL) {
        preencheCamposLayer();
    }

}

void ConfigsBackgrounds::on_pushButton_clicked()
{
    std::string *returnString;
    ConfigsImportDialog *configsImportDialog = new ConfigsImportDialog(optionsController, ConfigsImportDialog::IMPORT_LAYER, this);
    configsImportDialog->exec();
    returnString = configsImportDialog->getReturnString();

    if(returnString != NULL) {
        BgLayer *bgLayer = ((BgLayer*) ui->listWidgetLayers->currentItem()->data(Qt::UserRole).value<void*>());
        ui->lineEditImageFile->setText(QString(returnString->c_str()));
        bgLayer->fileName = std::string("images/").append(returnString->c_str());

        delete returnString;
    }



    delete configsImportDialog;

    backgroundsGraphicsScene->reloadBackground();
}

void ConfigsBackgrounds::on_spinBoxDx_valueChanged(int value)
{
    BgLayer *bgLayer = ((BgLayer*) ui->listWidgetLayers->currentItem()->data(Qt::UserRole).value<void*>());
    bgLayer->displacementX = value;
    backgroundsGraphicsScene->reloadBackground();
}

void ConfigsBackgrounds::on_spinBoxDy_valueChanged(int value)
{
    BgLayer *bgLayer = ((BgLayer*) ui->listWidgetLayers->currentItem()->data(Qt::UserRole).value<void*>());
    bgLayer->displacementY = value;
    backgroundsGraphicsScene->reloadBackground();
}

void ConfigsBackgrounds::on_checkBoxRepeatHor_toggled(bool checked)
{
    BgLayer *bgLayer = ((BgLayer*) ui->listWidgetLayers->currentItem()->data(Qt::UserRole).value<void*>());
    bgLayer->repeatsHorizontally = checked;
    backgroundsGraphicsScene->reloadBackground();
}

void ConfigsBackgrounds::on_checkBoxRepeatVer_toggled(bool checked)
{
    BgLayer *bgLayer = ((BgLayer*) ui->listWidgetLayers->currentItem()->data(Qt::UserRole).value<void*>());
    bgLayer->repeatsVertically = checked;
    backgroundsGraphicsScene->reloadBackground();
}

void ConfigsBackgrounds::on_comboBoxBehavior_currentIndexChanged(int index)
{
    BgLayer *bgLayer = ((BgLayer*) ui->listWidgetLayers->currentItem()->data(Qt::UserRole).value<void*>());
    bgLayer->behavior = index;
    backgroundsGraphicsScene->reloadBackground();

    if(index < 2) {
        ui->spinBoxVx->setEnabled(false);
        ui->spinBoxVy->setEnabled(false);
    } else {
        ui->spinBoxVx->setEnabled(true);
        ui->spinBoxVy->setEnabled(true);
    }
}

void ConfigsBackgrounds::on_spinBoxVx_valueChanged(int value)
{
    BgLayer *bgLayer = ((BgLayer*) ui->listWidgetLayers->currentItem()->data(Qt::UserRole).value<void*>());
    bgLayer->vx = value;
    backgroundsGraphicsScene->reloadBackground();
}

void ConfigsBackgrounds::on_spinBoxVy_valueChanged(int value)
{
    BgLayer *bgLayer = ((BgLayer*) ui->listWidgetLayers->currentItem()->data(Qt::UserRole).value<void*>());
    bgLayer->vy = value;
    backgroundsGraphicsScene->reloadBackground();
}

void ConfigsBackgrounds::on_listWidgetLayers_itemChanged(QListWidgetItem* item)
{

}

void ConfigsBackgrounds::on_pushButtonAddLayer_clicked()
{

}

void ConfigsBackgrounds::on_pushButtonAddLayer_pressed()
{
    std::string *returnString;
    ConfigsImportDialog *configsImportDialog = new ConfigsImportDialog(optionsController, ConfigsImportDialog::IMPORT_LAYER, this);
    configsImportDialog->exec();
    returnString = configsImportDialog->getReturnString();

    if(returnString != NULL) {
        BgLayer *bgLayer = new BgLayer();
        Background *bg = ((Background*) ui->listWidgetBgs->currentItem()->data(Qt::UserRole).value<void*>());

        bgLayer->fileName = std::string("images/").append(returnString->c_str());
        bg->layerList->push_back(bgLayer);

        delete returnString;
    }



    delete configsImportDialog;

    populaListaLayers();
    backgroundsGraphicsScene->reloadBackground();
}

void ConfigsBackgrounds::on_pushButtonRemoveLayer_pressed()
{
    if(ui->listWidgetLayers->count() == 1) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Necessária ao menos uma camada."));
    } else {
        if(ui->listWidgetLayers->currentItem() != NULL) {
            BgLayer *bgLayer = ((BgLayer*) ui->listWidgetLayers->currentItem()->data(Qt::UserRole).value<void*>());
            Background *bg = ((Background*) ui->listWidgetBgs->currentItem()->data(Qt::UserRole).value<void*>());

            if(bgLayer != NULL) {
                ui->listWidgetLayers->removeItemWidget(ui->listWidgetLayers->currentItem());
                bg->layerList->erase(std::find(bg->layerList->begin(), bg->layerList->end(), bgLayer));

            }
        }
    }


    populaListaLayers();
    backgroundsGraphicsScene->reloadBackground();



}
#include "configsgeneralwidget.h"
#include "ui_configsgeneralwidget.h"

ConfigsGeneralWidget::ConfigsGeneralWidget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ConfigsGeneralWidget)
{
    ui->setupUi(this);
    ui->editResolutionHeight->setValidator(new QIntValidator());
    ui->editResolutionWidth->setValidator(new QIntValidator());
    preencheDadosGerais();
    atualizaImagensTelas();
    atualizaVisualizacaoEditsResolucao();
    preencheEditsResolucao();
    preencheEditsMusicas();

    ativaMudancaComboMapaInicial = false;
    populaComboMapaInicial();
    ativaMudancaComboMapaInicial = true;
    preencheCurrentIndexComboInicialMap();
}

ConfigsGeneralWidget::~ConfigsGeneralWidget()
{
    delete ui;
}

void ConfigsGeneralWidget::changeEvent(QEvent *e)
{
    QWidget::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

void ConfigsGeneralWidget::setOptionsController(OptionsController *optionsController) {
    this->optionsController = optionsController;
}

void ConfigsGeneralWidget::atualizaImagensTelas() {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::cout << gameData->getProjectDirectory().append("/images/").append(gameData->gameoverScreenFile) << std::endl;

    QPixmap pixmap1, pixmap2, pixmap3;
    pixmap1 = QPixmap(QString(gameData->getProjectDirectory().append("/images/").append(gameData->titleScreenData.backgroundFile).c_str()));

    ui->labelTelaInicial->setPixmap(pixmap1.scaled(100, 75, Qt::KeepAspectRatio, Qt::SmoothTransformation));

    pixmap2 = QPixmap(QString(gameData->getProjectDirectory().append("/images/").append(gameData->optionsScreenFile).c_str()));

    ui->labelTelaOpcoes->setPixmap(pixmap2.scaled(100, 75, Qt::KeepAspectRatio, Qt::SmoothTransformation));

    pixmap3 = QPixmap(QString(gameData->getProjectDirectory().append("/images/").append(gameData->gameoverScreenFile).c_str()));

    ui->labelTelaGameOver->setPixmap(pixmap3.scaled(100, 75, Qt::KeepAspectRatio, Qt::SmoothTransformation));
}

void ConfigsGeneralWidget::on_buttonAlterarTelaInicial_clicked()
{
    ConfigsImportDialog *newDialog;
    newDialog = new ConfigsImportDialog(optionsController, ConfigsImportDialog::IMPORT_TITLESCREENS, EditorConstants::IMPORT_OPTION_TITLE_SCREEN);
    newDialog->setModal(true);
    newDialog->show();
}

void ConfigsGeneralWidget::on_buttonAlterarTelaOpcoes_clicked()
{
    ConfigsImportDialog *newDialog;
    newDialog = new ConfigsImportDialog(optionsController, ConfigsImportDialog::IMPORT_TITLESCREENS, EditorConstants::IMPORT_OPTION_OPTION_SCREEN);
    newDialog->setModal(true);
    newDialog->show();
}

void ConfigsGeneralWidget::on_buttonAlterarTelaGameOver_clicked()
{
    ConfigsImportDialog *newDialog;
    newDialog = new ConfigsImportDialog(optionsController, ConfigsImportDialog::IMPORT_TITLESCREENS, EditorConstants::IMPORT_OPTION_GAME_OVER_SCREEN);
    newDialog->setModal(true);
    newDialog->show();
}

void ConfigsGeneralWidget::atualizaVisualizacaoEditsResolucao() {
    if(ui->comboResolution->currentIndex() == 6) {
        ui->editResolutionHeight->setEnabled(true);
        ui->editResolutionWidth->setEnabled(true);
    } else {
        ui->editResolutionHeight->setEnabled(false);
        ui->editResolutionWidth->setEnabled(false);
    }
}

void ConfigsGeneralWidget::preencheDadosGerais() {
    GameData *gameData = GameData::getInstance();
    ui->editGameName->setText(QString(gameData->gameName->c_str()));

    if(gameData->resWidth == 320 && gameData->resHeight == 240) {
        ui->comboResolution->setCurrentIndex(0);
    } else if(gameData->resWidth == 640 && gameData->resHeight == 480) {
        ui->comboResolution->setCurrentIndex(1);
    } else if(gameData->resWidth == 640 && gameData->resHeight == 400) {
        ui->comboResolution->setCurrentIndex(2);
    } else if(gameData->resWidth == 800 && gameData->resHeight == 600) {
        ui->comboResolution->setCurrentIndex(3);
    } else if(gameData->resWidth == 1024 && gameData->resHeight == 786) {
        ui->comboResolution->setCurrentIndex(4);
    } else if(gameData->resWidth == 1280 && gameData->resHeight == 800) {
        ui->comboResolution->setCurrentIndex(5);
    } else {
        ui->comboResolution->setCurrentIndex(6);


        std::ostringstream resWidth, resHeight;

        resWidth << gameData->resWidth;
        resHeight << gameData->resHeight;

        ui->editResolutionWidth->setText(QString(resWidth.str().c_str()));
        ui->editResolutionHeight->setText(QString(resHeight.str().c_str()));
    }
}

void ConfigsGeneralWidget::preencheEditsResolucao() {
    switch(ui->comboResolution->currentIndex()) {
    case 0:
        ui->editResolutionWidth->setText("320");
        ui->editResolutionHeight->setText("240");
        break;
    case 1:
        ui->editResolutionWidth->setText("640");
        ui->editResolutionHeight->setText("480");
        break;
    case 2:
        ui->editResolutionWidth->setText("640");
        ui->editResolutionHeight->setText("400");
        break;
    case 3:
        ui->editResolutionWidth->setText("800");
        ui->editResolutionHeight->setText("600");
        break;
    case 4:
        ui->editResolutionWidth->setText("1024");
        ui->editResolutionHeight->setText("786");
        break;
    case 5:
        ui->editResolutionWidth->setText("1280");
        ui->editResolutionHeight->setText("800");
        break;
    }
}

void ConfigsGeneralWidget::preencheEditsMusicas() {
    GameData *gameData = GameData::getInstance();
    ui->lineEditMusicaTelaGameOver->setText(QString(gameData->gameOverScreenMusic.c_str()));
    ui->lineEditMusicaTelaInicial->setText(QString(gameData->titleScreenMusic.c_str()));
    std::cout << "Titlescreen Music: " << gameData->titleScreenMusic.c_str() << std::endl;
    ui->lineEditMusicaTelaOpcoes->setText(QString(gameData->optionsScreenMusic.c_str()));
}

void ConfigsGeneralWidget::on_comboResolution_currentIndexChanged(int index)
{
    atualizaVisualizacaoEditsResolucao();
    preencheEditsResolucao();
    optionsController->determinaValorResolucaoCombo(index);

}

void ConfigsGeneralWidget::on_editGameName_textChanged(QString string)
{
    GameData *gameData = GameData::getInstance();
    if(!string.isEmpty()) {
        delete gameData->gameName;
        gameData->gameName = new std::string(string.toStdString().c_str());
    }

}

void ConfigsGeneralWidget::on_editResolutionWidth_textChanged(QString string)
{
    GameData *gameData = GameData::getInstance();
    if(!string.isEmpty()) {
        gameData->resWidth = string.toInt();
    }
}

void ConfigsGeneralWidget::on_editResolutionHeight_textChanged(QString string)
{
    GameData *gameData = GameData::getInstance();
    if(!string.isEmpty()) {
        gameData->resHeight = string.toInt();
    }
}

void ConfigsGeneralWidget::populaComboMapaInicial() {
    GameData *gameData = GameData::getInstance();

    ui->comboInitialMap->clear();
    populaComboMapaInicialPercorreArvore(gameData->mapList, std::string(""));
}

void ConfigsGeneralWidget::populaComboMapaInicialPercorreArvore(std::vector<Map*> *mapList, std::string prefix) {
    for(std::vector<Map*>::iterator it = mapList->begin(); it != mapList->end(); ++it) {
        Map* map = *it;
        if(map->isFolder()) {
            populaComboMapaInicialPercorreArvore(map->filhos, std::string(prefix.c_str()).append(map->mapName).append(" > "));
        } else {
            ui->comboInitialMap->addItem(QString(prefix.c_str()).append(map->mapName.c_str()), QVariant(map->key));
            std::cout << "map-key: " << map->key << std::endl;
        }
    }
}

void ConfigsGeneralWidget::preencheCurrentIndexComboInicialMap() {
    GameData *gameData = GameData::getInstance();

    /* procurando na comboInicialMap uma ocorrencia do index gravado
       no GameData */

    int i;
    for(i = 0; i < ui->comboInitialMap->count(); i++) {
        int id = ui->comboInitialMap->itemData(i).toInt();
        if(id == gameData->idFirstMap) {
            ui->comboInitialMap->setCurrentIndex(i);
            break;
        }
    }

    // TODO: fazer ele verificar se um mapa não foi deletado
}

void ConfigsGeneralWidget::on_comboInitialMap_currentIndexChanged(int index)
{
    if(ativaMudancaComboMapaInicial) {
        GameData *gameData = GameData::getInstance();
        int idMapa = ui->comboInitialMap->itemData(index).toInt();
        gameData->idFirstMap = idMapa;
        std::cout << "idMapa: " << idMapa << std::endl;
    }

}

void ConfigsGeneralWidget::on_toolButtonMusicaTelaInicial_clicked()
{
    GameData *gameData = GameData::getInstance();

    SoundPickerDialog *soundPickerDialog = new SoundPickerDialog(SoundPickerDialog::MUSICA, this);
    soundPickerDialog->exec();

    if(soundPickerDialog->okPressed()) {
        ui->lineEditMusicaTelaInicial->setText(QString(soundPickerDialog->getSelectedFile().c_str()));
        gameData->titleScreenMusic = std::string(soundPickerDialog->getSelectedFile().c_str());
    }


    delete soundPickerDialog;
}

void ConfigsGeneralWidget::on_toolButtonMusicaTelaOpcoes_clicked()
{
    GameData *gameData = GameData::getInstance();

    SoundPickerDialog *soundPickerDialog = new SoundPickerDialog(SoundPickerDialog::MUSICA, this);
    soundPickerDialog->exec();

    if(soundPickerDialog->okPressed()) {
        ui->lineEditMusicaTelaOpcoes->setText(QString(soundPickerDialog->getSelectedFile().c_str()));
        gameData->optionsScreenMusic = std::string(soundPickerDialog->getSelectedFile().c_str());
    }


    delete soundPickerDialog;
}

void ConfigsGeneralWidget::on_toolButtonMusicaTelaGameOver_clicked()
{
    GameData *gameData = GameData::getInstance();

    SoundPickerDialog *soundPickerDialog = new SoundPickerDialog(SoundPickerDialog::MUSICA, this);
    soundPickerDialog->exec();

    if(soundPickerDialog->okPressed()) {
        ui->lineEditMusicaTelaGameOver->setText(QString(soundPickerDialog->getSelectedFile().c_str()));
        gameData->gameOverScreenMusic = std::string(soundPickerDialog->getSelectedFile().c_str());
    }


    delete soundPickerDialog;
}
#include "configsimportdialog.h"
#include "ui_configsimportdialog.h"

ConfigsImportDialog::ConfigsImportDialog(OptionsController *optionsController, int importType, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::ConfigsImportDialog)
{
    this->optionsController = optionsController;
    this->importType = importType;
    ui->setupUi(this);
    populaLista();

    returnString = NULL;

    if(importType != IMPORT_ANIMATIONS) {
        ui->comboBoxTipo->setVisible(false);
        ui->labelTipo->setVisible(false);
    }

    animationImportPattern = 0;
}

ConfigsImportDialog::ConfigsImportDialog(OptionsController *optionsController, int importType, int importOption, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::ConfigsImportDialog)
{
    this->optionsController = optionsController;
    this->importType = importType;
    this->importOption = importOption;
    ui->setupUi(this);
    populaLista();

    returnString = NULL;

    animationImportPattern = 0;
}

ConfigsImportDialog::~ConfigsImportDialog()
{
    delete ui;
}

void ConfigsImportDialog::populaLista() {
    GameData *gameData;
    gameData = GameData::getInstance();

    QDir *dir;
    QStringList files;
    QStringList filters;

    switch(importType) {
    case IMPORT_TILESETS:
        dir = new QDir(gameData->getProjectDirectory().append("/tilesets/").c_str());
        filters << "*.png" << "*.jpg" << "*.gif" << "*.bmp";

        break;

    case IMPORT_TITLESCREENS:
        dir = new QDir(gameData->getProjectDirectory().append("/images/").c_str());
        filters << "*.png" << "*.jpg" << "*.gif" << "*.bmp";

        break;
    case IMPORT_ANIMATIONS:
        dir = new QDir(gameData->getProjectDirectory().append("/animations/").c_str());
        filters << "*.png" << "*.jpg" << "*.gif" << "*.bmp";

        break;
    case IMPORT_SPRITE:
        dir = new QDir(gameData->getProjectDirectory().append("/objects/").c_str());
        filters << "*.png" << "*.jpg" << "*.gif" << "*.bmp";

        break;
    case IMPORT_BACKGROUND:
        dir = new QDir(gameData->getProjectDirectory().append("/images/").c_str());
        filters << "*.png" << "*.jpg" << "*.gif" << "*.bmp";

        break;

    case IMPORT_LAYER:
        dir = new QDir(gameData->getProjectDirectory().append("/images/").c_str());
        filters << "*.png" << "*.jpg" << "*.gif" << "*.bmp";

        break;
    }




    dir->setNameFilters(filters);

    files = dir->entryList();


    ui->listWidget->clear();
    for(QStringList::Iterator it = files.begin(); it != files.end(); ++it) {
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(*it);
        ui->listWidget->addItem(newItem);
    }
}

void ConfigsImportDialog::on_botaoSelecionar_clicked()
{
    if(ui->listWidget->currentItem() == NULL) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Necessário importar um recurso antes."));
    } else {
        switch(importType) {
        case IMPORT_TILESETS:
            optionsController->addTileset(ui->listWidget->currentItem()->text().toStdString());
            break;

        case IMPORT_TITLESCREENS:
            optionsController->setGameScreen(ui->listWidget->currentItem()->text().toStdString(), importOption);
            break;

        case IMPORT_ANIMATIONS:
            optionsController->addAnimation(ui->listWidget->currentItem()->text().toStdString(), animationImportPattern);
            break;

        case IMPORT_SPRITE:
            returnString = new std::string(ui->listWidget->currentItem()->text().toStdString().c_str());
            break;
        case IMPORT_BACKGROUND:
            optionsController->addBackground(ui->listWidget->currentItem()->text().toStdString());
            break;

        case IMPORT_LAYER:
            returnString = new std::string(ui->listWidget->currentItem()->text().toStdString().c_str());
            break;
        }



        this->close();
    }
}

void ConfigsImportDialog::on_botaoImportar_clicked()
{
    QStringList fileNames;


    fileNames = QFileDialog::getOpenFileNames(this, tr("Open Project"), "", tr("(*.png *.jpg *.bmp *.gif)"));


    for(QStringList::Iterator it = fileNames.begin(); it != fileNames.end(); ++it) {
        QString fileName = *it;

        if(!fileName.isEmpty()) {
            optionsController->importResource(fileName.toStdString(), importType);
            populaLista();
            for(int i = 0; i < ui->listWidget->count(); i++) {
                if(ui->listWidget->itemAt(i, 0)->text().compare(fileName)) {
                    ui->listWidget->setCurrentItem(ui->listWidget->itemAt(i, 0));
                }
            }
        }
    }
}

void ConfigsImportDialog::on_botaoCancelar_clicked()
{
    this->close();
}

void ConfigsImportDialog::on_listWidget_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    QPixmap image;
    std::string diretorio;
    GameData *gameData;

    if(current != NULL) {
        gameData = GameData::getInstance();

        switch(importType) {
        case IMPORT_TILESETS:
            diretorio = gameData->getProjectDirectory().append("/tilesets/");
            break;
        case IMPORT_TITLESCREENS:
            diretorio = gameData->getProjectDirectory().append("/images/");
            break;
        case IMPORT_ANIMATIONS:
            diretorio = gameData->getProjectDirectory().append("/animations/");
            break;
        case IMPORT_SPRITE:
            diretorio = gameData->getProjectDirectory().append("/objects/");
            break;
        case IMPORT_BACKGROUND:
            diretorio = gameData->getProjectDirectory().append("/images/");
            break;
        case IMPORT_LAYER:
            diretorio = gameData->getProjectDirectory().append("/images/");
            break;
        }


        diretorio.append(current->text().toStdString().c_str());

        image = QPixmap(diretorio.c_str());



        ui->imagethumbnail->setPixmap(image.scaledToWidth(200 , Qt::SmoothTransformation));
    }
}

std::string *ConfigsImportDialog::getReturnString() {
    return returnString;
}

void ConfigsImportDialog::on_comboBoxTipo_currentIndexChanged(int index)
{
    animationImportPattern = index;
}
#include "configsnewobjectwindow.h"
#include "ui_configsnewobjectwindow.h"

ConfigsNewObjectWindow::ConfigsNewObjectWindow(OptionsController *optionsController, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::ConfigsNewObjectWindow), optionsController(optionsController)
{
    ui->setupUi(this);
}

ConfigsNewObjectWindow::~ConfigsNewObjectWindow()
{
    delete ui;
}

void ConfigsNewObjectWindow::changeEvent(QEvent *e)
{
    QDialog::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

void ConfigsNewObjectWindow::on_buttonBox_accepted()
{
    /* validação */
    if(ui->lineEditName->text().isEmpty()) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Necessita digitar o nome."));

        this->show();
    } else {
        optionsController->addObject(ui->lineEditName->text().toStdString(), ui->comboTipo->currentIndex());
    }
}
#include "configsobjanimationchooserwindow.h"
#include "ui_configsobjanimationchooserwindow.h"

ConfigsObjAnimationChooserWindow::ConfigsObjAnimationChooserWindow(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::ConfigsObjAnimationChooserWindow),
    optionsController(optionsController),
    gameObject(gameObject),
    currentListItem(currentListItem)
{
    ui->setupUi(this);

    copyGameObjectAnimation();

    populaListaEstados();
    populaListaAnimacoes();

    ui->labelDirectionNumber->setText(QString::number(ui->horizontalSliderDirectionNumber->value()*4).append(" dirs"));

    ui->groupBoxDirecao->setEnabled(false);
    ui->groupBoxSpriteAnim->setEnabled(false);
    ui->groupBoxVisu->setEnabled(false);

    currentGameObjectAnimation = NULL;

    animationGraphicsScene = new AnimationGraphicsScene(ui->graphicsView);
    ui->graphicsView->setScene(animationGraphicsScene);


}

ConfigsObjAnimationChooserWindow::~ConfigsObjAnimationChooserWindow()
{
    delete ui;
    delete animationGraphicsScene;
}


void ConfigsObjAnimationChooserWindow::on_horizontalSliderDirectionNumber_valueChanged(int value)
{
    ui->dial->setMaximum(pow(2, value));
    ui->labelDirectionNumber->setText(QString::number(pow(2, value)).append(" dirs"));
}

void ConfigsObjAnimationChooserWindow::populaListaEstados() {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::vector<GameObjectAnimation*> *gameObjectAnimationList;


    gameObjectAnimationList = gameObjectAnimations;

    ui->listWidgetEstados->clear();

    for(std::vector<GameObjectAnimation*>::iterator it = gameObjectAnimationList->begin(); it != gameObjectAnimationList->end(); ++it) {
        GameObjectAnimation *iterationItem;

        iterationItem = *it;
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString(iterationItem->name.c_str()));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) iterationItem));
        ui->listWidgetEstados->addItem(newItem);

    }
}

void ConfigsObjAnimationChooserWindow::populaListaAnimacoes() {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::vector<AnimationData*> *animationDataList;


    animationDataList = gameData->animationDataList;

    ui->listWidget->clear();

    QListWidgetItem *newItem = new QListWidgetItem();
    newItem->setText("-----");
    newItem->setData(Qt::UserRole, QVariant::fromValue((void*) NULL));
    ui->listWidget->addItem(newItem);

    for(std::vector<AnimationData*>::iterator it = animationDataList->begin(); it != animationDataList->end(); ++it) {
        AnimationData *iterationItem;

        iterationItem = *it;
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString(iterationItem->name.c_str()));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) iterationItem));
        newItem->setIcon(QIcon(QPixmap::fromImage(iterationItem->getIconImage())));
        ui->listWidget->addItem(newItem);

    }
}

void ConfigsObjAnimationChooserWindow::mostraAnimacaoVisualizacao() {
    if(ui->listWidget->currentItem() != NULL) {
        AnimationData *animationData = (AnimationData*) ui->listWidget->currentItem()->data(Qt::UserRole).value<void*>();

        if(animationData != NULL) {
            animationGraphicsScene->addAnimationData(animationData);
        } else {
            animationGraphicsScene->removeGraphics();
        }
    }

}

void ConfigsObjAnimationChooserWindow::mostraSpriteVisualizacao() {
    std::string diretorio = std::string("objects/");
    diretorio.append(ui->lineEditSprite->text().toStdString());

    if(!ui->lineEditSprite->text().isEmpty()) {
        animationGraphicsScene->addSpriteData(diretorio);
    } else {
        animationGraphicsScene->removeGraphics();
    }
}

void ConfigsObjAnimationChooserWindow::copyGameObjectAnimation() {
    gameObjectAnimations = new std::vector<GameObjectAnimation*>(gameObject->gameObjectAnimations->size());

    for(unsigned int i = 0; i < gameObject->gameObjectAnimations->size(); i++) {
        GameObjectAnimation *gameObjectAnimation = new GameObjectAnimation(*gameObject->gameObjectAnimations->at(i));

        gameObjectAnimation->sprites = new std::vector<Sprite*>(gameObject->gameObjectAnimations->at(i)->sprites->size());

        for(unsigned int j = 0; j < gameObject->gameObjectAnimations->at(i)->sprites->size(); j++) {
            Sprite *sprite = new Sprite(*gameObject->gameObjectAnimations->at(i)->sprites->at(j));

            gameObjectAnimation->sprites->at(j) = sprite;
        }

        gameObjectAnimation->animations = new std::vector<AnimationData*>(gameObject->gameObjectAnimations->at(i)->animations->size());

        for(unsigned int j = 0; j < gameObject->gameObjectAnimations->at(i)->animations->size(); j++) {
            gameObjectAnimation->animations->at(j) = gameObject->gameObjectAnimations->at(i)->animations->at(j);
        }

        gameObjectAnimation->types = new std::vector<int>(gameObject->gameObjectAnimations->at(i)->types->size());

        for(unsigned int j = 0; j < gameObject->gameObjectAnimations->at(i)->types->size(); j++) {
            gameObjectAnimation->types->at(j) = gameObject->gameObjectAnimations->at(i)->types->at(j);
        }

        gameObjectAnimations->at(i) = gameObjectAnimation;



    }

}

void ConfigsObjAnimationChooserWindow::preencheCamposCurrentDirection() {
    int direction = getDialConvertedValue();
    int type;
    Sprite *currentSprite = currentGameObjectAnimation->sprites->at(direction);
    AnimationData *currentAnimationData = currentGameObjectAnimation->animations->at(direction);

    type = currentGameObjectAnimation->types->at(direction);
    ui->tabWidgetSpriteAnim->setCurrentIndex(type);

    if(currentSprite != NULL) {
         ui->lineEditSprite->setText(QString(currentSprite->spriteFileName.c_str()));
    }

    ui->checkBoxInvertHorizontal->setChecked(currentGameObjectAnimation->horizontalInvert.at(direction));
    ui->checkBoxInvertHorizontal2->setChecked(currentGameObjectAnimation->horizontalInvert.at(direction));
    ui->checkBoxInvertVertical->setChecked(currentGameObjectAnimation->verticalInvert.at(direction));
    ui->checkBoxInvertVertically2->setChecked(currentGameObjectAnimation->verticalInvert.at(direction));

    if(currentAnimationData == NULL) {
        ui->listWidget->setCurrentItem(ui->listWidget->itemAt(0, 0));
    } else {
        for(int i = 1; i < ui->listWidget->count(); i++) {
            AnimationData *animationData = (AnimationData*) ui->listWidget->item(i)->data(Qt::UserRole).value<void*>();
            if(animationData->id == currentAnimationData->id) {
                ui->listWidget->setCurrentItem(ui->listWidget->item(i));

            }
        }
    }

    animationGraphicsScene->setAdjustPoint(currentGameObjectAnimation->adjustments.at(direction).x,
                                           currentGameObjectAnimation->adjustments.at(direction).y);

    ui->spinBoxAdjustX->setValue(currentGameObjectAnimation->adjustments.at(direction).x);
    ui->spinBoxAdjustX2->setValue(currentGameObjectAnimation->adjustments.at(direction).x);
    ui->spinBoxAdjustY->setValue(currentGameObjectAnimation->adjustments.at(direction).y);
    ui->spinBoxAdjustY2->setValue(currentGameObjectAnimation->adjustments.at(direction).y);

}

int ConfigsObjAnimationChooserWindow::getDialConvertedValue() {
    int value = ui->dial->value();

    return (int)(value*(pow(2, 5 - ui->horizontalSliderDirectionNumber->value())) + 8)%32;
}

void ConfigsObjAnimationChooserWindow::on_dial_valueChanged(int value)
{
    ui->spinBoxDirectionValue->setValue(getDialConvertedValue());
    preencheCamposCurrentDirection();

    atualizaVisualizacao();
}

void ConfigsObjAnimationChooserWindow::on_listWidgetEstados_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    currentGameObjectAnimation = (GameObjectAnimation*) current->data(Qt::UserRole).value<void*>();

    if(currentGameObjectAnimation != NULL) {
        ui->groupBoxDirecao->setEnabled(true);
        ui->groupBoxSpriteAnim->setEnabled(true);
        ui->groupBoxVisu->setEnabled(true);
        preencheCamposCurrentDirection();

        atualizaVisualizacao();
    }




}

void ConfigsObjAnimationChooserWindow::on_tabWidgetSpriteAnim_currentChanged(int index)
{
    currentGameObjectAnimation->types->at(getDialConvertedValue()) = index;

    atualizaVisualizacao();


}

void ConfigsObjAnimationChooserWindow::atualizaVisualizacao() {
    int index = ui->tabWidgetSpriteAnim->currentIndex();

    switch(index) {
    case 0:
        animationGraphicsScene->removeGraphics();
        break;
    case 1:
        mostraSpriteVisualizacao();
        break;
    case 2:
        mostraAnimacaoVisualizacao();
        break;
    default:

        break;
    }
}


void ConfigsObjAnimationChooserWindow::on_checkBoxInvertHorizontal_toggled(bool checked)
{
    currentGameObjectAnimation->horizontalInvert.at(getDialConvertedValue()) = checked;
    ui->checkBoxInvertHorizontal2->setChecked(checked);
}

void ConfigsObjAnimationChooserWindow::on_checkBoxInvertVertical_toggled(bool checked)
{
    currentGameObjectAnimation->verticalInvert.at(getDialConvertedValue()) = checked;
    ui->checkBoxInvertVertically2->setChecked(checked);
}

void ConfigsObjAnimationChooserWindow::on_checkBoxInvertHorizontal2_toggled(bool checked)
{
    currentGameObjectAnimation->horizontalInvert.at(getDialConvertedValue()) = checked;
    ui->checkBoxInvertHorizontal->setChecked(checked);
}

void ConfigsObjAnimationChooserWindow::on_checkBoxInvertVertically2_toggled(bool checked)
{
    currentGameObjectAnimation->verticalInvert.at(getDialConvertedValue()) = checked;
    ui->checkBoxInvertVertical->setChecked(checked);
}

void ConfigsObjAnimationChooserWindow::on_pushButtonSpriteChooser_pressed()
{
    ConfigsImportDialog *configsImportDialog = new ConfigsImportDialog(optionsController, ConfigsImportDialog::IMPORT_SPRITE, this);

    configsImportDialog->exec();

    std::string *stringReturn = configsImportDialog->getReturnString();

    delete configsImportDialog;

    if(stringReturn != NULL) {
        ui->lineEditSprite->setText(QString(stringReturn->c_str()));

        currentGameObjectAnimation->sprites->at(getDialConvertedValue())->spriteFileName = std::string(stringReturn->c_str());

        delete stringReturn;

        atualizaVisualizacao();
    }


}

void ConfigsObjAnimationChooserWindow::on_listWidget_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    currentGameObjectAnimation->animations->at(getDialConvertedValue()) = (AnimationData*) current->data(Qt::UserRole).value<void*>();

    atualizaVisualizacao();
}

bool ConfigsObjAnimationChooserWindow::verificaSeParadoTemAnimacao() {
    GameObjectAnimation *testGameObjectAnimation = gameObjectAnimations->at(0);

    int i = 0;
    for(std::vector<int>::iterator it = testGameObjectAnimation->types->begin(); it != testGameObjectAnimation->types->end(); ++it) {
        int valor = *it;

        if(valor != 0) {

            if(valor == 1) {
                Sprite *testSprite;
                testSprite = testGameObjectAnimation->sprites->at(i);

                if(!testSprite->spriteFileName.empty()) {
                    return true;
                }
            } else {
                AnimationData *testAnimationData;
                testAnimationData = testGameObjectAnimation->animations->at(i);

                if(testAnimationData != NULL) {
                    return true;
                }
            }



        }

        i++;
    }

    return false;
}

void ConfigsObjAnimationChooserWindow::limpaDadosAntigos() {
    for(std::vector<GameObjectAnimation*>::iterator it = gameObject->gameObjectAnimations->begin(); it != gameObject->gameObjectAnimations->end(); ++it) {
        GameObjectAnimation *testGameObjectAnimation = *it;

        int i = 0;
        for(std::vector<int>::iterator it2 = testGameObjectAnimation->types->begin(); it2 != testGameObjectAnimation->types->end(); ++it2) {
            int value = *it2;

            switch(value) {
            case 1:
                delete testGameObjectAnimation->sprites->at(i);
                break;
            case 2:
                testGameObjectAnimation->animations->at(i) = NULL;
                break;
            default:

                break;
            }

            i++;
        }

        delete testGameObjectAnimation->types;
        delete testGameObjectAnimation->sprites;
        delete testGameObjectAnimation->animations;


        delete testGameObjectAnimation;
    }

    delete gameObject->gameObjectAnimations;
    gameObject->gameObjectAnimations = NULL;
}

void ConfigsObjAnimationChooserWindow::corrigeDadosArmazenamento() {

    for(std::vector<GameObjectAnimation*>::iterator it = gameObjectAnimations->begin(); it != gameObjectAnimations->end(); ++it) {
        GameObjectAnimation *testGameObjectAnimation = *it;

        int i = 0;
        for(std::vector<int>::iterator it2 = testGameObjectAnimation->types->begin(); it2 != testGameObjectAnimation->types->end(); ++it2) {
            int value = *it2;

            switch(value) {
            case 1:
                testGameObjectAnimation->animations->at(i) = NULL;
                break;
            case 2:
                delete testGameObjectAnimation->sprites->at(i);
                testGameObjectAnimation->sprites->at(i) = new Sprite();
                break;
            default:

                break;
            }

            i++;
        }

    }



}

void ConfigsObjAnimationChooserWindow::on_buttonBox_accepted()
{
    // validando o novo gameObjectAnimations
    if(verificaSeParadoTemAnimacao()) {
        corrigeDadosArmazenamento();
        limpaDadosAntigos();
        gameObject->gameObjectAnimations = gameObjectAnimations;
    } else {
        MessageBoxes::showMessageBox(QString::fromUtf8("É necessário ter ao menos uma representação gráfica em \"Parado\""));
    }



}

void ConfigsObjAnimationChooserWindow::on_spinBoxAdjustX_valueChanged(int value)
{
    currentGameObjectAnimation->adjustments.at(getDialConvertedValue()).x = value;
    ui->spinBoxAdjustX2->setValue(value);
    animationGraphicsScene->setAdjustPoint(ui->spinBoxAdjustX->value(), ui->spinBoxAdjustY->value());
}

void ConfigsObjAnimationChooserWindow::on_spinBoxAdjustY_valueChanged(int value)
{
    currentGameObjectAnimation->adjustments.at(getDialConvertedValue()).y = value;
    ui->spinBoxAdjustY2->setValue(value);
    animationGraphicsScene->setAdjustPoint(ui->spinBoxAdjustX->value(), ui->spinBoxAdjustY->value());
}

void ConfigsObjAnimationChooserWindow::on_spinBoxAdjustX2_valueChanged(int value)
{
    currentGameObjectAnimation->adjustments.at(getDialConvertedValue()).x = value;
    ui->spinBoxAdjustX->setValue(value);
    animationGraphicsScene->setAdjustPoint(ui->spinBoxAdjustX->value(), ui->spinBoxAdjustY->value());
}

void ConfigsObjAnimationChooserWindow::on_spinBoxAdjustY2_valueChanged(int value)
{
    currentGameObjectAnimation->adjustments.at(getDialConvertedValue()).y = value;
    ui->spinBoxAdjustY->setValue(value);
    animationGraphicsScene->setAdjustPoint(ui->spinBoxAdjustX->value(), ui->spinBoxAdjustY->value());
}
#include "configsobjattributeswidget.h"
#include "ui_configsobjattributeswidget.h"

ConfigsObjAttributesWidget::ConfigsObjAttributesWidget(OptionsController *optionsController, GameObject *gameObject,QListWidgetItem *currentListItem, QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ConfigsObjAttributesWidget),
    optionsController(optionsController),
    gameObject(gameObject),
    currentListItem(currentListItem)
{
    ui->setupUi(this);


    populaCampos();
    decideLevelEvolutionVisibility();
}

void ConfigsObjAttributesWidget::decideLevelEvolutionVisibility() {
    if(!ui->checkBoxLevelEvolution->isChecked()) {
        ui->labelEvoVelocity->setDisabled(true);
        ui->labelInitialLevel->setDisabled(true);
        ui->labelLabelAux->setDisabled(true);
        ui->labelmaxLevel->setDisabled(true);
        ui->spinBoxInitialLevel->setDisabled(true);
        ui->spinBoxMaxLevel->setDisabled(true);
        ui->horizontalSliderEvolutionVelocity->setDisabled(true);
    } else {
        ui->labelEvoVelocity->setDisabled(false);
        ui->labelInitialLevel->setDisabled(false);
        ui->labelLabelAux->setDisabled(false);
        ui->labelmaxLevel->setDisabled(false);
        ui->spinBoxInitialLevel->setDisabled(false);
        ui->spinBoxMaxLevel->setDisabled(false);
        ui->horizontalSliderEvolutionVelocity->setDisabled(false);
    }
}

void ConfigsObjAttributesWidget::populaCampos() {
    ui->spinBoxHp->setValue(gameObject->hp);
    ui->spinBoxMp->setValue(gameObject->mp);
    ui->spinBoxAtk->setValue(gameObject->atk);
    ui->spinBoxDef->setValue(gameObject->def);
    ui->spinBoxInitialLevel->setValue(gameObject->levelInicial);
    ui->spinBoxInt->setValue(gameObject->intelig);
    ui->spinBoxMaxLevel->setValue(gameObject->levelMax);

    ui->checkBoxLevelEvolution->setChecked(gameObject->evolucaoPorNivel);
    ui->horizontalSliderEvolutionVelocity->setValue(gameObject->velocidadeEvolucao);

}

ConfigsObjAttributesWidget::~ConfigsObjAttributesWidget()
{
    delete ui;
}

void ConfigsObjAttributesWidget::on_checkBoxLevelEvolution_toggled(bool checked)
{
    gameObject->evolucaoPorNivel = checked;
    decideLevelEvolutionVisibility();
}




void ConfigsObjAttributesWidget::on_spinBoxHp_valueChanged(int value)
{
    gameObject->hp = value;
}

void ConfigsObjAttributesWidget::on_spinBoxMp_valueChanged(int value)
{
    gameObject->mp = value;
}

void ConfigsObjAttributesWidget::on_spinBoxAtk_valueChanged(int value)
{
    gameObject->atk = value;
}

void ConfigsObjAttributesWidget::on_spinBoxDef_valueChanged(int value)
{
    gameObject->def = value;
}

void ConfigsObjAttributesWidget::on_spinBoxInt_valueChanged(int value)
{
    gameObject->intelig = value;
}

void ConfigsObjAttributesWidget::on_spinBoxInitialLevel_valueChanged(int value)
{
    gameObject->levelInicial = value;
}

void ConfigsObjAttributesWidget::on_spinBoxMaxLevel_valueChanged(int value)
{
    gameObject->levelMax = value;
}

void ConfigsObjAttributesWidget::on_horizontalSliderEvolutionVelocity_valueChanged(int value)
{
    gameObject->velocidadeEvolucao = value;
}
#include "configsobjdadosgeraiswidget.h"
#include "ui_configsobjdadosgeraiswidget.h"

ConfigsObjDadosGeraisWidget::ConfigsObjDadosGeraisWidget(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem, QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ConfigsObjDadosGeraisWidget),
    optionsController(optionsController),
    gameObject(gameObject),
    currentListItem(currentListItem)
{
    ui->setupUi(this);

    ui->editNome->setText(QString(gameObject->name.c_str()));

    ui->comboFormaGrafica->setCurrentIndex(gameObject->formaGrafica);
    ui->checkBoxObjUnico->setChecked(gameObject->isObjetoUnico);

    scene = new QGraphicsScene(this);
    item =
            new QGraphicsPixmapItem(QPixmap::fromImage(gameObject->getIconImage()));

    item->setPos(0, 0);

    scene->addItem(item);

    ui->graphicsViewSprite->setScene(scene);


}

ConfigsObjDadosGeraisWidget::~ConfigsObjDadosGeraisWidget()
{
    delete ui;
}

void ConfigsObjDadosGeraisWidget::on_editNome_textChanged(QString text )
{
    currentListItem->setText(text);
    gameObject->name = text.toStdString();
}

void ConfigsObjDadosGeraisWidget::on_checkBoxObjUnico_toggled(bool checked)
{
    gameObject->isObjetoUnico = checked;
}

void ConfigsObjDadosGeraisWidget::on_comboFormaGrafica_currentIndexChanged(int index)
{
    gameObject->formaGrafica = index;
}

void ConfigsObjDadosGeraisWidget::on_botaoEditarFormaGrafica_clicked()
{
    ConfigsObjAnimationChooserWindow *configsObjAnimationChooserWindow =
            new ConfigsObjAnimationChooserWindow(optionsController,
                                                       gameObject,
                                                       currentListItem,
                                                       this);

    configsObjAnimationChooserWindow->setWindowTitle("Graficos do objeto");

    configsObjAnimationChooserWindow->exec();

    delete configsObjAnimationChooserWindow;

    currentListItem->setIcon(QIcon(QPixmap::fromImage(gameObject->getIconImage())));

    scene->removeItem(item);

    delete item;

    item =
            new QGraphicsPixmapItem(QPixmap::fromImage(gameObject->getIconImage()));

    item->setPos(0, 0);

    scene->addItem(item);

}
#include "configsobjectswidget.h"
#include "ui_configsobjectswidget.h"

ConfigsObjectsWidget::ConfigsObjectsWidget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ConfigsObjectsWidget)
{
    ui->setupUi(this);

    specificWidget = NULL;

    specificWidget = new ConfigsObjGenericWidget(this);
    ui->scrollArea->setWidget(specificWidget);

    configsTabWidget = NULL;

    populaListaPersonagem();
}

ConfigsObjectsWidget::~ConfigsObjectsWidget()
{
    delete ui;
}

void ConfigsObjectsWidget::changeEvent(QEvent *e)
{
    QWidget::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

void ConfigsObjectsWidget::on_pushButton_clicked()
{
    configsNewObjectWindow = new ConfigsNewObjectWindow(optionsController, this);
    configsNewObjectWindow->setModal(true);
    configsNewObjectWindow->setWindowTitle(QString("Novo objeto"));
    configsNewObjectWindow->show();
}

void ConfigsObjectsWidget::on_listPersonagem_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    if(current != 0x0) {
        GameObject* currentObject;
        currentObject = (GameObject*) current->data(Qt::UserRole).value<void*>();

        specificWidget->removeAllWidgets();
        specificWidget->addWidgets(optionsController, currentObject, current);


    }


}


void ConfigsObjectsWidget::setOptionsController(OptionsController *optionsController) {
    this->optionsController = optionsController;
}

void ConfigsObjectsWidget::populaListaPersonagem() {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::vector<GameObject*>* objectList;

    objectList = gameData->objectList;

    ui->listPersonagem->clear();

    for(std::vector<GameObject*>::iterator it = objectList->begin(); it != objectList->end(); ++it) {
        GameObject *gameObject;
        gameObject = *it;

        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString(gameObject->name.c_str()));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) gameObject));
        newItem->setIcon(QIcon(QPixmap::fromImage(gameObject->getIconImage())));

        ui->listPersonagem->addItem(newItem);
    }

}

void ConfigsObjectsWidget::selectObject(GameObject *gameObject) {
    int nro_elementos = ui->listPersonagem->count();

    for(int i = 0; i < nro_elementos; i++) {
        QListWidgetItem *item = ui->listPersonagem->item(i);
        GameObject *gameObjectItem = (GameObject*) item->data(Qt::UserRole).value<void*>();
        if(gameObjectItem->id == gameObject->id) {
            ui->listPersonagem->setCurrentItem(item);
            break;
        }
    }
}

void ConfigsObjectsWidget::setConfigsTabWidget(ConfigsTabWidget *configsTabWidget) {
    this->configsTabWidget = configsTabWidget;
    this->specificWidget->setConfigsTabWidget(configsTabWidget);
}
#include "configsobjgenericwidget.h"
#include "ui_configsobjgenericwidget.h"

ConfigsObjGenericWidget::ConfigsObjGenericWidget(QWidget *parent) :
    QWidget(parent),
    gameObject(gameObject),
    optionsController(optionsController),
    currentListItem(currentListItem),
    ui(new Ui::ConfigsObjGenericWidget),
    parent(parent)
{
    ui->setupUi(this);

    layout = new QVBoxLayout(this);
    layout->setMargin(5);
    layout->setSpacing(0);

    configsObjDadosGeraisWidget = NULL;
    configsObjAttributesWidget = NULL;
    configsObjBehaviorWidget = NULL;
    configsObjItem = NULL;
    configsObjPhysicsWidget = NULL;
    configsObjHabilidadesWidget = NULL;

    configsTabWidget = NULL;


}

void ConfigsObjGenericWidget::addWidgets(OptionsController *optionsController,GameObject *gameObject, QListWidgetItem *currentListItem) {

    configsObjDadosGeraisWidget = new ConfigsObjDadosGeraisWidget(optionsController, gameObject, currentListItem, parent);
    layout->addWidget(configsObjDadosGeraisWidget);



    if(gameObject->type == GameObject::NPC ||
       gameObject->type == GameObject::INIMIGO) {
        configsObjBehaviorWidget = new ConfigsObjNpcBehaviorWidget(optionsController, gameObject, currentListItem, parent);
        layout->addWidget(configsObjBehaviorWidget);
    } else if(gameObject->type == GameObject::ITEM) {
        configsObjItem = new ConfigsObjItem(optionsController, gameObject, currentListItem, parent);
        layout->addWidget(configsObjItem);
    } else {
        configsObjPhysicsWidget = new ConfigsObjPhysicsWidget(optionsController, gameObject, currentListItem, parent);
        layout->addWidget(configsObjPhysicsWidget);
    }

    if(gameObject->type != GameObject::ITEM && gameObject->type != GameObject::NPC) {
        configsObjAttributesWidget = new ConfigsObjAttributesWidget(optionsController, gameObject, currentListItem, parent);
        layout->addWidget(configsObjAttributesWidget);
    }

    configsObjHabilidadesWidget = new ConfigsObjHabilidadesWidget(optionsController, gameObject, currentListItem, parent);
    configsObjHabilidadesWidget->setConfigsTabWidget(configsTabWidget);
    layout->addWidget(configsObjHabilidadesWidget);
}

void ConfigsObjGenericWidget::removeAllWidgets() {
    if(configsObjDadosGeraisWidget != NULL) {
        layout->removeWidget(configsObjDadosGeraisWidget);

        delete configsObjDadosGeraisWidget;
        configsObjDadosGeraisWidget = NULL;
    }


    if(configsObjAttributesWidget != NULL) {
        layout->removeWidget(configsObjAttributesWidget);

        delete configsObjAttributesWidget;
        configsObjAttributesWidget = NULL;
    }


    if(configsObjBehaviorWidget != NULL) {
        layout->removeWidget(configsObjBehaviorWidget);

        delete configsObjBehaviorWidget;
        configsObjBehaviorWidget = NULL;
    }

    if(configsObjItem != NULL) {
        layout->removeWidget(configsObjItem);

        delete configsObjItem;
        configsObjItem = NULL;
    }

    if(configsObjPhysicsWidget != NULL) {
        layout->removeWidget(configsObjPhysicsWidget);

        delete configsObjPhysicsWidget;
        configsObjPhysicsWidget = NULL;
    }


    if(configsObjHabilidadesWidget != NULL) {
        layout->removeWidget(configsObjHabilidadesWidget);

        delete configsObjHabilidadesWidget;
        configsObjHabilidadesWidget = NULL;
    }
}

ConfigsObjGenericWidget::~ConfigsObjGenericWidget()
{
    delete ui;
}

void ConfigsObjGenericWidget::setConfigsTabWidget(ConfigsTabWidget *configsTabWidget) {
    this->configsTabWidget = configsTabWidget;
}
#include "configsobjhabilidadeswidget.h"
#include "ui_configsobjhabilidadeswidget.h"

ConfigsObjHabilidadesWidget::ConfigsObjHabilidadesWidget(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem, QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ConfigsObjHabilidadesWidget),
    optionsController(optionsController),
    gameObject(gameObject),
    currentListItem(currentListItem)
{
    ui->setupUi(this);

    if(gameObject->type == GameObject::ITEM ||
       gameObject->type == GameObject::NPC |
       gameObject->type == GameObject::INIMIGO ||
       gameObject->type == GameObject::STATIC_OBJECT) {
        ui->groupBoxHabilidades->setVisible(false);
    } else {
        ui->groupBoxHabilidades->setVisible(true);
    }


    populaListaSkills();
}

ConfigsObjHabilidadesWidget::~ConfigsObjHabilidadesWidget()
{
    delete ui;
}

void ConfigsObjHabilidadesWidget::populaListaSkills() {
    ui->treeWidgetSkills->clear();

    for(std::vector<SkillData*>::iterator it = gameObject->listaHabilidades.begin(); it != gameObject->listaHabilidades.end(); ++it) {
        SkillData* skillData = *it;


        std::stringstream ss1, ss2;
        ss1.str("");
        ss1 << skillData->intensity;

        ss2.str("");
        if(skillData->level > 0) {
            ss2 << skillData->level;
        } else {
            ss2 << "-";
        }


        QTreeWidgetItem *treeItem = new QTreeWidgetItem(QStringList()
                                                    << QString(skillData->skill->name.c_str())
                                                    << QString(ss1.str().c_str())
                                                    << QString(ss2.str().c_str()));

        treeItem->setData(0, Qt::UserRole, QVariant::fromValue((void*) skillData));


        ui->treeWidgetSkills->insertTopLevelItem(0, treeItem);
    }
}

void ConfigsObjHabilidadesWidget::on_comboEvoNivel_currentIndexChanged(int index)
{
    gameObject->evolucaoPorNivel = !index;

}

void ConfigsObjHabilidadesWidget::on_botaoOpcoes_clicked()
{

}

void ConfigsObjHabilidadesWidget::on_botaoAddHabilidade_clicked()
{

}

void ConfigsObjHabilidadesWidget::on_botaoEditorEventos_clicked()
{

}

void ConfigsObjHabilidadesWidget::on_botaoAddHabilidade_pressed()
{
    SkillData *skillData;

    ConfigsObjNewSkillDialog *configsObjNewSkillDialog;
    configsObjNewSkillDialog = new ConfigsObjNewSkillDialog(gameObject);
    configsObjNewSkillDialog->setWindowTitle("Nova habilidade");

    skillData = configsObjNewSkillDialog->exec();

    if(skillData != NULL) {
        optionsController->addObjectSkill(gameObject, skillData);
        populaListaSkills();
    }
}

void ConfigsObjHabilidadesWidget::on_listHabilidades_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{

}

void ConfigsObjHabilidadesWidget::on_pushButtonRemove_pressed()
{
    if(ui->treeWidgetSkills->currentItem() != NULL) {
        SkillData* skillData = (SkillData*) ui->treeWidgetSkills->currentItem()->data(0, Qt::UserRole).value<void*>();

        if(skillData != NULL) {
            optionsController->removeObjectSkill(gameObject, skillData);
            populaListaSkills();
        }

    }

}


void ConfigsObjHabilidadesWidget::on_pushButtonEdit_pressed()
{

    if(ui->treeWidgetSkills->currentItem() != NULL) {
        SkillData* skillData = (SkillData*) ui->treeWidgetSkills->currentItem()->data(0, Qt::UserRole).value<void*>();

        if(skillData != NULL) {
            ConfigsObjNewSkillDialog *configsObjNewSkillDialog;
            configsObjNewSkillDialog = new ConfigsObjNewSkillDialog(gameObject, skillData);
            configsObjNewSkillDialog->setWindowTitle("Nova habilidade");

            configsObjNewSkillDialog->exec();

            populaListaSkills();
        }

    }


}


void ConfigsObjHabilidadesWidget::setConfigsTabWidget(ConfigsTabWidget *configsTabWidget) {
    this->configsTabWidget = configsTabWidget;
}

void ConfigsObjHabilidadesWidget::on_botaoEditorEventos_pressed()
{
    configsTabWidget->selectObjectEvent(gameObject->id);
}
#include "configsobjitem.h"
#include "ui_configsobjitem.h"

ConfigsObjItem::ConfigsObjItem(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem, QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ConfigsObjItem),
    optionsController(optionsController),
    gameObject(gameObject),
    currentListItem(currentListItem)
{
    ui->setupUi(this);

    populaCampos();
}

ConfigsObjItem::~ConfigsObjItem()
{
    delete ui;
}

void ConfigsObjItem::populaCampos() {
    ui->checkBoxAtivaEvento->setChecked(gameObject->ativaEvento);
    ui->checkBoxComportamentoDesapareceEncParedes->setChecked(gameObject->desapareceEncostarParede);
    ui->checkBoxComportamentoDesapareceEncPers->setChecked(gameObject->desapareceEncostarPersonagem);
    ui->checkBoxConcedePontos->setChecked(gameObject->concedePontos);
    ui->checkBoxGanhaPerdeMagia->setChecked(gameObject->ganhaPerdeMagia);
    ui->checkBoxGanhaPerdeVida->setChecked(gameObject->ganhaPerdeVida);
    ui->checkBoxIncrementaVariavel->setChecked(gameObject->incrementaVariavel);
    ui->checkBoxConcedeHabilidade->setChecked(gameObject->concedeHabilidade);

    switch(gameObject->comportamentoEncostarPersonagem) {
    case 0:
        ui->radioButtonAtivaEfeitoImediatamente->setChecked(true);
        ui->radioButtonEnviaInventario->setChecked(false);
        break;
    case 1:
        ui->radioButtonAtivaEfeitoImediatamente->setChecked(false);
        ui->radioButtonEnviaInventario->setChecked(true);
        break;
    default:

        break;
    }

    ui->spinBoxConcedePontos->setValue(gameObject->concedePontosValor);
    ui->spinBoxGanhaPerdeMagia->setValue(gameObject->ganhaPerdeMagiaValor);
    ui->spinBoxGanhaPerdeVida->setValue(gameObject->ganhaPerdeVidaValor);
    ui->spinBoxIncrementaVariavel->setValue(gameObject->incrementaVariavelValor);

    ui->spinBoxConcedePontos->setEnabled(gameObject->concedePontos);
    ui->spinBoxGanhaPerdeMagia->setEnabled(gameObject->ganhaPerdeMagia);
    ui->spinBoxGanhaPerdeVida->setEnabled(gameObject->ganhaPerdeVida);
    ui->spinBoxIncrementaVariavel->setEnabled(gameObject->incrementaVariavel);

    ui->comboBoxAtivaEvento->setEnabled(gameObject->ativaEvento);
    ui->comboBoxConcedeHabilidade->setEnabled(gameObject->concedeHabilidade);
    ui->comboBoxIncrementaVariavel->setEnabled(gameObject->incrementaVariavel);


    ui->comboMovimentacaoItem->setCurrentIndex(gameObject->comportamentoEncostarPersonagem);

    /* TODO: popular combos da variavel, evento e habilidade, quando estiverem prontas*/

}

void ConfigsObjItem::on_checkBoxConcedePontos_toggled(bool checked)
{
    gameObject->concedePontos = checked;

   if(checked) {
       ui->spinBoxConcedePontos->setEnabled(true);
   } else {
       ui->spinBoxConcedePontos->setEnabled(false);
   }
}

void ConfigsObjItem::on_checkBoxGanhaPerdeVida_toggled(bool checked)
{
    gameObject->ganhaPerdeVida = checked;

    if(checked) {
        ui->spinBoxGanhaPerdeVida->setEnabled(true);
    } else {
        ui->spinBoxGanhaPerdeVida->setEnabled(false);
    }
}

void ConfigsObjItem::on_checkBoxGanhaPerdeMagia_toggled(bool checked)
{
    gameObject->ganhaPerdeMagia = checked;

    if(checked) {
        ui->spinBoxGanhaPerdeMagia->setEnabled(true);
    } else {
        ui->spinBoxGanhaPerdeMagia->setEnabled(false);
    }
}

void ConfigsObjItem::on_checkBoxIncrementaVariavel_toggled(bool checked)
{
    gameObject->incrementaVariavel = checked;

    if(checked) {
        ui->spinBoxIncrementaVariavel->setEnabled(true);
        ui->comboBoxIncrementaVariavel->setEnabled(true);
    } else {
        ui->spinBoxIncrementaVariavel->setEnabled(false);
         ui->comboBoxIncrementaVariavel->setEnabled(false);
    }
}

void ConfigsObjItem::on_checkBoxAtivaEvento_toggled(bool checked)
{
    gameObject->ativaEvento = checked;

    if(checked) {
        ui->comboBoxAtivaEvento->setEnabled(true);
    } else {
        ui->comboBoxAtivaEvento->setEnabled(false);
    }
}

void ConfigsObjItem::on_spinBoxConcedePontos_valueChanged(int value)
{
    gameObject->concedePontosValor = value;
}

void ConfigsObjItem::on_spinBoxGanhaPerdeVida_valueChanged(int value)
{
    gameObject->ganhaPerdeVidaValor = value;
}

void ConfigsObjItem::on_spinBoxGanhaPerdeMagia_valueChanged(int value)
{
    gameObject->ganhaPerdeMagiaValor = value;
}

void ConfigsObjItem::on_comboBoxIncrementaVariavel_currentIndexChanged(int index)
{
    /* TODO: fazer este quando variaveis estiverem prontas */
}

void ConfigsObjItem::on_spinBoxIncrementaVariavel_valueChanged(int value)
{
    gameObject->incrementaVariavelValor = value;
}

void ConfigsObjItem::on_comboBoxAtivaEvento_currentIndexChanged(int index)
{
    /* TODO: fazer este quando variaveis estiverem prontas */
}

void ConfigsObjItem::on_radioButtonAtivaEfeitoImediatamente_toggled(bool checked)
{
    if(checked) {
        gameObject->comportamentoEncostarPersonagem = 0;
    }

}

void ConfigsObjItem::on_radioButtonEnviaInventario_toggled(bool checked)
{
    if(checked) {
        gameObject->comportamentoEncostarPersonagem = 1;
    }

}

void ConfigsObjItem::on_comboMovimentacaoItem_currentIndexChanged(int index)
{
    gameObject->formaMovimentacaoNpcItem = index;
}

void ConfigsObjItem::on_checkBoxComportamentoDesapareceEncPers_toggled(bool checked)
{
    gameObject->desapareceEncostarPersonagem = checked;
}

void ConfigsObjItem::on_checkBoxComportamentoDesapareceEncParedes_toggled(bool checked)
{
    gameObject->desapareceEncostarParede = checked;
}

void ConfigsObjItem::on_checkBoxConcedeHabilidade_toggled(bool checked)
{
    gameObject->concedeHabilidade = checked;

    if(checked) {
        ui->comboBoxConcedeHabilidade->setEnabled(true);
    } else {
        ui->comboBoxConcedeHabilidade->setEnabled(false);
    }
}

void ConfigsObjItem::on_comboBoxConcedeHabilidade_currentIndexChanged(int index)
{
    /* TODO quando habilidade estiverem prontas */
}
#include "configsobjnewskilldialog.h"
#include "ui_configsobjnewskilldialog.h"

ConfigsObjNewSkillDialog::ConfigsObjNewSkillDialog(GameObject *gameObject, SkillData *skillData, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::ConfigsObjNewSkillDialog),
    gameObject(gameObject)
{
    ui->setupUi(this);

    populaComboHabilidades();
    populaComboObjetos();

    if(skillData) {
        this->skillData = skillData;
        preencheCampos(skillData);
    } else {
        this->skillData = new SkillData();
    }


}

ConfigsObjNewSkillDialog::~ConfigsObjNewSkillDialog()
{
    delete ui;
}

void ConfigsObjNewSkillDialog::preencheCampos(SkillData *skillData) {
    if(skillData->skillObject != NULL) {

        if(skillData->skill != NULL) {
            int count_skill = ui->comboBoxSkill->count();
            for(int i = 0; i < count_skill; i++) {
                Skill *skill = (Skill*) ui->comboBoxSkill->itemData(i, Qt::UserRole).value<void*>();

                if(skill != NULL) {
                    if(skill->id == skillData->skill->id) {
                        ui->comboBoxSkill->setCurrentIndex(i);
                    }
                }


            }
        }

        if(skillData->skillObject != NULL) {
            int count_skill_object = ui->comboBoxSkillObject->count();
            for(int i = 0; i < count_skill_object; i++) {
                GameObject *gameObject = (GameObject*) ui->comboBoxSkillObject->itemData(i, Qt::UserRole).value<void*>();

                if(gameObject->id == skillData->skillObject->id) {
                    ui->comboBoxSkillObject->setCurrentIndex(i);
                }
            }
        }

        ui->checkBoxGetItem->setChecked(false);

        if(skillData->skillProvider != NULL) {
            int count_skill_object = ui->comboBoxProviderObject->count();
            for(int i = 0; i < count_skill_object; i++) {
                GameObject *gameObject = (GameObject*) ui->comboBoxProviderObject->itemData(i, Qt::UserRole).value<void*>();

                if(gameObject->id == skillData->skillObject->id) {
                    ui->comboBoxProviderObject->setCurrentIndex(i);
                    ui->checkBoxAlways->setChecked(false);
                    ui->checkBoxGetItem->setChecked(true);
                }
            }
        }

        if(skillData->level > 0) {
            ui->spinBoxLevel->setValue(skillData->level);
            ui->checkBoxAlways->setChecked(false);
            ui->checkBoxLevel->setChecked(true);
        } else {
            ui->checkBoxLevel->setChecked(false);
        }

        ui->spinBoxIntensity->setValue(skillData->intensity);
        ui->spinBoxMagicCost->setValue(skillData->magicCost);


    }


}

void ConfigsObjNewSkillDialog::populaComboHabilidades() {
    GameData *gameData = GameData::getInstance();

    std::vector<Skill*> *skillList = gameData->skillList;

    ui->comboBoxSkill->clear();

    ui->comboBoxSkill->insertItem(ui->comboBoxSkill->count() + 1, QString("-- Escolha a habilidade --"), QVariant::fromValue((void*) NULL));

    for(std::vector<Skill*>::iterator it = skillList->begin(); it != skillList->end(); ++it) {
        Skill *skill = *it;

        if(skill->containsObjectType(gameObject->type)) {
            ui->comboBoxSkill->insertItem(ui->comboBoxSkill->count() + 1, QString(skill->name.c_str()), QVariant::fromValue((void*) skill));
        }

    }
}

void ConfigsObjNewSkillDialog::populaComboObjetos() {
    GameData *gameData = GameData::getInstance();

    std::vector<GameObject*> *objectList = gameData->objectList;

    ui->comboBoxSkillObject->clear();

    for(std::vector<GameObject*>::iterator it = objectList->begin(); it != objectList->end(); ++it) {
        GameObject *gameObject = *it;

        if(gameObject->type == GameObject::ITEM) {
            ui->comboBoxSkillObject->insertItem(0, QIcon(QPixmap::fromImage(gameObject->getIconImage())), QString(gameObject->name.c_str()),
                                                QVariant::fromValue((void*) gameObject));
            ui->comboBoxProviderObject->insertItem(0, QIcon(QPixmap::fromImage(gameObject->getIconImage())), QString(gameObject->name.c_str()),
                                                QVariant::fromValue((void*) gameObject));
        }




    }

}

SkillData* ConfigsObjNewSkillDialog::exec() {
    QDialog::exec();


    if(this->accepeted) {


        skillData->intensity = ui->spinBoxIntensity->value();
        skillData->magicCost = ui->spinBoxMagicCost->value();
        if(ui->checkBoxLevel->isChecked()) {
            skillData->level = ui->spinBoxLevel->value();
        } else {
            skillData->level = -1;
        }
        skillData->skill = (Skill*) ui->comboBoxSkill->itemData(ui->comboBoxSkill->currentIndex(), Qt::UserRole).value<void*>();
        if(skillData->skill->hasObject) {
            skillData->skillObject = (GameObject*) ui->comboBoxSkillObject->itemData(ui->comboBoxSkillObject->currentIndex(), Qt::UserRole).value<void*>();
        } else {
            skillData->skillObject = NULL;
        }

        if(ui->checkBoxGetItem->isChecked()) {
            skillData->skillProvider = (GameObject*) ui->comboBoxProviderObject->itemData(ui->comboBoxProviderObject->currentIndex(), Qt::UserRole).value<void*>();
        } else {
            skillData->skillProvider = NULL;
        }



        return skillData;
    } else {
        return NULL;
    }

}

void ConfigsObjNewSkillDialog::on_comboBoxSkill_currentIndexChanged(int index)
{
    Skill *skill = (Skill*) ui->comboBoxSkill->itemData(index, Qt::UserRole).value<void*>();

    if(skill != NULL) {
        ui->spinBoxIntensity->setEnabled(skill->hasIntensity);
        ui->comboBoxSkillObject->setEnabled(skill->hasObject);
        ui->groupBoxObtain->setEnabled(true);
        ui->spinBoxMagicCost->setEnabled(true);
    } else {
        ui->spinBoxIntensity->setEnabled(false);
        ui->comboBoxSkillObject->setEnabled(false);
        ui->groupBoxObtain->setEnabled(false);
        ui->spinBoxMagicCost->setEnabled(false);
    }


}

void ConfigsObjNewSkillDialog::on_checkBoxAlways_toggled(bool checked)
{

}

void ConfigsObjNewSkillDialog::on_checkBoxLevel_toggled(bool checked)
{
    ui->spinBoxLevel->setEnabled(checked);
}

void ConfigsObjNewSkillDialog::on_checkBoxGetItem_toggled(bool checked)
{
    ui->comboBoxProviderObject->setEnabled(checked);
}

void ConfigsObjNewSkillDialog::on_checkBoxAlways_pressed()
{

}

void ConfigsObjNewSkillDialog::on_checkBoxLevel_pressed()
{

}

void ConfigsObjNewSkillDialog::on_checkBoxGetItem_pressed()
{

}

void ConfigsObjNewSkillDialog::on_checkBoxAlways_released()
{
    if(ui->checkBoxAlways->isChecked()) {
        ui->checkBoxLevel->setChecked(false);
        ui->checkBoxGetItem->setChecked(false);
    } else {
        ui->checkBoxAlways->setChecked(true);
    }
}

void ConfigsObjNewSkillDialog::on_checkBoxLevel_released()
{
    if(ui->checkBoxLevel->isChecked()) {
        ui->checkBoxAlways->setChecked(false);
    } else {
        if(!ui->checkBoxGetItem->isChecked()) {
            ui->checkBoxAlways->setChecked(true);
        }
    }
}



void ConfigsObjNewSkillDialog::on_checkBoxGetItem_released()
{
    if(ui->comboBoxProviderObject->count() == 0) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Nío existem itens para serem escolhidos."));
        ui->checkBoxGetItem->setChecked(false);
    }

    if(ui->checkBoxGetItem->isChecked()) {
        ui->checkBoxAlways->setChecked(false);
    } else {
        if(!ui->checkBoxLevel->isChecked()) {
            ui->checkBoxAlways->setChecked(true);
        }
    }
}


void ConfigsObjNewSkillDialog::on_buttonBox_accepted()
{
    Skill *skill = (Skill*) ui->comboBoxSkill->itemData(ui->comboBoxSkill->currentIndex(), Qt::UserRole).value<void*>();

    if(skill == NULL) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Selecione uma habilidade."));
        return;
    }

    if(skill->hasIntensity) {
        if(ui->spinBoxIntensity->value() == 0) {
            MessageBoxes::showMessageBox(QString::fromUtf8("Intensidade deve ser maior do que zero."));
            return;
        }

    }

    if(skill->hasObject) {
        if(((GameObject*) ui->comboBoxSkillObject->itemData(ui->comboBoxSkillObject->currentIndex(), Qt::UserRole).value<void*>()) == NULL) {
            MessageBoxes::showMessageBox(QString::fromUtf8("Um objeto deve ser selecionado."));
            return;
        }

    }

    accepeted = true;
    accept();
}


void ConfigsObjNewSkillDialog::on_buttonBox_rejected()
{
    accepeted = false;
    reject();
}
#include "configsobjnpcbehaviorwidget.h"
#include "ui_configsobjnpcbehaviorwidget.h"

ConfigsObjNpcBehaviorWidget::ConfigsObjNpcBehaviorWidget(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem,QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ConfigsObjNpcBehaviorWidget),
    optionsController(optionsController),
    gameObject(gameObject),
    currentListItem(currentListItem)
{
    ui->setupUi(this);
    ativaMudancaCombo = false;
    populaCampos();
    ativaMudancaCombo = true;

    if(gameObject->type == GameObject::NPC) {
        ui->groupBoxInimigo->setVisible(false);
    }
}

ConfigsObjNpcBehaviorWidget::~ConfigsObjNpcBehaviorWidget()
{
    delete ui;
}

void ConfigsObjNpcBehaviorWidget::populaCampos() {
    GameData *gameData = GameData::getInstance();

    ui->comboBoxFormaMovimentacaoNpc->setCurrentIndex(gameObject->formaMovimentacaoNpcItem);
    ui->spinBoxRaioMovimentacao->setValue(gameObject->raioMovimentacao);
    ui->checkBoxAtacaAtiraItemMagiaDirEstiver->setChecked(gameObject->atiraItemMaginaDirecaoEstiver);
    ui->checkBoxAtacaAtiraItemMagiaDirPers->setChecked(gameObject->atiraItemMagiaDirecaoPersonagem);
    ui->checkBoxAtacaEncostaNoPersonagem->setChecked(gameObject->atacaEncostaPersonagem);
    ui->checkBoxAtacaUsaEspada->setChecked(gameObject->atacaUsandoEspada);
    ui->checkBoxDerrotaAcertandoEspada->setChecked(gameObject->derrotaAcertandoEspadaSobreInimigo);
    ui->checkBoxDerrotaAtirandoItemMagia->setChecked(gameObject->derrotaAtirandoItemMagiaInimigo);
    ui->checkBoxDerrotaEncostandoInimigo->setChecked(gameObject->derrotaEncostandoInimigo);
    ui->checkBoxDerrotaPulandoSobre->setChecked(gameObject->derrotaPulandoSobreInimigo);

    ui->spinBoxDanoEncostaPersonagem->setValue(gameObject->atacaEncostaPersonagemDano);
    ui->spinBoxDanoUsaEspada->setValue(gameObject->atacaUsandoEspadaDano);

    ui->spinBoxVelocidadeMovimentacao->setValue(gameObject->vx);

    ui->checkBox->setChecked(gameObject->movimentaApenasDentroTela);

    std::vector<GameObject *> *gameObjectList;


    gameObjectList = gameData->objectList;

    ui->comboBoxItemDirecaoEstiver->clear();
    ui->comboBoxItemDirecaoPersonagem->clear();
    ui->comboBoxItemEspada->clear();

    for(std::vector<GameObject*>::iterator it = gameObjectList->begin(); it != gameObjectList->end(); ++it) {
        GameObject *currentGameObject = *it;
        if(currentGameObject->type == GameObject::ITEM) {
            ui->comboBoxItemDirecaoEstiver->addItem(QIcon(QPixmap::fromImage(currentGameObject->getIconImage())), QString(currentGameObject->name.c_str()), QVariant(currentGameObject->id));
            ui->comboBoxItemDirecaoPersonagem->addItem(QIcon(QPixmap::fromImage(currentGameObject->getIconImage())), QString(currentGameObject->name.c_str()), QVariant(currentGameObject->id));
            ui->comboBoxItemEspada->addItem(QIcon(QPixmap::fromImage(currentGameObject->getIconImage())), QString(currentGameObject->name.c_str()), QVariant(currentGameObject->id));

            if(currentGameObject->id == gameObject->atiraItemMagiaDirecaoPersonagemIdItem) {
                ui->comboBoxItemDirecaoPersonagem->setCurrentIndex(ui->comboBoxItemDirecaoPersonagem->count() - 1);
            }

            if(currentGameObject->id == gameObject->atiraItemMaginaDirecaoEstiverIdItem) {
                ui->comboBoxItemDirecaoEstiver->setCurrentIndex(ui->comboBoxItemDirecaoEstiver->count() - 1);
            }

            if(currentGameObject->id == gameObject->espadaItemId) {
                ui->comboBoxItemEspada->setCurrentIndex(ui->comboBoxItemEspada->count() - 1);
            }
        }
    }

    if(gameObject->formaMovimentacaoNpcItem > 0) {
        ui->spinBoxVelocidadeMovimentacao->setEnabled(true);
        ui->spinBoxRaioMovimentacao->setEnabled(true);
        ui->checkBox->setEnabled(true);
    } else {
        ui->spinBoxVelocidadeMovimentacao->setEnabled(false);
        ui->spinBoxRaioMovimentacao->setEnabled(false);
        ui->checkBox->setEnabled(false);
    }

    ui->spinBoxPeriodicidade->setValue(gameObject->tempoAtaque);
    ui->spinBoxMagicCost->setValue(gameObject->magicCost);

    ui->spinBoxExperiencePoints->setValue(gameObject->experiencePoints);



}


void ConfigsObjNpcBehaviorWidget::on_comboBoxFormaMovimentacaoNpc_currentIndexChanged(int index)
{
    gameObject->formaMovimentacaoNpcItem = index;

    if(index > 0) {
        ui->spinBoxVelocidadeMovimentacao->setEnabled(true);
        ui->spinBoxRaioMovimentacao->setEnabled(true);
        ui->checkBox->setEnabled(true);
    } else {
        ui->spinBoxVelocidadeMovimentacao->setEnabled(false);
        ui->spinBoxRaioMovimentacao->setEnabled(false);
        ui->checkBox->setEnabled(false);
    }

}

void ConfigsObjNpcBehaviorWidget::on_checkBoxDerrotaEncostandoInimigo_toggled(bool checked)
{
    gameObject->derrotaEncostandoInimigo = checked;
}

void ConfigsObjNpcBehaviorWidget::on_checkBoxDerrotaAtirandoItemMagia_toggled(bool checked)
{
    gameObject->derrotaAtirandoItemMagiaInimigo = checked;
}

void ConfigsObjNpcBehaviorWidget::on_checkBoxDerrotaAcertandoEspada_toggled(bool checked)
{
    gameObject->derrotaAcertandoEspadaSobreInimigo = checked;
}

void ConfigsObjNpcBehaviorWidget::on_checkBoxDerrotaPulandoSobre_toggled(bool checked)
{
    gameObject->derrotaPulandoSobreInimigo = checked;
}

void ConfigsObjNpcBehaviorWidget::on_checkBoxAtacaEncostaNoPersonagem_toggled(bool checked)
{
    gameObject->atacaEncostaPersonagem = checked;
}

void ConfigsObjNpcBehaviorWidget::on_checkBoxAtacaUsaEspada_toggled(bool checked)
{
    gameObject->atacaUsandoEspada = checked;
}

void ConfigsObjNpcBehaviorWidget::on_checkBoxAtacaAtiraItemMagiaDirEstiver_toggled(bool checked)
{
    gameObject->atiraItemMaginaDirecaoEstiver = checked;
}

void ConfigsObjNpcBehaviorWidget::on_checkBoxAtacaAtiraItemMagiaDirPers_toggled(bool checked)
{
    gameObject->atiraItemMagiaDirecaoPersonagem = checked;
}

void ConfigsObjNpcBehaviorWidget::on_spinBoxDanoEncostaPersonagem_valueChanged(int value)
{
    gameObject->atacaEncostaPersonagemDano = value;
}

void ConfigsObjNpcBehaviorWidget::on_spinBoxDanoUsaEspada_valueChanged(int value)
{
    gameObject->atacaUsandoEspadaDano = value;
}

void ConfigsObjNpcBehaviorWidget::on_comboBoxItemDirecaoEstiver_currentIndexChanged(int index)
{
    if(ativaMudancaCombo) {
        gameObject->atiraItemMaginaDirecaoEstiverIdItem =
            ui->comboBoxItemDirecaoEstiver->itemData(index).toInt();
    }
}

void ConfigsObjNpcBehaviorWidget::on_comboBoxItemEspada_currentIndexChanged(int index)
{
    if(ativaMudancaCombo) {
        gameObject->espadaItemId =
            ui->comboBoxItemEspada->itemData(index).toInt();
    }
}

void ConfigsObjNpcBehaviorWidget::on_comboBoxItemDirecaoPersonagem_currentIndexChanged(int index)
{
    if(ativaMudancaCombo) {
        gameObject->atiraItemMagiaDirecaoPersonagemIdItem =
            ui->comboBoxItemDirecaoPersonagem->itemData(index).toInt();
    }

}

void ConfigsObjNpcBehaviorWidget::on_spinBoxVelocidadeMovimentacao_valueChanged(int value)
{
    gameObject->vx = value;
}

void ConfigsObjNpcBehaviorWidget::on_checkBox_toggled(bool checked)
{
    gameObject->movimentaApenasDentroTela = checked;
}

void ConfigsObjNpcBehaviorWidget::on_spinBoxRaioMovimentacao_valueChanged(int value)
{
    gameObject->raioMovimentacao = value;
}

void ConfigsObjNpcBehaviorWidget::on_spinBoxMagicCost_valueChanged(int value)
{
    gameObject->magicCost = value;
}


void ConfigsObjNpcBehaviorWidget::on_spinBoxPeriodicidade_valueChanged(double value)
{
    gameObject->tempoAtaque = value;
}

void ConfigsObjNpcBehaviorWidget::on_spinBoxExperiencePoints_valueChanged(int value)
{
    gameObject->experiencePoints = value;
}
#include "configsobjphysicswidget.h"
#include "ui_configsobjphysicswidget.h"

ConfigsObjPhysicsWidget::ConfigsObjPhysicsWidget(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem, QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ConfigsObjPhysicsWidget),
    optionsController(optionsController),
    gameObject(gameObject),
    currentListItem(currentListItem)
{
    ui->setupUi(this);

    switch(gameObject->type) {
    case GameObject::EIGHT_MOVEMENT_OBJECT:
        ui->gbPhysicsEightMovement->setEnabled(true);
        ui->gbPhysicsCarMovement->setVisible(false);
        ui->gbPhysicsBouncingBall->setVisible(false);
        ui->gbPhysicsMouseMovement->setVisible(false);
        ui->gbPhysicsPlatformer->setVisible(false);

        ui->comboTipoMovimento->setCurrentIndex(gameObject->tipoMovimento);

        ui->spinVx->setValue(gameObject->vx);
        ui->spinVy->setValue(gameObject->vy);
        ui->spinAx->setValue(gameObject->ax);
        ui->spinAy->setValue(gameObject->ay);
        ui->spinDax->setValue(gameObject->dax);
        ui->spinDay->setValue(gameObject->day);
        break;

    case GameObject::CAR_MOVEMENT_OBJECT:
        ui->gbPhysicsCarMovement->setEnabled(true);
        ui->gbPhysicsEightMovement->setVisible(false);
        ui->gbPhysicsBouncingBall->setVisible(false);
        ui->gbPhysicsMouseMovement->setVisible(false);
        ui->gbPhysicsPlatformer->setVisible(false);

        ui->comboTipoMovimento_2->setCurrentIndex(gameObject->tipoMovimento);
        ui->spinCarV->setValue(gameObject->vx);
        ui->spinCarA->setValue(gameObject->ax);
        ui->spinCarDA->setValue(gameObject->dax);
        ui->spinCarVA->setValue(gameObject->ay);
        break;

        /* Para o fighting movement, são utilizadas
           as mesmas físicas do platformer.         */

    case GameObject::FIGHTING_MOVEMENT_OBJECT:
        ui->gbPhysicsCarMovement->setVisible(false);
        ui->gbPhysicsEightMovement->setVisible(false);
        ui->gbPhysicsBouncingBall->setVisible(false);
        ui->gbPhysicsMouseMovement->setVisible(false);
        ui->gbPhysicsPlatformer->setEnabled(true);

        ui->comboTipoMovimentoPlatformer->setCurrentIndex(gameObject->tipoMovimento);
        ui->spinPlatformerV->setValue(gameObject->vx);
        ui->spinPlatformerA->setValue(gameObject->ax);
        ui->spinPlatformerG->setValue(gameObject->gravidade);
        ui->spinPlatformerIntensidadePulo->setValue(gameObject->intensidadePulo);

        break;

    case GameObject::PLATFORM_MOVEMENT_OBJECT:
        ui->gbPhysicsCarMovement->setVisible(false);
        ui->gbPhysicsEightMovement->setVisible(false);
        ui->gbPhysicsBouncingBall->setVisible(false);
        ui->gbPhysicsMouseMovement->setVisible(false);
        ui->gbPhysicsPlatformer->setEnabled(true);

        ui->comboTipoMovimentoPlatformer->setCurrentIndex(gameObject->tipoMovimento);
        ui->spinPlatformerV->setValue(gameObject->vx);
        ui->spinPlatformerA->setValue(gameObject->ax);
        ui->spinPlatformerG->setValue(gameObject->gravidade);
        ui->spinPlatformerIntensidadePulo->setValue(gameObject->intensidadePulo);

        break;

    case GameObject::MOUSE_MOVEMENT_OBJECT:
        ui->gbPhysicsCarMovement->setVisible(false);
        ui->gbPhysicsEightMovement->setVisible(false);
        ui->gbPhysicsBouncingBall->setVisible(false);
        ui->gbPhysicsMouseMovement->setEnabled(true);
        ui->gbPhysicsPlatformer->setVisible(false);

        ui->comboTipoMovimentoMouseObject->setCurrentIndex(gameObject->tipoMovimento);
        ui->comboFormaMovimentoMouseObject->setCurrentIndex(gameObject->formaMovimentoMouse);
        ui->spinMouseObjectV->setValue(gameObject->vx);
        ui->spinMouseObjectA->setValue(gameObject->ax);
        ui->spinMouseObjectDA->setValue(gameObject->dax);

        break;

    case GameObject::PONG_BALL_OBJECT:
        ui->gbPhysicsCarMovement->setVisible(false);
        ui->gbPhysicsEightMovement->setVisible(false);
        ui->gbPhysicsBouncingBall->setEnabled(true);
        ui->gbPhysicsMouseMovement->setVisible(false);
        ui->gbPhysicsPlatformer->setVisible(false);

        ui->spinBouncingBallVX->setValue(gameObject->vx);
        ui->spinBouncingBallVY->setValue(gameObject->vy);

        break;

    case GameObject::STATIC_OBJECT:
        ui->gbPhysicsCarMovement->setVisible(false);
        ui->gbPhysicsEightMovement->setVisible(false);
        ui->gbPhysicsBouncingBall->setVisible(false);
        ui->gbPhysicsMouseMovement->setVisible(false);
        ui->gbPhysicsPlatformer->setVisible(false);



        break;

    default:

        break;
    }

    /* resolve Collision */
    ui->checkBox->setChecked(gameObject->resolveCollision);




}

ConfigsObjPhysicsWidget::~ConfigsObjPhysicsWidget()
{
    delete ui;
}

void ConfigsObjPhysicsWidget::on_comboTipoMovimento_currentIndexChanged(int index)
{
    gameObject->tipoMovimento = index;
}

void ConfigsObjPhysicsWidget::on_spinVx_valueChanged(double value)
{
    gameObject->vx = value;
}

void ConfigsObjPhysicsWidget::on_spinVy_valueChanged(double value)
{
    gameObject->vy = value;
}

void ConfigsObjPhysicsWidget::on_spinAx_valueChanged(double value)
{
    gameObject->ax = value;
}

void ConfigsObjPhysicsWidget::on_spinAy_valueChanged(double value)
{
    gameObject->ay = value;
}

void ConfigsObjPhysicsWidget::on_spinDax_valueChanged(double value)
{
    gameObject->dax = value;
}

void ConfigsObjPhysicsWidget::on_spinDay_valueChanged(double value)
{
    gameObject->day = value;
}


void ConfigsObjPhysicsWidget::on_comboTipoMovimento_2_currentIndexChanged(int index)
{
    gameObject->tipoMovimento = index;
}



void ConfigsObjPhysicsWidget::on_spinCarV_valueChanged(double value)
{
    gameObject->vx = value;
}

void ConfigsObjPhysicsWidget::on_spinCarA_valueChanged(double value)
{
    gameObject->ax = value;
}

void ConfigsObjPhysicsWidget::on_spinCarDA_valueChanged(double value)
{
    gameObject->dax = value;
}



void ConfigsObjPhysicsWidget::on_comboTipoMovimentoPlatformer_currentIndexChanged(int index)
{
    gameObject->tipoMovimento = index;
}

void ConfigsObjPhysicsWidget::on_spinPlatformerV_valueChanged(double value)
{
    gameObject->vx = value;
}

void ConfigsObjPhysicsWidget::on_spinPlatformerA_valueChanged(double value)
{
    gameObject->ax = value;
}

void ConfigsObjPhysicsWidget::on_spinPlatformerG_valueChanged(double value)
{
    gameObject->gravidade = value;
}

void ConfigsObjPhysicsWidget::on_spinPlatformerIntensidadePulo_valueChanged(double value)
{
    gameObject->intensidadePulo = value;
}

void ConfigsObjPhysicsWidget::on_spinBouncingBallVX_valueChanged(double value)
{
    gameObject->vx = value;
}

void ConfigsObjPhysicsWidget::on_spinBouncingBallVY_valueChanged(double value)
{
    gameObject->vy = value;
}

void ConfigsObjPhysicsWidget::on_comboTipoMovimentoMouseObject_currentIndexChanged(int index)
{
    gameObject->tipoMovimento = index;
}

void ConfigsObjPhysicsWidget::on_comboFormaMovimentoMouseObject_currentIndexChanged(int index)
{
    gameObject->formaMovimentoMouse = index;
}

void ConfigsObjPhysicsWidget::on_spinMouseObjectV_valueChanged(double value)
{
    gameObject->vx = value;
}

void ConfigsObjPhysicsWidget::on_spinMouseObjectA_valueChanged(double value)
{
    gameObject->ax = value;
}

void ConfigsObjPhysicsWidget::on_spinMouseObjectDA_valueChanged(double value)
{
    gameObject->dax = value;
}

void ConfigsObjPhysicsWidget::on_checkBox_toggled(bool checked)
{
    gameObject->resolveCollision = checked;
}

void ConfigsObjPhysicsWidget::on_spinCarVA_valueChanged(double value)
{
    gameObject->ay = value;
}
#include "configstabwidget.h"
#include "ui_configstabwidget.h"

ConfigsTabWidget::ConfigsTabWidget(QWidget *parent) :
    QTabWidget(parent),
    ui(new Ui::ConfigsTabWidget)
{
    ui->setupUi(this);
    getObjectTab()->setConfigsTabWidget(this);

}

ConfigsTabWidget::~ConfigsTabWidget()
{
    delete ui;
}

void ConfigsTabWidget::setOptionsController(OptionsController *optionsController) {
    this->optionsController = optionsController;
    ui->tab_tilesets->setOptionsController(optionsController);
    ui->tab_objetos->setOptionsController(optionsController);
    ui->tab_gerais->setOptionsController(optionsController);
    ui->tab_animations->setOptionsController(optionsController);
    ui->tab_fundos->setOptionsController(optionsController);
}

void ConfigsTabWidget::changeEvent(QEvent *e)
{
    QTabWidget::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

ConfigsTilesetWidget* ConfigsTabWidget::getTilesetTab() {
    return (ConfigsTilesetWidget*) ui->tab_tilesets;
}

ConfigsObjectsWidget* ConfigsTabWidget::getObjectTab() {
    return (ConfigsObjectsWidget*) ui->tab_objetos;
}

ConfigsGeneralWidget* ConfigsTabWidget::getDadosGeraisTab() {
    return (ConfigsGeneralWidget*) ui->tab_gerais;
}

ConfigsAnimations* ConfigsTabWidget::getAnimationsTab() {
    return (ConfigsAnimations*) ui->tab_animations;
}

ConfigsBackgrounds* ConfigsTabWidget::getBackgroundsTab() {
    return (ConfigsBackgrounds*) ui->tab_fundos;
}

EventsWidget* ConfigsTabWidget::getEventsTab() {
    return (EventsWidget*) ui->tab_eventos_globais;
}

void ConfigsTabWidget::selectObject(GameObject *gameObject) {
    setCurrentWidget(ui->tab_objetos);
    getObjectTab()->selectObject(gameObject);
}

void ConfigsTabWidget::selectObjectEvent(int idObject) {
    setCurrentWidget(ui->tab_eventos_globais);
    getEventsTab()->selectObject(idObject);

}


#include "configstabwindow.h"
#include "ui_configstabwindow.h"

ConfigsTabWindow::ConfigsTabWindow(OptionsController *optionsController,  EventsEditorController *eventsEditorController, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::ConfigsTabWindow)
{
    ui->setupUi(this);
    this->optionsController = optionsController;


   ui->widget->setOptionsController(optionsController);
   getEventsTab()->setEventsEditorController(eventsEditorController);
}

ConfigsTabWindow::~ConfigsTabWindow()
{
    delete ui;
}

void ConfigsTabWindow::selectObject(GameObject *gameObject) {
    ui->widget->selectObject(gameObject);
}

void ConfigsTabWindow::changeEvent(QEvent *e)
{
    QDialog::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

ConfigsGeneralWidget* ConfigsTabWindow::getDadosGeraisTab() {
    return ui->widget->getDadosGeraisTab();
}

ConfigsTilesetWidget* ConfigsTabWindow::getTilesetTab() {
    return ui->widget->getTilesetTab();
}

ConfigsObjectsWidget* ConfigsTabWindow::getObjectTab() {
    return ui->widget->getObjectTab();
}

ConfigsAnimations* ConfigsTabWindow::getAnimationsTab() {
    return ui->widget->getAnimationsTab();
}

ConfigsBackgrounds* ConfigsTabWindow::getBackgroundsTab() {
    return ui->widget->getBackgroundsTab();
}

EventsWidget* ConfigsTabWindow::getEventsTab() {
    return ui->widget->getEventsTab();
}
#include "configstilesetdialogaddnew.h"
#include "ui_configstilesetdialogaddnew.h"

ConfigsTilesetDialogAddNew::ConfigsTilesetDialogAddNew(OptionsController *optionsController, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::ConfigsTilesetDialogAddNew)
{
    ui->setupUi(this);

    this->optionsController = optionsController;

    /* populando a lista */
    populaLista();
}

void ConfigsTilesetDialogAddNew::populaLista() {
    GameData *gameData;
    gameData = GameData::getInstance();

    QDir *dir;
    dir = new QDir(gameData->getProjectDirectory().append("/tilesets/").c_str());
    QStringList files;
    QStringList filters;

    filters << "*.png" << "*.jpg" << "*.gif" << "*.bmp";
    dir->setNameFilters(filters);

    files = dir->entryList();


    ui->listWidget->clear();
    for(QStringList::Iterator it = files.begin(); it != files.end(); ++it) {
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(*it);
        ui->listWidget->addItem(newItem);
    }


}

ConfigsTilesetDialogAddNew::~ConfigsTilesetDialogAddNew()
{
    delete ui;
}

void ConfigsTilesetDialogAddNew::changeEvent(QEvent *e)
{
    QDialog::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

void ConfigsTilesetDialogAddNew::on_listWidget_itemChanged(QListWidgetItem* item)
{


}

void ConfigsTilesetDialogAddNew::on_listWidget_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    QPixmap *image;
    QPixmap image_new_resolution;
    std::string diretorio;
    GameData *gameData;

    if(current != NULL) {
        gameData = GameData::getInstance();

        diretorio = gameData->getProjectDirectory().append("/tilesets/");
        diretorio.append(current->text().toStdString().c_str());

        image = new QPixmap(diretorio.c_str());


        image_new_resolution = image->scaledToHeight(200, Qt::SmoothTransformation);


        ui->imagethumbnail->setPixmap(*image);
    }



}

void ConfigsTilesetDialogAddNew::on_botaoImportar_clicked()
{
    QStringList fileNames;


    fileNames = QFileDialog::getOpenFileNames(this, tr("Open Project"), "", tr("(*.png *.jpg *.bmp *.gif)"));


    for(QStringList::Iterator it = fileNames.begin(); it != fileNames.end(); ++it) {
        QString fileName = *it;

        if(!fileName.isEmpty()) {
            optionsController->importResource(fileName.toStdString(), 0);
            populaLista();
        }
    }

}

void ConfigsTilesetDialogAddNew::on_botaoCancelar_clicked()
{
    this->close();
}

void ConfigsTilesetDialogAddNew::on_botaoSelecionar_clicked()
{
    if(ui->listWidget->currentItem() == NULL) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Necessário importar um tileset antes."));
    } else {
        optionsController->addTileset(ui->listWidget->currentItem()->text().toStdString());

        this->close();
    }

}
#include "configstilesetwidget.h"
#include "ui_configstilesetwidget.h"

ConfigsTilesetWidget::ConfigsTilesetWidget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ConfigsTilesetWidget)
{
    ui->setupUi(this);
    populaLista();
}

ConfigsTilesetWidget::~ConfigsTilesetWidget()
{
    delete ui;
}

void ConfigsTilesetWidget::changeEvent(QEvent *e)
{
    QWidget::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

void ConfigsTilesetWidget::setOptionsController(OptionsController *optionsController) {
    this->optionsController = optionsController;
}

void ConfigsTilesetWidget::on_pushButton_clicked()
{
    ConfigsImportDialog *newWindow;

    newWindow = new ConfigsImportDialog(optionsController, ConfigsImportDialog::IMPORT_TILESETS, this);
    newWindow->setWindowTitle(QString("Importar tilesets"));
    newWindow->setModal(true);
    newWindow->show();
}

void ConfigsTilesetWidget::populaLista() {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::vector<TileSet*>* tileSetList;


    tileSetList = gameData->tileSetList;

    ui->listWidget->clear();

    for(std::vector<TileSet*>::iterator it = tileSetList->begin(); it != tileSetList->end(); ++it) {
        TileSet *iterationItem;

        iterationItem = *it;
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString(iterationItem->name.c_str()));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) iterationItem));
        ui->listWidget->addItem(newItem);

    }
}

void ConfigsTilesetWidget::on_listWidget_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{

    if(current != 0x0) {
        TileSet *currentTileset;
        currentTileset = (TileSet*) current->data(Qt::UserRole).value<void*>();


        ui->lineEdit->setDisabled(false);
        ui->spinBox->setDisabled(false);
        ui->lineEdit->setText(current->text());
        ui->spinBox->setValue(currentTileset->tileSize);

        TilesetColMapScene *tilesetColMapScene;
        tilesetColMapScene = new TilesetColMapScene(currentTileset, this);
        ui->graphicsView->setScene(tilesetColMapScene);
        ui->graphicsView->setMouseTracking(true);
        ui->graphicsView->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
        ui->graphicsView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);

        ui->graphicsView->repaint();
    }

}

void ConfigsTilesetWidget::on_lineEdit_textChanged(QString )
{
    ui->listWidget->currentItem()->setText(ui->lineEdit->text());
    TileSet *currentTileset;
    currentTileset = (TileSet*) ui->listWidget->currentItem()->data(Qt::UserRole).value<void*>();
    currentTileset->name = ui->lineEdit->text().toStdString();
}

void ConfigsTilesetWidget::on_spinBox_valueChanged(int )
{
    TileSet *currentTileset;
    currentTileset = (TileSet*) ui->listWidget->currentItem()->data(Qt::UserRole).value<void*>();

    currentTileset->tileSize = ui->spinBox->value();
}
#include "easynewgameobjectdialog.h"
#include "ui_easynewgameobjectdialog.h"

EasyNewGameObjectDialog::EasyNewGameObjectDialog(OptionsController *OptionsController, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::EasyNewGameObjectDialog),
    optionsController(optionsController)
{
    ui->setupUi(this);

    populaCombosObjetos();
    habilitaCheckBoxes();


    gameObject = new GameObject();
    preencheComboMovementStyle();

    scene = new QGraphicsScene(this);
    item =
            new QGraphicsPixmapItem(QPixmap::fromImage(gameObject->getIconImage()));

    item->setPos(0, 0);

    scene->addItem(item);

    ui->graphicsView->setScene(scene);
}

EasyNewGameObjectDialog::~EasyNewGameObjectDialog()
{
    delete item;
    delete scene;
    delete ui;
}

GameObject* EasyNewGameObjectDialog::exec() {
    QDialog::exec();

    if(gameObject != NULL) {
        GameData *gameData = GameData::getInstance();

        gameObject->name = ui->lineEditName->text().toStdString();
        gameObject->type = ui->comboBoxType->currentIndex();

        switch(ui->comboBoxMovementType->currentIndex()) {
        case MOVEMENT_SSLOW:
            gameObject->vx = 7;
            gameObject->vy = 15;
            gameObject->ax = 10;
            gameObject->ay = 10;
            gameObject->dax = 10;
            gameObject->day = 10;
            break;
        case MOVEMENT_SLOW:
            gameObject->vx = 10;
            gameObject->vy = 10;
            gameObject->ax = 7;
            gameObject->ay = 7;
            gameObject->dax = 7;
            gameObject->day = 7;
            break;
        case MOVEMENT_FAST:
            gameObject->vx = 15;
            gameObject->vy = 15;
            gameObject->ax = 10;
            gameObject->ay = 10;
            gameObject->dax = 10;
            gameObject->day = 10;
            break;
        case MOVEMENT_FFAST:
            gameObject->vx = 20;
            gameObject->vy = 20;
            gameObject->ax = 15;
            gameObject->ay = 15;
            gameObject->dax = 15;
            gameObject->day = 15;
            break;
        case MOVEMENT_SFAST:
            gameObject->vx = 25;
            gameObject->vy = 25;
            gameObject->ax = 20;
            gameObject->ay = 20;
            gameObject->dax = 20;
            gameObject->day = 20;
            break;
        }

        gameObject->tipoMovimento = ui->comboBoxMovementStyle->currentIndex();

        if(ui->checkBoxDoubleJump->isChecked()) {
            SkillData *skillData = new SkillData();
            skillData->id = Skill::SKILL_DOUBLE_JUMP;
            skillData->intensity = gameObject->intensidadePulo;
            skillData->magicCost = 0;
            skillData->level = -1;
            skillData->skill = gameData->skillList->at(Skill::SKILL_DOUBLE_JUMP);
            skillData->skillObject = NULL;
            skillData->skillProvider = NULL;

            gameObject->listaHabilidades.push_back(skillData);
        }

        if(ui->checkBoxFly->isChecked()) {
            SkillData *skillData = new SkillData();
            skillData->id = Skill::SKILL_FLY;
            skillData->intensity = 3;
            skillData->magicCost = 0;
            skillData->level = -1;
            skillData->skill = gameData->skillList->at(Skill::SKILL_FLY);
            skillData->skillObject = NULL;
            skillData->skillProvider = NULL;

            gameObject->listaHabilidades.push_back(skillData);
        }

        if(ui->checkBoxGlide->isChecked()) {
            SkillData *skillData = new SkillData();
            skillData->id = Skill::SKILL_GLIDE;
            skillData->intensity = 1;
            skillData->magicCost = 0;
            skillData->level = -1;
            skillData->skill = gameData->skillList->at(Skill::SKILL_GLIDE);
            skillData->skillObject = NULL;
            skillData->skillProvider = NULL;

            gameObject->listaHabilidades.push_back(skillData);
        }

        if(ui->checkBoxJump->isChecked()) {
            SkillData *skillData = new SkillData();
            skillData->id = Skill::SKILL_JUMP;
            skillData->intensity = gameObject->intensidadePulo;
            skillData->magicCost = 0;
            skillData->level = -1;
            skillData->skill = gameData->skillList->at(Skill::SKILL_JUMP);
            skillData->skillObject = NULL;
            skillData->skillProvider = NULL;

            gameObject->listaHabilidades.push_back(skillData);
        }

        if(ui->checkBoxObjectThrow->isChecked()) {
            if(gameObject->type != GameObject::INIMIGO) {
                SkillData *skillData = new SkillData();
                skillData->id = Skill::SKILL_THROW_OBJECT;
                skillData->intensity = 2;
                skillData->magicCost = 0;
                skillData->level = -1;
                skillData->skill = gameData->skillList->at(Skill::SKILL_THROW_OBJECT);
                skillData->skillObject = (GameObject*)
                        ui->comboBoxObjectThrow->itemData(ui->comboBoxObjectThrow->currentIndex(), Qt::UserRole).value<void*>();
                skillData->skillProvider = NULL;

                gameObject->listaHabilidades.push_back(skillData);
            } else {
                gameObject->atiraItemMaginaDirecaoEstiver = true;
                gameObject->atiraItemMaginaDirecaoEstiverDano = 1;
                gameObject->atiraItemMaginaDirecaoEstiverIdItem = ((GameObject*)
                        ui->comboBoxObjectThrow->itemData(ui->comboBoxObjectThrow->currentIndex(), Qt::UserRole).value<void*>())->id;

            }

        }

        if(ui->checkBoxObjectThrowClick->isChecked()) {
            SkillData *skillData = new SkillData();
            skillData->id = Skill::SKILL_THROW_OBJECT_CLICK;
            skillData->intensity = 2;
            skillData->magicCost = 0;
            skillData->level = -1;
            skillData->skill = gameData->skillList->at(Skill::SKILL_THROW_OBJECT_CLICK);
            skillData->skillObject = (GameObject*)
                    ui->comboBoxObjectThrowClick->itemData(ui->comboBoxObjectThrowClick->currentIndex(), Qt::UserRole).value<void*>();
            skillData->skillProvider = NULL;

            gameObject->listaHabilidades.push_back(skillData);
        }

        if(ui->checkBoxRun->isChecked()) {
            SkillData *skillData = new SkillData();
            skillData->id = Skill::SKILL_RUN;
            skillData->intensity = 2;
            skillData->magicCost = 0;
            skillData->level = -1;
            skillData->skill = gameData->skillList->at(Skill::SKILL_RUN);
            skillData->skillObject = NULL;
            skillData->skillProvider = NULL;

            gameObject->listaHabilidades.push_back(skillData);
        }

        if(ui->checkBoxSwordUse->isChecked()) {
            SkillData *skillData = new SkillData();
            skillData->id = Skill::SKILL_USE_SWORD;
            skillData->intensity = 2;
            skillData->magicCost = 0;
            skillData->level = -1;
            skillData->skill = gameData->skillList->at(Skill::SKILL_USE_SWORD);
            skillData->skillObject = (GameObject*)
                    ui->comboBoxObjectThrowClick->itemData(ui->comboBoxObjectThrowClick->currentIndex(), Qt::UserRole).value<void*>();
            skillData->skillProvider = NULL;

            gameObject->listaHabilidades.push_back(skillData);
        }

        if(ui->checkBoxWallKick->isChecked()) {
            SkillData *skillData = new SkillData();
            skillData->id = Skill::SKILL_WALL_KICK;
            skillData->intensity = 35;
            skillData->magicCost = 0;
            skillData->level = -1;
            skillData->skill = gameData->skillList->at(Skill::SKILL_WALL_KICK);
            skillData->skillObject = NULL;
            skillData->skillProvider = NULL;

            gameObject->listaHabilidades.push_back(skillData);
        }

        if(ui->checkBoxAttackedLeaning->isChecked()) {
            gameObject->derrotaEncostandoInimigo = true;
        } else {
            gameObject->derrotaEncostandoInimigo = false;
        }

        if(ui->checkBoxAttackLeaning->isChecked()) {
            gameObject->atacaEncostaPersonagem = true;
            gameObject->atacaEncostaPersonagemDano = 1;
            gameObject->tempoAtaque = 3;
        } else {
            gameObject->atacaEncostaPersonagem = false;
            gameObject->atacaEncostaPersonagemDano = 0;
        }
    }





    return gameObject;
}

void EasyNewGameObjectDialog::populaCombosObjetos() {
    GameData *gameData = GameData::getInstance();

    ui->comboBoxObjectSword->clear();
    ui->comboBoxObjectThrow->clear();
    ui->comboBoxObjectThrowClick->clear();

    for(std::vector<GameObject*>::iterator it = gameData->objectList->begin(); it != gameData->objectList->end(); ++it) {
        GameObject *gameObject = *it;

        if(gameObject->type == GameObject::ITEM) {
            ui->comboBoxObjectSword->addItem(QIcon(QPixmap::fromImage(gameObject->getIconImage())), QString(gameObject->name.c_str()),
                                        QVariant::fromValue((void*) gameObject));

            ui->comboBoxObjectThrow->addItem(QIcon(QPixmap::fromImage(gameObject->getIconImage())), QString(gameObject->name.c_str()),
                                        QVariant::fromValue((void*) gameObject));

            ui->comboBoxObjectThrowClick->addItem(QIcon(QPixmap::fromImage(gameObject->getIconImage())), QString(gameObject->name.c_str()),
                                        QVariant::fromValue((void*) gameObject));
        }



    }
}

void EasyNewGameObjectDialog::habilitaCheckBoxes() {
    GameData *gameData = GameData::getInstance();

    std::vector<Skill*> *skillList = gameData->skillList;

    Skill *currentSkill;

    currentSkill = skillList->at(Skill::SKILL_DOUBLE_JUMP);
    if(std::find(currentSkill->objectTypes.begin(), currentSkill->objectTypes.end(), ui->comboBoxType->currentIndex()) != currentSkill->objectTypes.end()) {
        ui->checkBoxDoubleJump->setEnabled(true);
    } else {
        ui->checkBoxDoubleJump->setEnabled(false);
        ui->checkBoxDoubleJump->setChecked(false);
    }

    currentSkill = skillList->at(Skill::SKILL_FLY);
    if(std::find(currentSkill->objectTypes.begin(), currentSkill->objectTypes.end(), ui->comboBoxType->currentIndex()) != currentSkill->objectTypes.end()) {
        ui->checkBoxFly->setEnabled(true);
    } else {
        ui->checkBoxFly->setChecked(false);
        ui->checkBoxFly->setEnabled(false);
    }

    currentSkill = skillList->at(Skill::SKILL_GLIDE);
    if(std::find(currentSkill->objectTypes.begin(), currentSkill->objectTypes.end(), ui->comboBoxType->currentIndex()) != currentSkill->objectTypes.end()) {
        ui->checkBoxGlide->setEnabled(true);
    } else {
        ui->checkBoxGlide->setEnabled(false);
        ui->checkBoxGlide->setChecked(false);
    }

    currentSkill = skillList->at(Skill::SKILL_JUMP);
    if(std::find(currentSkill->objectTypes.begin(), currentSkill->objectTypes.end(), ui->comboBoxType->currentIndex()) != currentSkill->objectTypes.end()) {
        ui->checkBoxJump->setEnabled(true);
    } else {
        if(ui->comboBoxType->currentIndex() == GameObject::PLATFORM_MOVEMENT_OBJECT || GameObject::FIGHTING_MOVEMENT_OBJECT) {
            ui->checkBoxJump->setChecked(true);
        } else {
            ui->checkBoxJump->setChecked(false);
        }
        ui->checkBoxJump->setEnabled(false);
    }

    currentSkill = skillList->at(Skill::SKILL_RUN);
    if(std::find(currentSkill->objectTypes.begin(), currentSkill->objectTypes.end(), ui->comboBoxType->currentIndex()) != currentSkill->objectTypes.end()) {
        ui->checkBoxRun->setEnabled(true);
    } else {
        ui->checkBoxRun->setEnabled(false);
        ui->checkBoxRun->setChecked(false);
    }

    currentSkill = skillList->at(Skill::SKILL_THROW_OBJECT);
    if(std::find(currentSkill->objectTypes.begin(), currentSkill->objectTypes.end(), ui->comboBoxType->currentIndex()) != currentSkill->objectTypes.end()
            || ui->comboBoxType->currentIndex() == GameObject::INIMIGO) {
        ui->checkBoxObjectThrow->setEnabled(true);
        ui->comboBoxObjectThrow->setEnabled(true);
    } else {
        ui->checkBoxObjectThrow->setEnabled(false);
        ui->checkBoxObjectThrow->setChecked(false);
        ui->comboBoxObjectThrow->setEnabled(false);
    }

    currentSkill = skillList->at(Skill::SKILL_THROW_OBJECT_CLICK);
    if(std::find(currentSkill->objectTypes.begin(), currentSkill->objectTypes.end(), ui->comboBoxType->currentIndex()) != currentSkill->objectTypes.end()) {
        ui->checkBoxObjectThrowClick->setEnabled(true);
        ui->comboBoxObjectThrowClick->setEnabled(true);
    } else {
        ui->checkBoxObjectThrowClick->setEnabled(false);
        ui->checkBoxObjectThrowClick->setChecked(false);
        ui->comboBoxObjectThrowClick->setEnabled(false);
    }

    currentSkill = skillList->at(Skill::SKILL_USE_SWORD);
    if(std::find(currentSkill->objectTypes.begin(), currentSkill->objectTypes.end(), ui->comboBoxType->currentIndex()) != currentSkill->objectTypes.end()) {
        ui->checkBoxSwordUse->setEnabled(true);
        ui->comboBoxObjectSword->setEnabled(true);
    } else {
        ui->checkBoxSwordUse->setEnabled(false);
        ui->checkBoxSwordUse->setChecked(false);
        ui->comboBoxObjectSword->setEnabled(false);
    }

    currentSkill = skillList->at(Skill::SKILL_WALL_KICK);
    if(std::find(currentSkill->objectTypes.begin(), currentSkill->objectTypes.end(), ui->comboBoxType->currentIndex()) != currentSkill->objectTypes.end()) {
        ui->checkBoxWallKick->setEnabled(true);
    } else {
        ui->checkBoxWallKick->setEnabled(false);
        ui->checkBoxWallKick->setChecked(false);
    }

    if(ui->comboBoxType->currentIndex() == GameObject::INIMIGO) {
        ui->checkBoxAttackLeaning->setEnabled(true);
        ui->checkBoxAttackedLeaning->setEnabled(true);
    } else {
        ui->checkBoxAttackLeaning->setEnabled(false);
        ui->checkBoxAttackLeaning->setChecked(false);
        ui->checkBoxAttackedLeaning->setEnabled(false);
    }


}

void EasyNewGameObjectDialog::preencheComboMovementStyle() {
    switch(ui->comboBoxType->currentIndex()) {
    case GameObject::EIGHT_MOVEMENT_OBJECT:
        ui->comboBoxMovementStyle->clear();
        ui->comboBoxMovementStyle->setEnabled(false);
        break;
    case GameObject::CAR_MOVEMENT_OBJECT:
        ui->comboBoxMovementStyle->clear();
        ui->comboBoxMovementStyle->setEnabled(false);
        break;
    case GameObject::PLATFORM_MOVEMENT_OBJECT:
        ui->comboBoxMovementStyle->clear();
        ui->comboBoxMovementStyle->setEnabled(false);
        break;
    case GameObject::FIGHTING_MOVEMENT_OBJECT:
        ui->comboBoxMovementStyle->clear();
        ui->comboBoxMovementStyle->setEnabled(false);
        break;
    case GameObject::PONG_BALL_OBJECT:
        ui->comboBoxMovementStyle->clear();
        ui->comboBoxMovementStyle->setEnabled(false);
        break;
    case GameObject::MOUSE_MOVEMENT_OBJECT:
        ui->comboBoxMovementStyle->clear();
        ui->comboBoxMovementStyle->setEnabled(true);

        ui->comboBoxMovementStyle->addItem(QString::fromUtf8("Sempre na posição do mouse"));
        ui->comboBoxMovementStyle->addItem(QString::fromUtf8("Sempre na posição do mouse quando clicar"));
        ui->comboBoxMovementStyle->addItem(QString::fromUtf8("Sempre segue o mouse"));
        ui->comboBoxMovementStyle->addItem(QString::fromUtf8("Segue o mouse quando clicar"));
        ui->comboBoxMovementStyle->setCurrentIndex(2);
        break;
    case GameObject::STATIC_OBJECT:
        ui->comboBoxMovementStyle->clear();
        ui->comboBoxMovementStyle->setEnabled(false);
        break;
    case GameObject::NPC:

    case GameObject::INIMIGO:
        ui->comboBoxMovementStyle->clear();
        ui->comboBoxMovementStyle->setEnabled(true);
        ui->comboBoxMovementStyle->addItem(QString::fromUtf8("Parado"));
        ui->comboBoxMovementStyle->addItem(QString::fromUtf8("Segue personagem"));
        ui->comboBoxMovementStyle->addItem(QString::fromUtf8("Foge do personagem"));
        ui->comboBoxMovementStyle->addItem(QString::fromUtf8("Move esquerda/direita"));
        ui->comboBoxMovementStyle->addItem(QString::fromUtf8("Move cima/baixo"));
        ui->comboBoxMovementStyle->addItem(QString::fromUtf8("Movimento circular"));
        break;
    case GameObject::ITEM:
        ui->comboBoxMovementStyle->clear();
        ui->comboBoxMovementStyle->setEnabled(false);
        break;
    }
}

void EasyNewGameObjectDialog::on_comboBoxType_currentIndexChanged(int index)
{
    habilitaCheckBoxes();
    preencheComboMovementStyle();
}

void EasyNewGameObjectDialog::on_buttonBox_accepted()
{
    if(ui->lineEditName->text().isEmpty()) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Erro: O objeto precisa ter um nome!"));
        return;
    }

    if(ui->checkBoxObjectThrow->isChecked() && ui->comboBoxObjectThrow->count() == 0) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Erro: é necessário escolher um ítem para marcar a opção de atirar objeto."));
        return;
    }

    if(ui->checkBoxObjectThrowClick->isChecked() && ui->comboBoxObjectThrowClick->count() == 0) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Erro: é necessário escolher um ítem para marcar a opção de atirar objeto com clique."));
        return;
    }

    if(ui->checkBoxSwordUse->isChecked() && ui->comboBoxObjectSword->count() == 0) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Erro: é necessário escolher um ítem para marcar a opção de atirar objeto com clique."));
        return;
    }




    accept();
}

void EasyNewGameObjectDialog::on_buttonBox_rejected()
{
    delete gameObject;
    gameObject = NULL;

    reject();
}

void EasyNewGameObjectDialog::on_pushButtonEditGraphics_pressed()
{
    ConfigsObjAnimationChooserWindow *configsObjAnimationChooserWindow =
            new ConfigsObjAnimationChooserWindow(optionsController,
                                                       gameObject,
                                                       NULL,
                                                       this);

    configsObjAnimationChooserWindow->setWindowTitle("Graficos do objeto");

    configsObjAnimationChooserWindow->exec();

    delete configsObjAnimationChooserWindow;


    scene->removeItem(item);

    delete item;

    item =
            new QGraphicsPixmapItem(QPixmap::fromImage(gameObject->getIconImage()));

    item->setPos(0, 0);

    scene->addItem(item);
}
#include "editorconstants.h"

EditorConstants::EditorConstants()
{
}
#include "eventattributedata.h"



EventAttributeData::EventAttributeData(std::string name, std::list<int> *conditions, std::list<int> *actions)
{
    this->name = name;
    this->conditions = conditions;
    this->actions = actions;

    type = 0;
    showNumberValueCombo = true;
    showVariableValueCombo = true;
    showObjectFieldCombo = true;
    specialComboType = 0;
    showDirectionInput = true;
    showObject02 = 0;

    std::cout << "Sizes: " << sizeof(id) + sizeof(name) + sizeof(conditions) + sizeof(actions) + sizeof(type) + sizeof(showNumberValueCombo) + sizeof(showVariableValueCombo) + sizeof(showObjectFieldCombo) + sizeof(showDirectionInput) + sizeof(showObject02) + sizeof(specialComboType) << std::endl;
    std::cout << "Sizeofint: " << sizeof(int) << std::endl;
    std::cout << "Sizeofbool: " << sizeof(bool) << std::endl;

}

EventAttributeData::EventAttributeData() {

}

bool EventAttributeData::isObjectType() {
    return !showNumberValueCombo && !showVariableValueCombo && !showObjectFieldCombo && !showDirectionInput && showObject02;
}

bool EventAttributeData::isNothingType() {
    return !showNumberValueCombo && !showVariableValueCombo && !showObjectFieldCombo && !showDirectionInput && !showObject02;
}

bool EventAttributeData::showValueGroup() {
    return showNumberValueCombo || showVariableValueCombo || showObjectFieldCombo || showDirectionInput || specialComboType != 0;
}
#include "eventcombodataprovider.h"

EventComboDataProvider* EventComboDataProvider::singleton = NULL;


EventComboDataProvider* EventComboDataProvider::getInstance() {
    if(singleton == NULL) {
        singleton = new EventComboDataProvider();
    }

    return singleton;
}

EventAttributeData* EventComboDataProvider::getAttribute(int index) {
    std::map<int, EventAttributeData*>::iterator it = eventMap.find(index);
    if(it != eventMap.end()) {
        return it->second;
    } else {
        return NULL;
    }
}

QString EventComboDataProvider::getConditionString(int index) {
    std::map<int, std::string>::iterator it = conditionMap.find(index);
    if(it != conditionMap.end()) {
        return QString(it->second.c_str());
    } else {
        return NULL;
    }
}

QString EventComboDataProvider::getActionString(int index) {
    std::map<int, std::string>::iterator it = actionMap.find(index);
    if(it != conditionMap.end()) {
        return QString(it->second.c_str());
    } else {
        return NULL;
    }
}

std::list<GameObject*> EventComboDataProvider::getSpecialObjectList(int eventType) {
    std::list<GameObject*> specialObjectListFiltered;

    foreach(GameObject *gameObject, specialObjectList) {
        if(eventType == EventData::TYPE_ACTION) {
            if(gameObject->id == ID_SPECIAL_GLOBAL || gameObject->id == ID_SPECIAL_TIMER || gameObject->id ==  ID_SPECIAL_MUSIC) {
                specialObjectListFiltered.push_back(gameObject);
            }
        } else {
            specialObjectListFiltered.push_back(gameObject);
        }
    }

    return specialObjectListFiltered;
}
std::list<SpecialComboValueData*> EventComboDataProvider::getSpecialComboValueList(int specialType, GameObject *gameObject) {
    std::list<SpecialComboValueData*> list;
    GameData *gameData = GameData::getInstance();

    std::vector<Map*> *mapList = gameData->mapList;

    QDir *dir;
    QStringList files;
    QStringList filters;

    switch(specialType) {
    case EventAttributeData::COMBO_TYPE_KEY:

        pushSpecialComboData(&list, SDLK_UP, "Cima");
        pushSpecialComboData(&list, SDLK_RIGHT, "Direita");
        pushSpecialComboData(&list, SDLK_DOWN, "Baixo");
        pushSpecialComboData(&list, SDLK_LEFT, "Esquerda");

        pushSpecialComboData(&list, SDLK_a, "A");
        pushSpecialComboData(&list, SDLK_b, "B");
        pushSpecialComboData(&list, SDLK_c, "C");
        pushSpecialComboData(&list, SDLK_d, "D");
        pushSpecialComboData(&list, SDLK_e, "E");
        pushSpecialComboData(&list, SDLK_f, "F");
        pushSpecialComboData(&list, SDLK_g, "G");
        pushSpecialComboData(&list, SDLK_h, "H");
        pushSpecialComboData(&list, SDLK_i, "I");
        pushSpecialComboData(&list, SDLK_j, "J");
        pushSpecialComboData(&list, SDLK_k, "K");
        pushSpecialComboData(&list, SDLK_l, "L");
        pushSpecialComboData(&list, SDLK_m, "M");
        pushSpecialComboData(&list, SDLK_n, "N");
        pushSpecialComboData(&list, SDLK_o, "O");
        pushSpecialComboData(&list, SDLK_p, "P");
        pushSpecialComboData(&list, SDLK_q, "Q");
        pushSpecialComboData(&list, SDLK_r, "R");
        pushSpecialComboData(&list, SDLK_s, "S");
        pushSpecialComboData(&list, SDLK_t, "T");
        pushSpecialComboData(&list, SDLK_u, "U");
        pushSpecialComboData(&list, SDLK_v, "V");
        pushSpecialComboData(&list, SDLK_w, "W");
        pushSpecialComboData(&list, SDLK_x, "X");
        pushSpecialComboData(&list, SDLK_y, "Y");
        pushSpecialComboData(&list, SDLK_z, "Z");

        pushSpecialComboData(&list, SDLK_RETURN, "ENTER");
        pushSpecialComboData(&list, SDLK_SPACE, QString::fromUtf8("ESPAÇO").toStdString());
        pushSpecialComboData(&list, SDLK_RSHIFT, "SHIFT DIREITO");
        pushSpecialComboData(&list, SDLK_LSHIFT, "SHIFT ESQUERDO");
        pushSpecialComboData(&list, SDLK_RCTRL, "CTRL DIREITO");
        pushSpecialComboData(&list, SDLK_LCTRL, "CTRL ESQUERDO");
        pushSpecialComboData(&list, SDLK_RALT, "ALT DIREITO");
        pushSpecialComboData(&list, SDLK_LALT, "ALT ESQUERDO");


        break;
    case EventAttributeData::COMBO_TYPE_MAP:

        foreach(Map *map, *mapList) {
            pushSpecialComboData(&list, map->key, map->mapName);
        }


        break;
    case EventAttributeData::COMBO_TYPE_MOUSE:
            pushSpecialComboData(&list, 1, QString::fromUtf8("Botão esquerdo").toStdString());
            pushSpecialComboData(&list, 3, QString::fromUtf8("Botão direito").toStdString());
            pushSpecialComboData(&list, 2, QString::fromUtf8("Botão do meio").toStdString());


        break;
    case EventAttributeData::COMBO_TYPE_MUSIC:
        dir = new QDir(gameData->getProjectDirectory().append("/musics/").c_str());
        filters.clear();
        filters << "*.wav" << "*.mp3";
        std::cout << gameData->getProjectDirectory().append("/musics/");


        dir->setNameFilters(filters);

        files = dir->entryList();



        for(QStringList::Iterator it = files.begin(); it != files.end(); ++it) {
            pushSpecialComboData(&list, 0, ((QString)*it).toStdString());
        }
        break;
    case EventAttributeData::COMBO_TYPE_SOUND:    
        dir = new QDir(gameData->getProjectDirectory().append("/sfx/").c_str());
        filters.clear();
        filters << "*.wav" << "*.mp3";
        std::cout << gameData->getProjectDirectory().append("/sfx/");


        dir->setNameFilters(filters);

        files = dir->entryList();



        for(QStringList::Iterator it = files.begin(); it != files.end(); ++it) {
            pushSpecialComboData(&list, 0, ((QString)*it).toStdString());
        }
        break;
    case EventAttributeData::COMBO_TYPE_PROCEDURE:

        foreach(ProcedureData *procedureData, *gameData->procedureList) {
            std::stringstream ss;

            ss << "Global - " << procedureData->name;

            pushSpecialComboData(&list, procedureData->id, ss.str());
        }

        if(gameObject != NULL) {
           foreach(ProcedureData *procedureData, *gameObject->procedureList) {
               std::stringstream ss;

               ss << gameObject->name << " - " << procedureData->name;

               pushSpecialComboData(&list, -procedureData->id, ss.str());
           }
        }


        break;
    }

    return list;
}


bool EventComboDataProvider::isNoValueAction(int action) {
    switch(action) {
    case ACTION_TOOGLE_PAUSE_MUSIC:
        return true;
        break;
    case ACTION_STOP_MUSIC:
        return true;
        break;
    case ACTION_TOGGLE_PAUSE_SOUND:
        return true;
        break;
    case ACTION_STOP_SOUND:
        return true;
        break;
    case ACTION_RESET_MAP:
        return true;
    case ACTION_BOUNCE:
        return true;
        break;

    }


    return false;
}

bool EventComboDataProvider::isNoValueCondition(int condition) {
    switch(condition) {
    case COND_IS_MUSIC_PLAYING:
        return true;
        break;
    case COND_IS_SOUND_PLAYING:
        return true;
        break;

    }

    return false;
}

void EventComboDataProvider::pushAttributeData(int id, QString name, std::list<int> *conditions, std::list<int> *actions,
                                               bool showNumberValueCombo, bool showVariableValueCombo,
                                               bool showObjectFieldCombo, bool showDirectionInput,
                                               bool showObject02, int specialComboType) {

    EventAttributeData *eventAttributeData = new EventAttributeData();

    std::cout << "EAD size:" << sizeof(*eventAttributeData) << std::endl;



    eventAttributeData->name = std::string(name.toStdString().c_str());
    eventAttributeData->conditions = conditions;
    eventAttributeData->actions = actions;
    eventAttributeData->id = id;
    eventAttributeData->showNumberValueCombo = showNumberValueCombo;
    eventAttributeData->showVariableValueCombo = showVariableValueCombo;
    eventAttributeData->showObjectFieldCombo = showObjectFieldCombo;
    eventAttributeData->showObject02 = showObject02;
    eventAttributeData->showDirectionInput = showDirectionInput;
    eventAttributeData->specialComboType = specialComboType;




    eventMap.insert(std::pair<int, EventAttributeData*>(id, eventAttributeData));
}

void EventComboDataProvider::pushConditionData(int id, QString name) {
    conditionMap.insert(std::pair<int, std::string>(id, name.toStdString()));
}

void EventComboDataProvider::pushActionData(int id, QString name) {
    actionMap.insert(std::pair<int, std::string>(id, name.toStdString()));
}

void EventComboDataProvider::pushSpecialComboData(std::list<SpecialComboValueData *> *list, int code, std::string string) {
    SpecialComboValueData *specialComboValueData = new SpecialComboValueData();
    specialComboValueData->code = code;
    specialComboValueData->string = string;

    list->push_back(specialComboValueData);
}



EventComboDataProvider::EventComboDataProvider()
{


    std::list<int> *actions;
    std::list<int> *conds;

    actions = new std::list<int>();

    conds = new std::list<int>();
    conds->push_back((int)COND_DETECT_SIMPLE_COLLISION);
    conds->push_back((int)COND_DETECT_PIXEL_COLLISION);

    actions = new std::list<int>();

    pushAttributeData(ATT_COLISION, QString::fromUtf8("Colisão"), conds, actions,
                      false, false, false, false, true, false);


    conds = new std::list<int>();
    conds->push_back((int)COND_EQUAL);
    conds->push_back((int)COND_DIFFERENT);
    conds->push_back((int)COND_LESS);
    conds->push_back((int)COND_LESS_EQUAL);
    conds->push_back((int)COND_GREATER);
    conds->push_back((int)COND_GREATER_EQUAL);


    actions = new std::list<int>();
    actions->push_back((int)ACTION_SET_VALUE);
    actions->push_back((int)ACTION_ADD_VALUE);
    actions->push_back((int)ACTION_MULT_VALUE);
    actions->push_back((int)ACTION_DIV_VALUE);



    pushAttributeData(ATT_VARIABLES, QString::fromUtf8("[[VariableName]]"), conds, actions,
                     true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );

    pushAttributeData(ATT_POSITION_X, QString::fromUtf8("Posição X"), conds, actions,
                     true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_POSITION_Y, QString::fromUtf8("Posição Y"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_VELOCITY, QString::fromUtf8("Velocidade"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_VELOCITY_X, QString::fromUtf8("Velocidade X"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_VELOCITY_Y, QString::fromUtf8("Velocidade Y"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_ACCELERATION, QString::fromUtf8("Aceleração"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_ACCELERATION_X, QString::fromUtf8("Aceleração X"),conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_ACCELERATION_Y, QString::fromUtf8("Aceleração Y"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );

    pushAttributeData(ATT_GRAVITY, QString::fromUtf8("Gravidade"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_JUMP_INTENSITY, QString::fromUtf8("Intensidade do pulo"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_HP, QString::fromUtf8("HP (vida)"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_MP, QString::fromUtf8("MP (magia)"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_ATK, QString::fromUtf8("Ataque"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_DEF, QString::fromUtf8("Defesa"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_INT, QString::fromUtf8("Inteligência"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_OBJECT_LEVEL, QString::fromUtf8("Nível"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );




    conds = new std::list<int>();
    conds->push_back((int)COND_EQUAL);
    conds->push_back((int)COND_DIFFERENT);

    pushAttributeData(ATT_DIRECTION, QString::fromUtf8("Direção"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );

    actions = new std::list<int>();
    actions->push_back((int)ACTION_SET_VALUE);

    pushAttributeData(ATT_ANIMATION, QString::fromUtf8("Animação"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );

    actions = new std::list<int>();
    actions->push_back((int)ACTION_SET_VALUE);
    actions->push_back((int)ACTION_ADD_VALUE);
    actions->push_back((int)ACTION_MULT_VALUE);
    actions->push_back((int)ACTION_DIV_VALUE);

    pushAttributeData(ATT_ROTATION, QString::fromUtf8("Rotação"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE );
    pushAttributeData(ATT_ZOOM, QString::fromUtf8("Zoom"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE);

    actions = new std::list<int>();
    conds = new std::list<int>();

    conds->push_back((int)COND_BUTTON_PRESSED);
    conds->push_back((int)COND_BUTTON_DOWN);

    pushAttributeData(ATT_KEY, QString::fromUtf8("Teclado"), conds, actions,
                      false, false, false, false, false, EventAttributeData::COMBO_TYPE_KEY );

    actions = new std::list<int>();
    conds = new std::list<int>();

    conds->push_back((int)COND_MOUSE_BUTTON_PRESSED);
    conds->push_back((int)COND_MOUSE_BUTTON_DOWN);

    pushAttributeData(ATT_MOUSE, QString::fromUtf8("Mouse"), conds, actions,
                      false, false, false, false, false, EventAttributeData::COMBO_TYPE_MOUSE );


    actions = new std::list<int>();
    conds = new std::list<int>();

    conds->push_back((int)COND_IS_MUSIC_PLAYING);
    actions->push_back((int)ACTION_PLAY_MUSIC);
    actions->push_back((int)ACTION_TOOGLE_PAUSE_MUSIC);
    actions->push_back((int)ACTION_STOP_MUSIC);

    pushAttributeData(ATT_MUSIC, QString::fromUtf8("Música"), conds, actions,
                      false, false, false, false, false, EventAttributeData::COMBO_TYPE_MUSIC );

    actions = new std::list<int>();
    conds = new std::list<int>();

    conds->push_back((int)COND_IS_SOUND_PLAYING);
    actions->push_back((int)ACTION_PLAY_SOUND);
    actions->push_back((int)ACTION_TOGGLE_PAUSE_SOUND);
    actions->push_back((int)ACTION_STOP_SOUND);

    pushAttributeData(ATT_SOUND, QString::fromUtf8("Som"), conds, actions,
                      false, false, false, false, false, EventAttributeData::COMBO_TYPE_SOUND );

    actions = new std::list<int>();
    conds = new std::list<int>();

    conds->push_back((int)COND_IS_CURRENT_MAP);
    actions->push_back((int)ACTION_SET_MAP);
    actions->push_back((int)ACTION_RESET_MAP);

    pushAttributeData(ATT_MAP, QString::fromUtf8("Mapa"), conds, actions,
                      false, false, false, false, false, EventAttributeData::COMBO_TYPE_MAP );

    actions = new std::list<int>();
    conds = new std::list<int>();
    actions->push_back((int)ACTION_CALL_PROCEDURE);

    pushAttributeData(ATT_PROCEDURE, QString::fromUtf8("Procedimentos"), conds, actions,
                      false, false, false, false, false, EventAttributeData::COMBO_TYPE_PROCEDURE );

    actions = new std::list<int>();
    conds = new std::list<int>();
    conds->push_back((int)COND_EVERY_SECONDS);
    actions->push_back((int)ACTION_RESET_MAP_TIMER);
    actions->push_back((int)ACTION_RESET_GAME_TIMER);

    pushAttributeData(ATT_TIMER, QString::fromUtf8("Tempo"), conds, actions,
                      true, true, false, false, false, EventAttributeData::COMBO_TYPE_NONE);



    actions = new std::list<int>();
    conds = new std::list<int>();
    actions->push_back((int)ACTION_PLATFORM_JUMP);

    pushAttributeData(ATT_SPECIAL_PLATFORM_MOVEMENT, QString::fromUtf8("Especiais (Plataforma)"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE);

    actions = new std::list<int>();
    conds = new std::list<int>();
    actions->push_back((int)ACTION_BOUNCE);
    actions->push_back((int)ACTION_BOOST);

    pushAttributeData(ATT_MOVEMENT, QString::fromUtf8("Movimentos Extras"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE);

    actions = new std::list<int>();
    conds = new std::list<int>();
    conds->push_back((int)COND_EQUAL);
    conds->push_back((int)COND_DIFFERENT);
    conds->push_back((int)COND_LESS);
    conds->push_back((int)COND_LESS_EQUAL);
    conds->push_back((int)COND_GREATER);
    conds->push_back((int)COND_GREATER_EQUAL);

    pushAttributeData(ATT_INSTANCE_NUMBER, QString::fromUtf8("Número de objetos"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE);

    actions = new std::list<int>();
    conds = new std::list<int>();
    actions->push_back((int)ACTION_THROW_OBJECT);

    pushAttributeData(ATT_THROWER, QString::fromUtf8("Atirar objetos"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE);

    actions = new std::list<int>();
    conds = new std::list<int>();
    actions->push_back((int)ACTION_FOLLOW_OBJECT);
    actions->push_back((int)ACTION_UNFOLLOW_OBJECT);

    pushAttributeData(ATT_FOLLOWER, QString::fromUtf8("Seguir/Afastar"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE);

    actions = new std::list<int>();
    conds = new std::list<int>();
    conds->push_back((int)COND_IS_LEFT_SIDE);
    conds->push_back((int)COND_IS_UP_SIDE);
    conds->push_back((int)COND_IS_RIGHT_SIDE);
    conds->push_back((int)COND_IS_DOWN_SIDE);

    pushAttributeData(ATT_SIDES, QString::fromUtf8("Canto da tela"), conds, actions,
                      false, false, false, false, false, EventAttributeData::COMBO_TYPE_NONE);



    actions = new std::list<int>();
    conds = new std::list<int>();
    conds->push_back((int)COND_EQUAL);
    conds->push_back((int)COND_DIFFERENT);
    conds->push_back((int)COND_LESS);
    conds->push_back((int)COND_LESS_EQUAL);
    conds->push_back((int)COND_GREATER);
    conds->push_back((int)COND_GREATER_EQUAL);

    pushAttributeData(ATT_GAME_TIMER, QString::fromUtf8("Timer global"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE);
    pushAttributeData(ATT_MAP_TIMER, QString::fromUtf8("Timer do mapa"), conds, actions,
                      true, true, true, false, true, EventAttributeData::COMBO_TYPE_NONE);

    pushConditionData(COND_EQUAL, QString::fromUtf8("Igual a"));
    pushConditionData(COND_DIFFERENT, QString::fromUtf8("Diferente de"));
    pushConditionData(COND_LESS, QString::fromUtf8("Menor que"));
    pushConditionData(COND_LESS_EQUAL, QString::fromUtf8("Menor ou igual a"));
    pushConditionData(COND_GREATER, QString::fromUtf8("Maior que"));
    pushConditionData(COND_GREATER_EQUAL, QString::fromUtf8("Maior ou igual a"));

    pushConditionData(COND_DETECT_SIMPLE_COLLISION, QString("Colide com"));
    pushConditionData(COND_DETECT_PIXEL_COLLISION, QString("Colide (por pixel) com"));

    pushConditionData(COND_BUTTON_PRESSED, QString::fromUtf8("Botão apertado"));
    pushConditionData(COND_BUTTON_DOWN, QString::fromUtf8("Botão segurado"));

    pushConditionData(COND_MOUSE_BUTTON_PRESSED, QString::fromUtf8("Mouse apertado"));
    pushConditionData(COND_MOUSE_BUTTON_DOWN, QString::fromUtf8("Mouse segurado"));

    pushConditionData(COND_IS_MUSIC_PLAYING, QString::fromUtf8("Existe música tocando?"));
    pushConditionData(COND_IS_SOUND_PLAYING, QString::fromUtf8("Existe som tocando?"));

    pushConditionData(COND_IS_CURRENT_MAP, QString::fromUtf8("É o mapa atual"));

    pushConditionData(COND_EVERY_SECONDS, QString::fromUtf8("A cada __ segundos"));

    pushConditionData(COND_IS_LEFT_SIDE, QString::fromUtf8("No canto esquerdo"));
    pushConditionData(COND_IS_UP_SIDE, QString::fromUtf8("No canto de cima"));
    pushConditionData(COND_IS_RIGHT_SIDE, QString::fromUtf8("No canto direito"));
    pushConditionData(COND_IS_DOWN_SIDE, QString::fromUtf8("No canto debaixo"));

    pushActionData(ACTION_SET_VALUE, QString::fromUtf8("Determina valor"));
    pushActionData(ACTION_ADD_VALUE, QString::fromUtf8("Adiciona valor"));
    pushActionData(ACTION_MULT_VALUE, QString::fromUtf8("Multiplica valor"));
    pushActionData(ACTION_DIV_VALUE, QString::fromUtf8("Divide valor"));
    pushActionData(ACTION_DIV_VALUE, QString::fromUtf8("Divide valor"));

    pushActionData(ACTION_PLAY_MUSIC, QString::fromUtf8("Toca música"));
    pushActionData(ACTION_TOOGLE_PAUSE_MUSIC, QString::fromUtf8("Pausa/resume música"));
    pushActionData(ACTION_STOP_MUSIC, QString::fromUtf8("Para música"));

    pushActionData(ACTION_PLAY_SOUND, QString::fromUtf8("Toca som"));
    pushActionData(ACTION_TOGGLE_PAUSE_SOUND, QString::fromUtf8("Pausa/resume som"));
    pushActionData(ACTION_STOP_SOUND, QString::fromUtf8("Para som"));

    pushActionData(ACTION_SET_MAP, QString::fromUtf8("Pula para mapa"));
    pushActionData(ACTION_RESET_MAP, QString::fromUtf8("Reseta mapa"));

    pushActionData(ACTION_CALL_PROCEDURE, QString::fromUtf8("Chama procedimento"));

    pushActionData(ACTION_RESET_MAP_TIMER, QString::fromUtf8("Reinicia timer do mapa"));
    pushActionData(ACTION_RESET_GAME_TIMER, QString::fromUtf8("Reinicia timer do jogo"));

    pushActionData(ACTION_PLATFORM_JUMP, QString::fromUtf8("Pula"));

    pushActionData(ACTION_BOUNCE, QString::fromUtf8("Quica"));

    pushActionData(ACTION_BOOST, QString::fromUtf8("Impulsiona"));

    pushActionData(ACTION_THROW_OBJECT, QString::fromUtf8("Atira objeto na velocidade:"));

    pushActionData(ACTION_FOLLOW_OBJECT, QString::fromUtf8("Segue objeto na velocidade:"));
    pushActionData(ACTION_UNFOLLOW_OBJECT, QString::fromUtf8("Foge do objeto na velocidade:"));



    GameObject *specialGameObject = new GameObject(-1);
    specialGameObject->specialIconPath = std::string(":/icones_editor_eventos/data/event_editor_icons/globe-icon.png");
    specialGameObject->name = std::string("Globais");

    specialObjectList.push_back(specialGameObject);

    specialGameObject = new GameObject(-2);
    specialGameObject->specialIconPath = std::string(":/icones_editor_eventos/data/event_editor_icons/joystick-icon.png");
    specialGameObject->name = std::string("Controles");

    specialObjectList.push_back(specialGameObject);

    specialGameObject = new GameObject(-3);
    specialGameObject->specialIconPath = std::string(":/icones_editor_eventos/data/event_editor_icons/clock-icon.png");
    specialGameObject->name = std::string("Tempo");

    specialObjectList.push_back(specialGameObject);

    specialGameObject = new GameObject(-4);
    specialGameObject->specialIconPath = std::      string(":/icones_editor_eventos/data/event_editor_icons/music-icon.png");
    specialGameObject->name = QString::fromUtf8("Música/Som").toStdString();

    specialObjectList.push_back(specialGameObject);

}
#include "eventdata.h"

EventData::EventData()
{
    newEvent = true;
    eventComboDataProvider = EventComboDataProvider::getInstance();
    parent = NULL;
}


QString EventData::getEventString(GameObject *currentGameObject) {
    if(newEvent) {
        return QString("< Novo evento >");
    } else {
        GameData *gameData = GameData::getInstance();
        std::stringstream ss;

        GameObject *gameObject01 = gameData->searchGameObjectById(idObject01);

        if(gameObject01 || idObject01 == EventComboDataProvider::ID_SPECIAL_GLOBAL) {
            if(idObject01 != EventComboDataProvider::ID_SPECIAL_GLOBAL) {
                ss << gameObject01->name;

                ss << ".";
            } else {
                ss << "Global.";
            }


            if(idAssociatedVariable < 300) {
                ss << eventComboDataProvider->getAttribute(idAssociatedVariable)->name << ": ";
            } else {
                if(currentGameObject != NULL) {
                    ss << currentGameObject->getVariableById(idAssociatedVariable - 300)->name << ": ";
                } else {
                    ss << gameData->getVariableById(idAssociatedVariable - 300)->name << ": ";
                }
            }

        }




        if(type == TYPE_CONDITION) {
            ss << eventComboDataProvider->getConditionString(opcode).toStdString();
        } else {
            ss << eventComboDataProvider->getActionString(opcode).toStdString();
        }




        ss << " : ";

        GameObject *gameObject02;

        std::list<SpecialComboValueData*> listSpecialCombo;

        switch(valueType) {
        case VALUE_TYPE_NUMBER:
            ss << value01;
            break;
        case VALUE_TYPE_VARIABLE:
            if(value01 < 0) {
                ss << currentGameObject->name << "." << currentGameObject->getVariableById(-value01)->name;
            } else {
                ss << "Global." << gameData->getVariableById(value01)->name;
            }
            break;
        case VALUE_TYPE_OBJECT_ATTRIBUTE:
            if(idObject02 != -1) {
                gameObject02 = gameData->searchGameObjectById(idObject02);
                ss << gameObject02->name << "." << eventComboDataProvider->getAttribute(value01)->name;
            }

            break;
        case VALUE_TYPE_SPECIAL:
            switch(idAssociatedVariable) {
            case EventComboDataProvider::ATT_KEY:
                listSpecialCombo = eventComboDataProvider->getSpecialComboValueList(EventAttributeData::COMBO_TYPE_KEY, NULL);

                foreach(SpecialComboValueData *specialComboValue, listSpecialCombo) {
                    if(specialComboValue->code == value01) {
                        ss << specialComboValue->string;
                        break;
                    }
                }

                break;
            case EventComboDataProvider::ATT_MOUSE:
                listSpecialCombo = eventComboDataProvider->getSpecialComboValueList(EventAttributeData::COMBO_TYPE_MOUSE, NULL);

                foreach(SpecialComboValueData *specialComboValue, listSpecialCombo) {
                    if(specialComboValue->code = value01) {
                        ss << specialComboValue->string;
                        break;
                    }
                }
                break;
            case EventComboDataProvider::ATT_MAP:
                if(type == TYPE_ACTION && (opcode == EventComboDataProvider::ACTION_SET_MAP) || type == TYPE_CONDITION) {
                    listSpecialCombo = eventComboDataProvider->getSpecialComboValueList(EventAttributeData::COMBO_TYPE_MAP, NULL);

                    foreach(SpecialComboValueData *specialComboValue, listSpecialCombo) {
                        if(specialComboValue->code = value01) {
                            ss << specialComboValue->string;
                            break;
                        }
                    }
                }

                break;
            case EventComboDataProvider::ATT_MUSIC:
                if(type == TYPE_ACTION && opcode == EventComboDataProvider::ACTION_PLAY_MUSIC) {
                    ss << stringValue;
                }

                break;
            case EventComboDataProvider::ATT_SOUND:
                if(type == TYPE_ACTION && opcode == EventComboDataProvider::ACTION_PLAY_SOUND) {
                    ss << stringValue;
                }
                break;
            case EventComboDataProvider::ATT_PROCEDURE:
                if(value01 < 0) {
                    if(currentGameObject != NULL) {
                        ss << currentGameObject->name << " - " << currentGameObject->getProcedureById(-value01)->name;
                    }
                } else {
                    ss << gameData->getProcedureById(value01)->name;
                }


                break;

            default:
                ss << "x";
                break;
            }

            break;
        case VALUE_TYPE_OBJECT2:
            if(idObject02 != -1) {
                gameObject02 = gameData->searchGameObjectById(idObject02);
                ss << gameObject02->name;
            }

            break;
        }



        return QString(ss.str().c_str());
    }
}

QIcon EventData::getEventIcon() {
    if(newEvent) {
        return QIcon(":/icones_editor_eventos/data/event_editor_icons/new_event_icon.png");
    } else {
        if(type == TYPE_CONDITION) {
            return QIcon(":/icones_editor_eventos/data/event_editor_icons/condition_icon.png");
        } else {
            return QIcon(":/icones_editor_eventos/data/event_editor_icons/action_icon.png");
        }

    }

}

QIcon EventData::getObject01Icon() {
    if(newEvent) {
        return QIcon("");
    } else {
        GameData *gameData = GameData::getInstance();

        if(idObject01 > 0) {
            GameObject *gameObject01 = gameData->searchGameObjectById(idObject01);

            if(gameObject01) {
                return QIcon(QPixmap::fromImage(gameObject01->getIconImage()));
            } else {
                return QIcon("");
            }
        } else {
            std::list<GameObject*> specialObjects = eventComboDataProvider->getSpecialObjectList(type);

            foreach(GameObject *gameObject, specialObjects) {
                if(gameObject->id == idObject01) {
                    return QIcon(QPixmap::fromImage(gameObject->getIconImage()));
                }
            }

            return QIcon("");


        }


    }

    return QIcon("");
}

QIcon EventData::getObject02Icon() {
    if(newEvent) {
        return QIcon("");
    } else {
        GameData *gameData = GameData::getInstance();

        if(idObject02 != -1) {
            GameObject *gameObject02 = gameData->searchGameObjectById(idObject02);

            if(gameObject02) {
                return QIcon(QPixmap::fromImage(gameObject02->getIconImage()));
            }
        } else {
            return QIcon("");
        }


    }
}

void EventData::addChild(EventData *child) {
    child->parent = this;
    subEvents.push_back(child);

}
#include "eventseditorcontroller.h"

EventsEditorController::EventsEditorController()
{
    eventComboDataProvider = EventComboDataProvider::getInstance();
}

void EventsEditorController::setMainController(MainController *mainController)
{
    this->mainController = mainController;
}

void EventsEditorController::openNewConditionWindow(EventData *eventData, GameObject *gameObject = NULL) {
    NewEventDialog *newEventDialog = new NewEventDialog(this, eventData, gameObject, EventData::TYPE_CONDITION);
    newEventDialog->setWindowTitle(QString::fromUtf8("Nova condição"));
    newEventDialog->exec();

    delete newEventDialog;
}

void EventsEditorController::openNewActionWindow(EventData *eventData, GameObject *gameObject = NULL) {
    NewEventDialog *newEventDialog = new NewEventDialog(this, eventData, gameObject, EventData::TYPE_ACTION);
    newEventDialog->setWindowTitle(QString::fromUtf8("Nova ação"));
    newEventDialog->exec();

    delete newEventDialog;
}

void EventsEditorController::openEditEventWindow(EventData *eventData, GameObject *gameObject) {
    NewEventDialog *newEventDialog = new NewEventDialog(this, eventData, gameObject, eventData->type);
    newEventDialog->setWindowTitle(QString::fromUtf8("Nova ação"));
    newEventDialog->exec();

    delete newEventDialog;
}


std::list<EventAttributeData*> EventsEditorController::getComboAttributes(GameObject *gameObject, int eventType) {
    std::list<EventAttributeData*> listAttributes;
    GameData *gameData = GameData::getInstance();
    EventAttributeData *variableGenericAttribute;
    EventAttributeData *variableAttribute;

    if(gameObject != NULL) {
        // lista de atributos comuns

        if(gameObject->type != GameObject::SPECIAL) {
            listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_POSITION_X));
            listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_POSITION_Y));

            if(gameObject->type == GameObject::EIGHT_MOVEMENT_OBJECT ||
                    gameObject->type == GameObject::PLATFORM_MOVEMENT_OBJECT ||
                    gameObject->type == GameObject::FIGHTING_MOVEMENT_OBJECT ||
                    gameObject->type == GameObject::STATIC_OBJECT ||
                    gameObject->type == GameObject::NPC ||
                    gameObject->type == GameObject::INIMIGO) {
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_VELOCITY_X));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_VELOCITY_Y));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_ACCELERATION_X));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_ACCELERATION_Y));
            } else if(gameObject->type == GameObject::CAR_MOVEMENT_OBJECT ||
                      gameObject->type == GameObject::MOUSE_MOVEMENT_OBJECT) {
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_VELOCITY));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_ACCELERATION));
            }

            if(gameObject->type == GameObject::PLATFORM_MOVEMENT_OBJECT) {
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_GRAVITY));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_JUMP_INTENSITY));
            }


            if(gameObject->type != GameObject::NPC && gameObject->type != GameObject::ITEM &&
                    gameObject->type != GameObject::STATIC_OBJECT) {
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_HP));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_HP));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_ATK));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_DEF));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_INT));
            }


            listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_DIRECTION));
            listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_ANIMATION));
            listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_ROTATION));
            listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_ZOOM));

            if(gameObject->type == GameObject::PLATFORM_MOVEMENT_OBJECT && eventType == EventData::TYPE_ACTION) {
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_SPECIAL_PLATFORM_MOVEMENT));
            }

            if(eventType == EventData::TYPE_CONDITION) {
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_COLISION));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_SIDES));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_INSTANCE_NUMBER));
            } else {
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_MOVEMENT));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_THROWER));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_FOLLOWER));

            }

            listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_OBJECT_LEVEL));

            variableGenericAttribute = eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_VARIABLES);

            foreach(VariableData *variableData, *gameObject->variableList) {
                variableAttribute = new EventAttributeData(*variableGenericAttribute);

                variableAttribute->id += variableData->id;
                variableAttribute->name = variableData->name;

                listAttributes.push_back(variableAttribute);
            }




        } else {
            switch(gameObject->id) {
            case EventComboDataProvider::ID_SPECIAL_GLOBAL:
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_MAP));
                if(eventType == EventData::TYPE_ACTION) {
                    listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_PROCEDURE));
                }

                variableGenericAttribute = eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_VARIABLES);

                foreach(VariableData *variableData, *gameData->variableList) {
                    variableAttribute = new EventAttributeData(*variableGenericAttribute);

                    variableAttribute->id += variableData->id;
                    variableAttribute->name = variableData->name;

                    listAttributes.push_back(variableAttribute);
                }



                break;
            case EventComboDataProvider::ID_SPECIAL_JOYSTICK:
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_KEY));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_MOUSE));
                break;
            case EventComboDataProvider::ID_SPECIAL_MUSIC:
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_MUSIC));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_SOUND));
                break;
            case EventComboDataProvider::ID_SPECIAL_TIMER:
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_TIMER));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_GAME_TIMER));
                listAttributes.push_back(eventComboDataProvider->getAttribute(EventComboDataProvider::ATT_MAP_TIMER));
                break;
            }
        }







    }



    return listAttributes;
}

QString EventsEditorController::getComboConditionString(int index) {
    return eventComboDataProvider->getConditionString(index);
}

QString EventsEditorController::getComboActionString(int index) {
    return eventComboDataProvider->getActionString(index);
}


ProcedureData* EventsEditorController::addProcedure(GameObject *gameObject, Map *map) {
    ProcedureData *procedureData;

    if(gameObject == NULL) {
        GameData *gameData = GameData::getInstance();

        procedureData = new ProcedureData();

        gameData->addProcedure(procedureData);
    } else {
        procedureData = new ProcedureData();

        gameObject->addProcedure(procedureData);

    }

    return procedureData;
}

ProcedureData* EventsEditorController::addProcedure() {
    addProcedure(NULL, NULL);
}

ProcedureData* EventsEditorController::addProcedure(GameObject *gameObject) {
    addProcedure(gameObject, NULL);
}

ProcedureData* EventsEditorController::addProcedure(Map *map) {
    addProcedure(NULL, map);
}

std::vector<GameObject*> EventsEditorController::getContextObjects(EventData *eventData) {
    std::vector<GameObject*> objectList;

    EventData *parent;
    parent = eventData->parent;
    while(parent != NULL) {
        GameData *gameData = GameData::getInstance();

        GameObject *gameObject01 = gameData->searchGameObjectById(parent->idObject01);

        objectList.push_back(gameObject01);

        if(parent->idObject02 != -1) {
            GameObject *gameObject02 = gameData->searchGameObjectById(parent->idObject02);;
            objectList.push_back(gameObject02);
        } else {
            objectList.push_back(NULL);
        }

        parent = parent->parent;


    }

    return objectList;
}

std::list<GameObject*> EventsEditorController::getSpecialGameObjects(int eventType) {
    return eventComboDataProvider->getSpecialObjectList(eventType);
}

std::list<SpecialComboValueData*> EventsEditorController::getSpecialComboValueList(int specialType, GameObject *gameObject) {
    return eventComboDataProvider->getSpecialComboValueList(specialType, gameObject);
}

bool EventsEditorController::isNoValueAction(int action) {
    return eventComboDataProvider->isNoValueAction(action);
}

bool EventsEditorController::isNoValueCondition(int condition) {
    return eventComboDataProvider->isNoValueCondition(condition);
}
#include "eventswidget.h"
#include "ui_eventswidget.h"

EventsWidget::EventsWidget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::EventsWidget)
{
    ui->setupUi(this);

    populaComboTarget();
    populaListaProcedures();
    populaVariableList();
    populaEventTree();

}

EventsWidget::~EventsWidget()
{
    delete ui;
}

void EventsWidget::setEventsEditorController(EventsEditorController *eventsEditorController) {
    this->eventsEditorController = eventsEditorController;
}



void EventsWidget::selectObject(int idObject) {
    for(int i = 0; i < ui->comboBoxTarget->count(); i++) {
        GameObject *gameObject = (GameObject*) ui->comboBoxTarget->itemData(i, Qt::UserRole).value<void*>();

        if(gameObject != NULL && gameObject->id == idObject) {
            ui->comboBoxTarget->setCurrentIndex(i);
            break;
        }
    }
}

void EventsWidget::populaComboTarget() {
    GameData *gameData = GameData::getInstance();

    ui->comboBoxTarget->clear();

    ui->comboBoxTarget->addItem(QIcon(":/icones_interface/data/icons/Gear.png"), QString("Global"), QVariant::fromValue((void*) NULL));

    for(std::vector<GameObject*>::iterator it = gameData->objectList->begin(); it != gameData->objectList->end(); ++it) {
        GameObject *gameObject = *it;

        ui->comboBoxTarget->addItem(QIcon(QPixmap::fromImage(gameObject->getIconImage())), QString(gameObject->name.c_str()),
                                    QVariant::fromValue((void*) gameObject));

    }
}

void EventsWidget::populaListaProcedures() {
    GameData *gameData = GameData::getInstance();

    ui->listWidgetProcedures->clear();

    std::vector<ProcedureData*> *procedureList = NULL;

    if(ui->comboBoxTarget->itemData(ui->comboBoxTarget->currentIndex(), Qt::UserRole) != NULL) {
        GameObject *gameObject = (GameObject*)
            ui->comboBoxTarget->itemData(ui->comboBoxTarget->currentIndex(), Qt::UserRole).value<void*>();

        if(gameObject == NULL) {
            QListWidgetItem *itemProcedureAlways = new QListWidgetItem(QString(gameData->procedureGlobalAlways->name.c_str()));
            itemProcedureAlways->setData(Qt::UserRole, QVariant::fromValue((void*) gameData->procedureGlobalAlways));

            QListWidgetItem *itemProcedureStart = new QListWidgetItem(QString(gameData->procedureGlobalStart->name.c_str()));
            itemProcedureStart->setData(Qt::UserRole, QVariant::fromValue((void*) gameData->procedureGlobalStart));

            QListWidgetItem *itemProcedureEnd = new QListWidgetItem(QString(gameData->procedureGlobalEnd->name.c_str()));
            itemProcedureEnd->setData(Qt::UserRole, QVariant::fromValue((void*) gameData->procedureGlobalEnd));

            ui->listWidgetProcedures->addItem(itemProcedureAlways);
            ui->listWidgetProcedures->addItem(itemProcedureStart);
            ui->listWidgetProcedures->addItem(itemProcedureEnd);

            procedureList = gameData->procedureList;

        } else {
            QListWidgetItem *itemProcedureAlways = new QListWidgetItem(QString(gameObject->procedureGlobalAlways->name.c_str()));
            itemProcedureAlways->setData(Qt::UserRole, QVariant::fromValue((void*) gameObject->procedureGlobalAlways));

            QListWidgetItem *itemProcedureStart = new QListWidgetItem(QString(gameObject->procedureGlobalStart->name.c_str()));
            itemProcedureStart->setData(Qt::UserRole, QVariant::fromValue((void*) gameObject->procedureGlobalStart));

            QListWidgetItem *itemProcedureEnd = new QListWidgetItem(QString(gameObject->procedureGlobalEnd->name.c_str()));
            itemProcedureEnd->setData(Qt::UserRole, QVariant::fromValue((void*) gameObject->procedureGlobalEnd));



            ui->listWidgetProcedures->addItem(itemProcedureAlways);
            ui->listWidgetProcedures->addItem(itemProcedureStart);
            ui->listWidgetProcedures->addItem(itemProcedureEnd);

            procedureList = gameObject->procedureList;
        }
    }

    if(procedureList != NULL) {
        for(std::vector<ProcedureData*>::iterator it = procedureList->begin(); it != procedureList->end(); ++it) {
            ProcedureData* procedureData = *it;

            QListWidgetItem *procedureItem = new QListWidgetItem(QString(procedureData->name.c_str()));
            procedureItem->setData(Qt::UserRole, QVariant::fromValue((void*) procedureData));

            ui->listWidgetProcedures->addItem(procedureItem);


        }
    }

    ui->listWidgetProcedures->setCurrentRow(0);
}

void EventsWidget::populaEventTree() {
    GameData *gameData = GameData::getInstance();



    ui->treeWidgetEvents->clear();

    if(ui->listWidgetProcedures->currentItem() != NULL) {
        ProcedureData *currentProcedure =
                (ProcedureData*) ui->listWidgetProcedures->currentItem()->data(Qt::UserRole).value<void*>();

        ui->lineEditProcedureName->setText(QString(currentProcedure->name.c_str()));
        ui->lineEditProcedureName->setEnabled(currentProcedure->nameEditable);

        if(currentProcedure != NULL) {
            populaSubEventTree(NULL, &currentProcedure->events);


        }
    }


}

void EventsWidget::populaVariableList() {
    ui->listWidgetVariables->clear();

    if(ui->comboBoxTarget->itemData(ui->comboBoxTarget->currentIndex(), Qt::UserRole) != NULL) {
        GameObject *gameObject = (GameObject*)
            ui->comboBoxTarget->itemData(ui->comboBoxTarget->currentIndex(), Qt::UserRole).value<void*>();

        std::vector<VariableData*> *variableList;

        if(gameObject != NULL) {
            variableList = gameObject->variableList;

        } else {
            GameData *gameData = GameData::getInstance();

            variableList = gameData->variableList;
        }

        for(std::vector<VariableData*>::iterator it = variableList->begin(); it != variableList->end(); ++it) {
            VariableData *variableData = *it;

            QListWidgetItem *itemVariable = new QListWidgetItem(QString(variableData->name.c_str()));
            itemVariable->setData(Qt::UserRole, QVariant::fromValue((void*) variableData));

            ui->listWidgetVariables->addItem(itemVariable);
        }

    }
}

void EventsWidget::activateNewEventItemMenu(QTreeWidgetItem *item) {
    EventData *eventData = (EventData*) item->data(0, Qt::UserRole).value<void*>();

    QMenu menu;

    QAction *newAction = menu.addAction(QString::fromUtf8("Nova ação"));
    QAction *newCondition = menu.addAction(QString::fromUtf8("Nova condição"));




    QAction *selectedAction = menu.exec(QCursor::pos());

    if(selectedAction == newCondition) {
        GameObject *gameObject = (GameObject*)
            ui->comboBoxTarget->itemData(ui->comboBoxTarget->currentIndex(), Qt::UserRole).value<void*>();

        eventsEditorController->openNewConditionWindow(eventData, gameObject);
        QTreeWidgetItem *currentItem = ui->treeWidgetEvents->currentItem();


        if(!eventData->newEvent) {
            setTreeWidgetItemData(currentItem, eventData);

            if(eventData->type == EventData::TYPE_CONDITION) {
                EventData *childEventData = new EventData();
                EventData *nextEventData = new EventData();

                QTreeWidgetItem *child = new QTreeWidgetItem();
                QTreeWidgetItem *next = new QTreeWidgetItem();

                setTreeWidgetItemData(child, childEventData);
                setTreeWidgetItemData(next, nextEventData);

                currentItem->addChild(child);

                eventData->addChild(childEventData);

                if(currentItem->parent() != NULL) {
                    currentItem->parent()->addChild(next);
                    eventData->parent->addChild(nextEventData);


                } else {
                    ui->treeWidgetEvents->addTopLevelItem(next);

                    ProcedureData *currentProcedure =
                            (ProcedureData*) ui->listWidgetProcedures->currentItem()->data(Qt::UserRole).value<void*>();

                    currentProcedure->events.push_back(nextEventData);
                }





            }



        }
    } else if(selectedAction == newAction) {
        GameObject *gameObject = (GameObject*)
            ui->comboBoxTarget->itemData(ui->comboBoxTarget->currentIndex(), Qt::UserRole).value<void*>();

        eventsEditorController->openNewActionWindow(eventData, gameObject);
        QTreeWidgetItem *currentItem = ui->treeWidgetEvents->currentItem();

        if(!eventData->newEvent) {
            setTreeWidgetItemData(currentItem, eventData);

            if(eventData->type == EventData::TYPE_ACTION) {
                EventData *nextEventData = new EventData();
                QTreeWidgetItem *next = new QTreeWidgetItem();

                setTreeWidgetItemData(next, nextEventData);

                if(currentItem->parent() != NULL) {
                    currentItem->parent()->addChild(next);
                    eventData->parent->addChild(nextEventData);


                } else {
                    ui->treeWidgetEvents->addTopLevelItem(next);

                    ProcedureData *currentProcedure =
                            (ProcedureData*) ui->listWidgetProcedures->currentItem()->data(Qt::UserRole).value<void*>();

                    currentProcedure->events.push_back(nextEventData);
                }

            }
        }
    }
}

void EventsWidget::activateCreatedEventItemMenu(QTreeWidgetItem *item) {
    EventData *eventData = (EventData*) item->data(0, Qt::UserRole).value<void*>();

    QMenu menu;

    QAction *editAction = menu.addAction(QString::fromUtf8("Editar"));
    QAction *removeAction = menu.addAction(QString::fromUtf8("Remover"));

    QAction *selectedAction = menu.exec(QCursor::pos());

    if(selectedAction == removeAction) {
        delete item;

        if(eventData->parent == NULL) {
            if(ui->listWidgetProcedures->currentItem() != NULL) {
                ProcedureData *currentProcedure =
                        (ProcedureData*) ui->listWidgetProcedures->currentItem()->data(Qt::UserRole).value<void*>();

                currentProcedure->events.remove(eventData);
            }
        } else {
            eventData->parent->subEvents.remove(eventData);
        }
    } else if(selectedAction = editAction) {
        GameObject *gameObject = (GameObject*)
            ui->comboBoxTarget->itemData(ui->comboBoxTarget->currentIndex(), Qt::UserRole).value<void*>();

        eventsEditorController->openEditEventWindow(eventData, gameObject);

        setTreeWidgetItemData(item, eventData);
    }

}

void EventsWidget::setTreeWidgetItemData(QTreeWidgetItem *widgetItem, EventData *eventData) {
    GameObject *gameObject = (GameObject*)
        ui->comboBoxTarget->itemData(ui->comboBoxTarget->currentIndex(), Qt::UserRole).value<void*>();

    QString eventString = eventData->getEventString(gameObject);
    widgetItem->setData(0, Qt::UserRole, QVariant::fromValue((void*) eventData));
    widgetItem->setText(0, eventString);
    widgetItem->setToolTip(0, eventString);
    widgetItem->setIcon(0, eventData->getEventIcon());
    widgetItem->setIcon(1, eventData->getObject01Icon());
    widgetItem->setIcon(2, eventData->getObject02Icon());

}

void EventsWidget::populaSubEventTree(QTreeWidgetItem *parent, std::list<EventData *> *events) {
    ui->treeWidgetEvents->header()->resizeSection(0, 350);
    ui->treeWidgetEvents->header()->resizeSection(1, 32);
    ui->treeWidgetEvents->header()->resizeSection(2, 32);

    for(std::list<EventData*>::iterator it = events->begin(); it != events->end(); ++it) {
        EventData *eventData = *it;

        QTreeWidgetItem *widgetItem = new QTreeWidgetItem();
        setTreeWidgetItemData(widgetItem, eventData);



        if(!eventData->subEvents.empty()) {
            populaSubEventTree(widgetItem, &eventData->subEvents);
        }


        if(parent != NULL) {
            parent->addChild(widgetItem);
        } else {
            ui->treeWidgetEvents->addTopLevelItem(widgetItem);
        }

         widgetItem->setExpanded(true);
    }
}

void EventsWidget::on_comboBoxTarget_currentIndexChanged(int index)
{
    populaListaProcedures();
    populaVariableList();
}


void EventsWidget::on_listWidgetProcedures_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    populaEventTree();
}

void EventsWidget::on_treeWidgetEvents_itemDoubleClicked(QTreeWidgetItem* item, int column)
{
    EventData *eventData = (EventData*) item->data(0, Qt::UserRole).value<void*>();

    if(eventData->newEvent) {
        activateNewEventItemMenu(item);
    } else {
        activateCreatedEventItemMenu(item);
    }

}

void EventsWidget::on_pushButtonNewProc_pressed()
{
    GameObject *gameObject = (GameObject*)
        ui->comboBoxTarget->itemData(ui->comboBoxTarget->currentIndex(), Qt::UserRole).value<void*>();

    ProcedureData* newProcedure;

    if(gameObject == NULL) {
        newProcedure = eventsEditorController->addProcedure();


    } else {
        newProcedure = eventsEditorController->addProcedure(gameObject);
    }

    QListWidgetItem *newProcedureItem = new QListWidgetItem(QString(newProcedure->name.c_str()));
    newProcedureItem->setData(Qt::UserRole, QVariant::fromValue((void*) newProcedure));
    ui->listWidgetProcedures->addItem(newProcedureItem);

}

void EventsWidget::on_lineEditProcedureName_textChanged(QString text)
{
    if(!text.isEmpty()) {
        if(ui->listWidgetProcedures->currentItem() != NULL) {
            ProcedureData *currentProcedure =
                    (ProcedureData*) ui->listWidgetProcedures->currentItem()->data(Qt::UserRole).value<void*>();

            if(currentProcedure != NULL){
                ui->listWidgetProcedures->currentItem()->setText(text);
                currentProcedure->name = text.toStdString();
            }
        }

    }
}

void EventsWidget::on_pushButtonNewVar_pressed()
{
    NewVariableDialog *newVariableDialog = new NewVariableDialog(NULL, this);
    newVariableDialog->setWindowTitle(QString::fromUtf8("Nova variável"));

    VariableData *variableData = newVariableDialog->exec();

    if(variableData != NULL) {
        GameObject *gameObject = (GameObject*)
            ui->comboBoxTarget->itemData(ui->comboBoxTarget->currentIndex(), Qt::UserRole).value<void*>();



        if(gameObject != NULL) {
            gameObject->addVariable(variableData);
        } else {
            GameData *gameData = GameData::getInstance();
            gameData->addVariable(variableData);
        }

        QListWidgetItem *itemVariable = new QListWidgetItem(QString(variableData->name.c_str()));
        itemVariable->setData(Qt::UserRole, QVariant::fromValue((void*) variableData));

        ui->listWidgetVariables->addItem(itemVariable);



    }
}




void EventsWidget::on_pushButtonEditVar_pressed()
{
    QListWidgetItem *currentItem = ui->listWidgetVariables->currentItem();

    if(currentItem != NULL) {
        VariableData *variableData = (VariableData*) currentItem->data(Qt::UserRole).value<void*>();

        NewVariableDialog *newVariableDialog = new NewVariableDialog(variableData, this);
        newVariableDialog->setWindowTitle(QString::fromUtf8("Editar variável"));

        variableData = newVariableDialog->exec();

        currentItem->setText(QString(variableData->name.c_str()));
    }


}
#include "gamedata.h"


int GameData::MAGIC_NUMBER = 0xAFACABBE;
GameData* GameData::singleton = NULL;

GameData::GameData()
{
    gameName = NULL;
    tileSetList = new std::vector<TileSet*>();
    mapList = new std::vector<Map*>();
    objectList = new std::vector<GameObject*>();
    animationDataList = new std::vector<AnimationData*>();
    backgroundList = new std::vector<Background*>();
    procedureList = new std::vector<ProcedureData*>();
    variableList = new std::vector<VariableData*>();
    editingMap = NULL;

    skillList = Skill::getEditorSkills();

    titleScreenMusic = std::string("");
    optionsScreenMusic = std::string("");
    gameOverScreenMusic = std::string("");

    loopGameOverScreenMusic = -1;
    loopTitleScreenMusic = -1;
    loopOptionsScreenMusic = -1;
    idFirstMap = 0;

    procedureGlobalAlways = new ProcedureData();
    procedureGlobalAlways->name = QString::fromUtf8("Sempre").toStdString();
    procedureGlobalAlways->nameEditable = false;
    procedureGlobalStart = new ProcedureData();
    procedureGlobalStart->name = QString::fromUtf8("Início do jogo").toStdString();
    procedureGlobalStart->nameEditable = false;
    procedureGlobalEnd = new ProcedureData();
    procedureGlobalEnd->name = QString::fromUtf8("Fim do jogo").toStdString();
    procedureGlobalEnd->nameEditable = false;

}

GameData::~GameData()
{
}

GameData* GameData::getInstance() {
    if(singleton == NULL) {
        singleton = new GameData();
    }

    return singleton;
}



std::string GameData::getProjectDirectory() {
    int posicaoUltimaBarra;

    posicaoUltimaBarra = filePath.find_last_of("/");

    return filePath.substr(0, posicaoUltimaBarra);
}

void GameData::createSubDirectory(std::string *filePath, std::string dir) {
    std::string *subdirectory;

    subdirectory = new std::string(filePath->c_str());
    subdirectory->append(dir);

    if(!QDir(subdirectory->c_str()).exists()) {
        QDir().mkdir(subdirectory->c_str());
    }
}



void GameData::createDirectoryStructure(std::string *filePath) {

    if(!QDir(filePath->c_str()).exists()) {
        QDir().mkdir(filePath->c_str());
    }

    createSubDirectory(filePath, "/tilesets/");
    createSubDirectory(filePath, "/sfx/");
    createSubDirectory(filePath, "/musics/");
    createSubDirectory(filePath, "/objects/");
    createSubDirectory(filePath, "/images/");
    createSubDirectory(filePath, "/animations/");
    createSubDirectory(filePath, "/runtime-common/");

    /* copiando alguns arquivos essenciais */
    std::string destPath;

    destPath = std::string(filePath->c_str());

    if(!QFile().copy(QString("data/project_data/default_object_sprite.png"), QString(std::string(destPath.c_str()).append("/objects/default_object_sprite.png").c_str()))) {
        printf("Falha no carregamento do default_object_sprite.");

        exit(1);
    }

    if(!QFile().copy(QString("data/project_data/default_title_screen.png"), QString(std::string(destPath.c_str()).append("/images/default_title_screen.png").c_str()))) {
        printf("Falha no carregamento do default_title_screen.png.");
        exit(1);
    }

    if(!QFile().copy(QString("data/project_data/default_options_screen.png"), QString(std::string(destPath.c_str()).append("/images/default_options_screen.png").c_str()))) {
        printf("Falha no carregamento do default_options_screen.png.");
        exit(1);
    }

    if(!QFile().copy(QString("data/project_data/default_gameover_screen.png"), QString(std::string(destPath.c_str()).append("/images/default_gameover_screen.png").c_str()))) {
        printf("Falha no carregamento do default_gameover_screen.png.");
        exit(1);
    }

    if(!QFile().copy(QString("data/project_data/runtime-common/dialog_bar1.png"), QString(std::string(destPath.c_str()).append("/runtime-common/dialog_bar1.png").c_str()))) {
        printf("Falha no carregamento do dialog_bar1.png.");
        exit(1);
    }

    if(!QFile().copy(QString("data/project_data/runtime-common/iconsolata.ttf"), QString(std::string(destPath.c_str()).append("/runtime-common/iconsolata.ttf").c_str()))) {
        printf("Falha no carregamento do dialog_bar1.png.");
        exit(1);
    }

    if(!QFile().copy(QString("data/project_data/runtime-common/oldsansblack.ttf"), QString(std::string(destPath.c_str()).append("/runtime-common/oldsansblack.ttf").c_str()))) {
        printf("Falha no carregamento do oldsansblack.ttf .");
        exit(1);
    }

    if(!QFile().copy(QString("data/project_data/runtime-common/runtime"), QString(std::string(destPath.c_str()).append("/ludo.exe").c_str()))) {
        printf("Falha no carregamento do dialog_bar1.png.");
        exit(1);
    }


}

void GameData::createInstance(std::string gameName, std::string folderName) {
    erase();

    this->gameName = new std::string(gameName.c_str());
    resWidth = 640;
    resHeight = 480;

    std::string *filePath;


    if(!QDir("projects/").exists()) {
        QDir().mkdir("projects/");
    }

    filePath = new std::string();

    filePath->append("projects/");
    filePath->append(folderName.c_str());

    // cria diretorio
    createDirectoryStructure(filePath);



    filePath->append("/game.ldo");

    this->filePath = *filePath;

    setTitleScreenFile("default_title_screen.png");
    setOptionsScreenFile("default_options_screen.png");
    setGameOverScreenFile("default_gameover_screen.png");

    save(*filePath);




}

void GameData::erase() {
    if(gameName != NULL) {
        delete gameName;
    }

    gameName = NULL;

    resWidth = 0;
    resHeight = 0;
}


char* GameData::loadString(FILE *fp) {
    char* string;
    int tamanho;

    fread(&tamanho, 1, sizeof(int), fp);
    string = (char*) calloc(tamanho + 1, sizeof(char));

    string[tamanho] = '\0';

    fread(string, sizeof(char), tamanho, fp);

    return string;
    
}

bool GameData::load(std::string fileName) {

    FILE *fp;
    fp = fopen(fileName.c_str(), "rb");

    /* lendo o numero magico e verificando se de fato é um número mágico */
    int magic_number;
    fread(&magic_number, 1, sizeof(int), fp);

    if(magic_number != MAGIC_NUMBER) {
        return false;
    }

    this->filePath = fileName;

    /* lê o nome do jogo */
    /*
    char *nome_jogo;
    int tamanho_nome_jogo;

    fread(&tamanho_nome_jogo, 1, sizeof(int), fp);
    nome_jogo = (char*) calloc(tamanho_nome_jogo + 1, sizeof(char));
    nome_jogo[tamanho_nome_jogo] = '\0';

    fread(nome_jogo, sizeof(char), tamanho_nome_jogo, fp);
    */

    char *nome_jogo;
    nome_jogo = loadString(fp);

    gameName = new std::string(nome_jogo);

    /* lê a resolução do jogo */
    fread(&resWidth, 1, sizeof(int), fp);
    fread(&resHeight, 1, sizeof(int), fp);

    loadTilesetList(fp);

    /* inicio das adicoes - 12 de março - PENDENTES NO RUNTIME -- OK*/
    loadAnimationDataList(fp);
    /* fim */

    loadObjectList(fp);
    loadObjectSkills(fp);

    loadBackgroundList(fp);

    mapList = loadMapList(fp);

    loadAllVariableLists(fp);

    loadAllEvents(fp);


    /*  lendo os nomes das imagens das telas principais */
    titleScreenData.backgroundFile = std::string(loadString(fp));
    optionsScreenFile = std::string(loadString(fp));
    gameoverScreenFile = std::string(loadString(fp));

    /* lendo os nomes das musicas das telas principais */
    titleScreenMusic = std::string(loadString(fp));
    optionsScreenMusic = std::string(loadString(fp));
    gameOverScreenMusic = std::string(loadString(fp));

    /* lendo a id do mapa inicial */
    fread(&idFirstMap, 1, sizeof(int), fp);

    fclose(fp);

    return true;
}


void GameData::saveString(std::string *str, FILE *fp) {
    int tamanho_string = str->size();
    fwrite(&tamanho_string, 1, sizeof(int), fp);
    fwrite(str->c_str(), tamanho_string, sizeof(char), fp);
}

bool GameData::save(std::string fileName) {
    FILE *fp;



    fp = fopen(fileName.c_str(), "wb");

    if(fp == NULL) {
        printf("erro ao salvar %s.\n", fileName.c_str());
        exit(1);
    }

    /* gravando o numero magico para indicar que é um arquivo de projeto do Ludo */
    fwrite(&MAGIC_NUMBER, 1, sizeof(int), fp);

    /* gravando o tamanho do nome do jogo, seguido do nome propriamente dito */
    int tamanho_nome_jogo;
    tamanho_nome_jogo = gameName->size();

    fwrite(&tamanho_nome_jogo, 1, sizeof(int), fp);
    fwrite(gameName->c_str(), gameName->size(), sizeof(char), fp);

    /* gravando a resolução do jogo */
    fwrite(&resWidth, 1, sizeof(int), fp);
    fwrite(&resHeight, 1, sizeof(int), fp);

    saveTilesetList(fp);

    /* inicio das adicoes - 12 de março - PENDENTES NO RUNTIME */
    saveAnimationDataList(fp);
    /* fim */

    saveObjectList(fp);
    saveObjectSkills(fp);

    saveBackgroundList(fp);

    saveMapList(fp, mapList);

    saveAllVariableLists(fp);

    saveAllEvents(fp);

    /* gravando os nomes das imagens das telas principais */
    saveString(&titleScreenData.backgroundFile, fp);
    saveString(&optionsScreenFile, fp);
    saveString(&gameoverScreenFile, fp);

    /* gravando os nomes das musicas das telas principais */
    saveString(&titleScreenMusic, fp);
    saveString(&optionsScreenMusic, fp);
    saveString(&gameOverScreenMusic, fp);

    /* gravando a id do mapa inicial */
    fwrite(&idFirstMap, 1, sizeof(int), fp);

    fclose(fp);

    return true;
}

bool GameData::saveTilesetList(FILE *fp) {
    int tileSetListSize;
    tileSetListSize = tileSetList->size();

    fwrite(&tileSetListSize, 1, sizeof(int), fp);

    for(std::vector<TileSet*>::iterator it = tileSetList->begin(); it != tileSetList->end(); ++it) {
        TileSet* tileset = (*it);

        fwrite(&tileset->id, 1, sizeof(int), fp);

        saveString(&tileset->file, fp);

        saveString(&tileset->name, fp);

        fwrite(&tileset->width, 1, sizeof(int), fp);
        fwrite(&tileset->height, 1, sizeof(int), fp);

        fwrite(&tileset->maxX, 1, sizeof(int), fp);
        fwrite(&tileset->maxY, 1, sizeof(int), fp);

        fwrite(&tileset->tileSize, 1, sizeof(int), fp);

        // TODO: salvar o collisionmatrix

        int i, j;
        for(i = 0; i < tileset->maxX; i++) {
            for(j = 0; j < tileset->maxY; j++) {
                fwrite(&tileset->collisionMatrix[i][j], 1, sizeof(int), fp);
            }
        }



    }
}

bool GameData::loadTilesetList(FILE *fp) {
    int num_tilesets;

    fread(&num_tilesets, 1, sizeof(int), fp);
    tileSetList = new std::vector<TileSet*>();

    int i;
    for(i = 0; i < num_tilesets; i++) {
        TileSet *tileSet = new TileSet();

        fread(&(tileSet->id), 1, sizeof(int), fp);

        tileSet->file = std::string(loadString(fp));
        tileSet->name = std::string(loadString(fp));


        fread(&(tileSet->width), 1, sizeof(int), fp);
        fread(&(tileSet->height), 1, sizeof(int), fp);

        fread(&(tileSet->maxX), 1, sizeof(int), fp);
        fread(&(tileSet->maxY), 1, sizeof(int), fp);

        fread(&(tileSet->tileSize), 1, sizeof(int), fp);


        tileSet->collisionMatrix.resize(boost::extents[tileSet->maxX][tileSet->maxY]);
        int j, k;
        for(j = 0; j < tileSet->maxX; j++) {
            for(k = 0; k < tileSet->maxY; k++) {
                int valor;
                fread(&valor, 1, sizeof(int), fp);
                tileSet->collisionMatrix[j][k] = valor;
            }
        }

        tileSet->reloadTilesetImage();

        tileSetList->push_back(tileSet);



    }
}

bool GameData::saveMapList(FILE *fp, std::vector<Map*>* list) {
    int mapListSize;
    mapListSize = list->size();

    fwrite(&mapListSize, 1, sizeof(int), fp);

    for(std::vector<Map*>::iterator it = list->begin(); it != list->end(); ++it) {
        Map* map = (*it);
        int tamanho_string;

        if(map->isFolder()) {
            int continue_int = 1;

            fwrite(&continue_int, 1, sizeof(int), fp);

            tamanho_string = map->mapName.size();
            fwrite(&tamanho_string, 1, sizeof(int), fp);
            fwrite(map->mapName.c_str(), tamanho_string, sizeof(char), fp);

            saveMapList(fp, map->filhos);
        } else {
            int null_int = 0;

            fwrite(&null_int, 1, sizeof(int), fp);

            fwrite(&(map->key), 1, sizeof(int), fp);

            tamanho_string = map->mapName.size();
            fwrite(&tamanho_string, 1, sizeof(int), fp);
            fwrite(map->mapName.c_str(), tamanho_string, sizeof(char), fp);

            fwrite(&(map->width), 1, sizeof(int), fp);
            fwrite(&(map->height), 1, sizeof(int), fp);

            fwrite(&(map->layers), 1, sizeof(int), fp);

            int tilesetListSize;
            if(map->tileSets != NULL && !map->tileSets->empty()) {
                tilesetListSize =  map->tileSets->size();
            } else {
                tilesetListSize = 0;
            }


            fwrite(&(tilesetListSize), 1, sizeof(int), fp);

            for(std::vector<TileSet*>::iterator it2 = map->tileSets->begin(); it2 != map->tileSets->end(); ++it2) {
                TileSet* tileSet = (*it2);

                fwrite(&(tileSet->id), 1, sizeof(int), fp);
            }

            /* ALTERACOES 22-FEV-2011 COMECAM AQUI */
            saveString(&map->music, fp);
            saveString(&map->sound, fp);

            fwrite(&map->loopMusic, 1, sizeof(int), fp);
            fwrite(&map->loopSound, 1, sizeof(int), fp);
            fwrite(&map->idFundo, 1, sizeof(int), fp);

            /* gravando as instancias de objetos */

            int nro_instancias = map->gameObjectInstances->size();
            fwrite(&nro_instancias, 1, sizeof(int), fp);

            for(std::vector<GameObjectInstance*>::iterator it2 = map->gameObjectInstances->begin(); it2 != map->gameObjectInstances->end(); ++it2) {
                GameObjectInstance *gameObjectInstance = *it2;

                fwrite(&gameObjectInstance->id, 1, sizeof(unsigned int), fp);
                fwrite(&gameObjectInstance->gameObject->id, 1,  sizeof(int), fp);
                fwrite(&gameObjectInstance->x, 1,  sizeof(int), fp);
                fwrite(&gameObjectInstance->y, 1,  sizeof(int), fp);

                fwrite(&gameObjectInstance->nroEventos, 1, sizeof(int), fp);
                fwrite(&gameObjectInstance->nroFalas, 1, sizeof(int), fp);

                fwrite(&gameObjectInstance->isCenter, 1, sizeof(bool), fp);
                fwrite(&gameObjectInstance->isMainObject, 1, sizeof(bool), fp);
            }



            /* ALTERACOES 22-FEV-2011 TERMINAM AQUI */


            /* salvando o mapa */
            int i, j, k;
            for(i = 0; i < map->width; i++) {
                for(j = 0; j < map->height; j++) {
                    for(k = 0; k < map->layers; k++) {
                        fwrite(&(map->map[i][j][k].x), 1, sizeof(int), fp);
                        fwrite(&(map->map[i][j][k].y), 1, sizeof(int), fp);
                        TileSet *mapTileSet = map->map[i][j][k].z;

                        if(mapTileSet == NULL) {
                            int null_int = -1;
                            fwrite(&null_int, 1, sizeof(int), fp);
                        } else {
                            printf("MapTileset: %d\n", mapTileSet->id);
                            fwrite(&(mapTileSet->id), 1, sizeof(int), fp);
                        }


                    }
                }
            }


            /* salvando teleport areas */
            int nro_teleport_areas;
            nro_teleport_areas = map->teleportAreas->size();
            fwrite(&nro_teleport_areas, 1, sizeof(int), fp);

            for(std::vector<TeleportArea*>::iterator it = map->teleportAreas->begin(); it != map->teleportAreas->end(); ++it) {
                TeleportArea* teleportArea = *it;

                fwrite(&teleportArea->id, 1, sizeof(int), fp);
                fwrite(&teleportArea->mapId, 1, sizeof(int), fp);
                fwrite(&teleportArea->mapPositionDetermined, 1, sizeof(bool), fp);
                fwrite(&teleportArea->mapPosX, 1, sizeof(int), fp);
                fwrite(&teleportArea->mapPosY, 1, sizeof(int), fp);
                fwrite(&teleportArea->x, 1, sizeof(int), fp);
                fwrite(&teleportArea->y, 1, sizeof(int), fp);
                fwrite(&teleportArea->w, 1, sizeof(int), fp);
                fwrite(&teleportArea->h, 1, sizeof(int), fp);
                fwrite(&teleportArea->showVictoryAnimation, 1, sizeof(bool), fp);

            }

            /* salvando o fundo */
            if(map->background != NULL) {
                fwrite(&map->background->id, 1, sizeof(int), fp);
            } else {
                int null_int = -1;
                fwrite(&null_int, 1, sizeof(int), fp);
            }




        }




    }
}

std::vector<Map*>* GameData::loadMapList(FILE *fp) {
    std::vector<Map*>* mapList;
    mapList = new std::vector<Map*>();

    int tamanhoMapList, i;

    fread((&tamanhoMapList), 1, sizeof(int), fp);

    for(i = 0; i < tamanhoMapList; i ++) {
        Map* map = new Map();
        int j, k, l;

        int isFolder;

        fread(&isFolder, 1, sizeof(int), fp);

        if(isFolder) {
            map->mapName = std::string(loadString(fp));

            map->filhos = loadMapList(fp);
        } else {

            fread(&(map->key), 1, sizeof(int), fp);
            map->mapName = std::string(loadString(fp));

            fread(&(map->width), 1, sizeof(int), fp);
            fread(&(map->height), 1, sizeof(int), fp);
            fread(&(map->layers), 1, sizeof(int), fp);

            int tileSetListSize;

            fread(&tileSetListSize, 1, sizeof(int), fp);

            map->tileSets = new std::vector<TileSet*>();

            for(j = 0; j < tileSetListSize; j++) {
               int id;

               fread(&id, 1, sizeof(int), fp);

               TileSet* tileSetItem = searchTilesetById(id);

               if(tileSetItem != NULL) {
                   map->tileSets->push_back(tileSetItem);
               } else {
                   printf("Erro na população dos tilesets de um mapa");
                   exit(1);
               }

             }

            /* ALTERACOES 22-FEV-2011 COMECAM AQUI */
            map->music = std::string(loadString(fp));
            map->sound = std::string(loadString(fp));

            fread(&map->loopMusic, 1, sizeof(int), fp);
            fread(&map->loopSound, 1, sizeof(int), fp);
            fread(&map->idFundo, 1, sizeof(int), fp);

            /* gravando as instancias de objetos */

            int nro_instancias;
            fread(&nro_instancias, 1, sizeof(int), fp);

            map->gameObjectInstances->clear();

            for(j = 0; j < nro_instancias; j++) {
                GameObjectInstance *gameObjectInstance = new GameObjectInstance(NULL);
                int gameObjectId;

                fread(&gameObjectInstance->id, 1, sizeof(unsigned int), fp);
                fread(&gameObjectId, 1,  sizeof(int), fp);
                gameObjectInstance->gameObject = searchGameObjectById(gameObjectId);

                if(gameObjectInstance->gameObject == NULL) {
                    std::cout << "Problema com um GameObjectInstance. Abortando..." << std::endl;
                    exit(1);
                }
                fread(&gameObjectInstance->x, 1,  sizeof(int), fp);
                fread(&gameObjectInstance->y, 1,  sizeof(int), fp);

                fread(&gameObjectInstance->nroEventos, 1,  sizeof(int), fp);
                fread(&gameObjectInstance->nroFalas, 1, sizeof(int), fp);

                fread(&gameObjectInstance->isCenter, 1, sizeof(bool), fp);
                fread(&gameObjectInstance->isMainObject, 1, sizeof(bool), fp);

                map->gameObjectInstances->push_back(gameObjectInstance);

            }


            /* ALTERACOES 22-FEV-2011 TERMINAM AQUI */

             map->map.resize(boost::extents[map->width][map->height][map->layers]);

             for(j = 0; j < map->width; j++) {
                 for(k = 0; k < map->height; k++) {
                     for(l = 0; l < map->layers; l++) {
                         fread(&(map->map[j][k][l].x), 1, sizeof(int), fp);
                         fread(&(map->map[j][k][l].y), 1, sizeof(int), fp);



                         int id;

                         fread(&id, 1, sizeof(int), fp);

                         if(id == -1) {
                            map->map[j][k][l].z = NULL;
                         } else {
                             TileSet* tileSetItem = searchTilesetById(id);

                             if(tileSetItem != NULL) {
                                 map->map[j][k][l].z = tileSetItem;
                             } else {
                                 printf("Erro na obtenção de um tileset de um tile %d\n", id);
                                 exit(1);
                             }
                         }


                     }
                 }
             }

            map->filhos = NULL;
        }

        /* lendo teleport areas */
        int nro_teleport_areas;
        nro_teleport_areas = map->teleportAreas->size();
        fread(&nro_teleport_areas, 1, sizeof(int), fp);

        map->teleportAreas = new std::vector<TeleportArea*>(nro_teleport_areas);

        for(j = 0; j < nro_teleport_areas; j++) {
            TeleportArea* teleportArea = new TeleportArea();

            fread(&teleportArea->id, 1, sizeof(int), fp);
            fread(&teleportArea->mapId, 1, sizeof(int), fp);
            fread(&teleportArea->mapPositionDetermined, 1, sizeof(bool), fp);
            fread(&teleportArea->mapPosX, 1, sizeof(int), fp);
            fread(&teleportArea->mapPosY, 1, sizeof(int), fp);
            fread(&teleportArea->x, 1, sizeof(int), fp);
            fread(&teleportArea->y, 1, sizeof(int), fp);
            fread(&teleportArea->w, 1, sizeof(int), fp);
            fread(&teleportArea->h, 1, sizeof(int), fp);
            fread(&teleportArea->showVictoryAnimation, 1, sizeof(bool), fp);

            map->teleportAreas->at(j) = teleportArea;

        }

        /* carregando o fundo */
        int idBg;
        fread(&idBg, 1, sizeof(int), fp);

        if(idBg != -1) {
            map->background = searchBackgroundById(idBg);
            if(map->background == NULL) {
                printf("Erro na obtenção de um background de id %d\n", idBg);
                exit(1);
            }
        } else {
            map->background = NULL;
        }








         mapList->push_back(map);
    }

    return mapList;
}

TileSet* GameData::searchTilesetById(int id) {
    for(std::vector<TileSet*>::iterator it = tileSetList->begin(); it != tileSetList->end(); ++it) {
        TileSet *tileset = *it;

        if(tileset->id == id) {
            return tileset;
        }
    }

    return NULL;
}

GameObject* GameData::searchGameObjectById(int id) {
    for(std::vector<GameObject*>::iterator it = objectList->begin(); it != objectList->end(); ++it) {
        GameObject *gameObject = *it;

        if(gameObject->id == id) {
            return gameObject;
        }
    }

    return NULL;
}

AnimationData* GameData::searchAnimationDataById(int id) {
    for(std::vector<AnimationData*>::iterator it = animationDataList->begin(); it != animationDataList->end(); ++it) {
        AnimationData *animationData = *it;

        if(animationData->id == id) {
            return animationData;
        }
    }

    return NULL;
}

Background* GameData::searchBackgroundById(int id) {
    for(std::vector<Background*>::iterator it = backgroundList->begin(); it != backgroundList->end(); ++it) {
        Background *bg = *it;

        if(bg->id == id) {
            return bg;
        }
    }

    return NULL;
}

Skill* GameData::searchSkillById(int id) {
    for(std::vector<Skill*>::iterator it = skillList->begin(); it != skillList->end(); ++it) {
        Skill *skill = *it;

        if(skill->id == id) {
            return skill;
        }
    }

    return NULL;
}

ProcedureData* GameData::getProcedureById(int id) {
    for(std::vector<ProcedureData*>::iterator it = procedureList->begin(); it != procedureList->end(); ++it) {
        ProcedureData *procedureData = *it;

        if(procedureData->id == id) {
            return procedureData;
        }
    }

    return NULL;
}

VariableData* GameData::getVariableById(int id) {
    for(std::vector<VariableData*>::iterator it = variableList->begin(); it != variableList->end(); ++it) {
        VariableData *variableData = *it;

        if(variableData->id == id) {
            return variableData;
        }
    }

    return NULL;
}

void GameData::addTileset(TileSet *tileSet) {
    tileSet->id = generateNewTilesetId();

    tileSetList->push_back(tileSet);
}

void GameData::addAnimation(AnimationData *animationData) {
    animationData->id = generateNewAnimationId();

    animationDataList->push_back(animationData);
}

void GameData::addGameObject(GameObject *gameObject) {
    gameObject->id = generateNewGameObjectId();

    objectList->push_back(gameObject);
}

void GameData::addBackground(Background *background) {
    background->id = generateNewBackgroundId();

    backgroundList->push_back(background);
}

void GameData::addProcedure(ProcedureData *procedureData) {
    procedureData->id = generateNewProcedureId();

    std::stringstream ss;
    ss << "Procedimento " << procedureData->id;

    procedureData->name = ss.str();

    procedureList->push_back(procedureData);
}

void GameData::addVariable(VariableData *variableData) {
    variableData->id = generateNewVariableId();

    variableList->push_back(variableData);
}

int GameData::generateNewTilesetId() {
    int id = 0;
    int itemId;
    TileSet* tileSetItem;

    if(!tileSetList->empty()) {
        for(std::vector<TileSet*>::iterator it = tileSetList->begin(); it != tileSetList->end(); ++it) {
            tileSetItem = *it;
            itemId = tileSetItem->id;
            if(itemId > id) id = itemId;
        }
    }


    return (id + 1);
}

int GameData::generateNewAnimationId() {
    int id = 0;
    int itemId;

    if(!animationDataList->empty()) {
        for(std::vector<AnimationData*>::iterator it = animationDataList->begin(); it != animationDataList->end(); ++it) {
            AnimationData *animationData = *it;
            itemId = animationData->id;
            if(itemId > id) id = itemId;
        }
    }

    return (id + 1);
}

int GameData::generateNewGameObjectId() {
    int id = 0;
    int itemId;
    GameObject* gameObjectItem;

    if(!objectList->empty()) {
        for(std::vector<GameObject*>::iterator it = objectList->begin(); it != objectList->end(); ++it) {
            gameObjectItem = *it;
            itemId = gameObjectItem->id;
            if(itemId > id) id = itemId;
        }
    }

    return (id + 1);
}

int GameData::generateNewBackgroundId() {
    int id = 0;
    int bgId;
    Background *bgItem;

    if(!backgroundList->empty()) {
        for(std::vector<Background*>::iterator it = backgroundList->begin(); it != backgroundList->end(); ++it) {
            bgItem = *it;
            bgId = bgItem->id;
            if(bgId > id) id = bgId;
        }
    }

    return (id + 1);
}

int GameData::generateNewProcedureId() {
    int id = 0;
    int procedureId;
    ProcedureData *procedureItem;

    if(!procedureList->empty()) {
        for(std::vector<ProcedureData*>::iterator it = procedureList->begin(); it != procedureList->end(); ++it) {
            procedureItem = *it;
            procedureId = procedureItem->id;
            if(procedureId > id) id = procedureId;
        }
    }

    return (id + 1);
}

int GameData::generateNewVariableId() {
    int id = 0;
    int bgId;
    VariableData *variableItem;

    if(!variableList->empty()) {
        for(std::vector<VariableData*>::iterator it = variableList->begin(); it != variableList->end(); ++it) {
            variableItem = *it;
            bgId = variableItem->id;
            if(bgId > id) id = bgId;
        }
    }

    return (id + 1);
}


int GameData::generateNewMapId() {
    int id;

    id = generateNewMapIdPercorreArvore(mapList, 0);

    return id;
}

int GameData::generateNewMapIdPercorreArvore(std::vector<Map*> *mapList, int id) {
    int itemId;
    Map* mapItem;
    itemId = 0;

    if(!mapList->empty()) {
        for(std::vector<Map*>::iterator it = mapList->begin(); it != mapList->end(); ++it) {
            mapItem = *it;
            if(mapItem->isFolder()) {
                id = generateNewMapIdPercorreArvore(mapItem->filhos, id);
            } else {
                itemId = mapItem->key;
                if(itemId > id) id = itemId;
            }

        }
    }

    return (id + 1);
}


void GameData::setTitleScreenFile(std::string fileName) {
    titleScreenData.backgroundFile = fileName;
}

void GameData::setOptionsScreenFile(std::string fileName) {
    optionsScreenFile = fileName;
}

void GameData::setGameOverScreenFile(std::string fileName) {
    gameoverScreenFile = fileName;
}

bool GameData::saveObjectList(FILE *fp) {
    std::vector<GameObject*> *list;
    list = objectList;

    int nro_objetos = objectList->size();
    fwrite(&nro_objetos, 1, sizeof(int), fp);

    for(std::vector<GameObject*>::iterator it = list->begin(); it != list->end(); ++it) {
        GameObject* gameObject = *it;

        fwrite(&gameObject->id, 1, sizeof(int), fp);
        saveString(&gameObject->name, fp);
        fwrite(&gameObject->type, 1, sizeof(int), fp);

        fwrite(&gameObject->isObjetoUnico, 1, sizeof(bool), fp);
        fwrite(&gameObject->formaGrafica, 1, sizeof(int), fp);
        fwrite(&gameObject->tipoMovimento, 1, sizeof(int), fp);

        fwrite(&gameObject->formaMovimentoMouse, 1, sizeof(int), fp);
        fwrite(&gameObject->vx, 1, sizeof(int), fp);
        fwrite(&gameObject->vy, 1, sizeof(int), fp);
        fwrite(&gameObject->ax, 1, sizeof(int), fp);
        fwrite(&gameObject->ay, 1, sizeof(int), fp);
        fwrite(&gameObject->dax, 1, sizeof(int), fp);
        fwrite(&gameObject->day, 1, sizeof(int), fp);
        fwrite(&gameObject->gravidade, 1, sizeof(int), fp);
        fwrite(&gameObject->intensidadePulo, 1, sizeof(int), fp);
        fwrite(&gameObject->evolucaoPorNivel, 1, sizeof(int), fp);

        /* inicio das adicoes - 12 de março - PENDENTES NO RUNTIME */

        fwrite(&gameObject->hp, 1, sizeof(int), fp);
        fwrite(&gameObject->mp, 1, sizeof(int), fp);
        fwrite(&gameObject->atk, 1, sizeof(int), fp);
        fwrite(&gameObject->def, 1, sizeof(int), fp);
        fwrite(&gameObject->intelig, 1, sizeof(int), fp);
        fwrite(&gameObject->levelInicial, 1, sizeof(int), fp);
        fwrite(&gameObject->levelMax, 1, sizeof(int), fp);
        fwrite(&gameObject->velocidadeEvolucao, 1, sizeof(int), fp);
        fwrite(&gameObject->resolveCollision, 1, sizeof(int), fp);

        if(gameObject->type == GameObject::INIMIGO || gameObject->type == GameObject::NPC ||
           gameObject->type == GameObject::ITEM) {
            fwrite(&gameObject->formaMovimentacaoNpcItem, 1, sizeof(int), fp);
            fwrite(&gameObject->movimentaApenasDentroTela, 1, sizeof(bool), fp);
            fwrite(&gameObject->raioMovimentacao, 1, sizeof(int), fp);

            if(gameObject->type == GameObject::INIMIGO) {

                fwrite(&gameObject->derrotaEncostandoInimigo, 1, sizeof(bool), fp);
                fwrite(&gameObject->derrotaAtirandoItemMagiaInimigo, 1, sizeof(bool), fp);
                fwrite(&gameObject->derrotaAcertandoEspadaSobreInimigo, 1, sizeof(bool), fp);
                fwrite(&gameObject->derrotaPulandoSobreInimigo, 1, sizeof(bool), fp);
                fwrite(&gameObject->atacaEncostaPersonagem, 1, sizeof(bool), fp);
                fwrite(&gameObject->atacaEncostaPersonagemDano, 1, sizeof(int), fp);
                fwrite(&gameObject->atacaUsandoEspada, 1, sizeof(bool), fp);
                fwrite(&gameObject->espadaItemId, 1, sizeof(int), fp);
                fwrite(&gameObject->atacaUsandoEspadaDano, 1, sizeof(int), fp);

                fwrite(&gameObject->atiraItemMaginaDirecaoEstiver, 1, sizeof(bool), fp);
                fwrite(&gameObject->atiraItemMaginaDirecaoEstiverIdItem, 1, sizeof(int), fp);
                fwrite(&gameObject->atiraItemMaginaDirecaoEstiverDano, 1, sizeof(int), fp);

                fwrite(&gameObject->atiraItemMagiaDirecaoPersonagem, 1, sizeof(bool), fp);
                fwrite(&gameObject->atiraItemMagiaDirecaoPersonagemIdItem, 1, sizeof(int), fp);
                fwrite(&gameObject->atiraItemMagiaDirecaoPersonagemDano, 1, sizeof(int), fp);

                fwrite(&gameObject->tempoAtaque, 1, sizeof(float), fp);
                fwrite(&gameObject->magicCost, 1, sizeof(int), fp);

                fwrite(&gameObject->experiencePoints, 1, sizeof(int), fp);


            } else if(gameObject->type == GameObject::NPC) {
                fwrite(&gameObject->nroFalas, 1, sizeof(int), fp);
            } else if(gameObject->type == GameObject::ITEM) {
                fwrite(&gameObject->concedePontos, 1, sizeof(bool), fp);
                fwrite(&gameObject->concedePontosValor, 1, sizeof(int), fp);
                fwrite(&gameObject->ganhaPerdeVida, 1, sizeof(bool), fp);
                fwrite(&gameObject->ganhaPerdeVidaValor, 1, sizeof(int), fp);
                fwrite(&gameObject->ganhaPerdeMagia, 1, sizeof(bool), fp);
                fwrite(&gameObject->ganhaPerdeMagiaValor, 1, sizeof(int), fp);
                fwrite(&gameObject->incrementaVariavel, 1, sizeof(bool), fp);
                fwrite(&gameObject->incrementaVariavelIdVariavel, 1, sizeof(int), fp);
                fwrite(&gameObject->incrementaVariavelValor, 1, sizeof(int), fp);
                fwrite(&gameObject->ativaEvento, 1, sizeof(bool), fp);
                fwrite(&gameObject->ativaEventoIdEvento, 1, sizeof(int), fp);
                fwrite(&gameObject->concedeHabilidade, 1, sizeof(bool), fp);
                fwrite(&gameObject->concedeHabilidadeIdHabilidade, 1, sizeof(int), fp);

                fwrite(&gameObject->comportamentoEncostarPersonagem, 1, sizeof(int), fp);
                fwrite(&gameObject->desapareceEncostarPersonagem, 1, sizeof(bool), fp);
                fwrite(&gameObject->desapareceEncostarParede, 1, sizeof(bool), fp);
            }
        }


        fwrite(&gameObject->possuiEventos, 1, sizeof(bool), fp);


        /* fim das adicoes - 12 de março */

        int nro_gameobject_animations = gameObject->gameObjectAnimations->size();
        fwrite(&nro_gameobject_animations, 1, sizeof(int), fp);

        for(std::vector<GameObjectAnimation*>::iterator it2 = gameObject->gameObjectAnimations->begin();
        it2 != gameObject->gameObjectAnimations->end(); ++it2) {
            GameObjectAnimation *gameObjectAnimation = *it2;

            fwrite(&gameObjectAnimation->id, 1, sizeof(int), fp);
            fwrite(&gameObjectAnimation->type, 1, sizeof(int), fp);

            /* inicio das adicoes - 12 de março - PENDENTES NO RUNTIME */
            fwrite(&gameObjectAnimation->numDirectionFactor, 1, sizeof(int), fp);

            int nro_types = gameObjectAnimation->types->size();
            fwrite(&nro_types, 1, sizeof(int), fp);

            for(std::vector<int>::iterator it3 = gameObjectAnimation->types->begin();
            it3 != gameObjectAnimation->types->end(); ++it3) {
                int valor_type = *it3;
                fwrite(&valor_type, 1, sizeof(int), fp);
            }

            int nro_horizontal_inverts = gameObjectAnimation->horizontalInvert.size();
            fwrite(&nro_horizontal_inverts, 1, sizeof(int), fp);

            for(std::vector<bool>::iterator it3 = gameObjectAnimation->horizontalInvert.begin();
            it3 != gameObjectAnimation->horizontalInvert.end(); ++it3) {
                bool valor_horinv = *it3;
                fwrite(&valor_horinv, 1, sizeof(bool), fp);
            }

            int nro_vertical_inverts = gameObjectAnimation->verticalInvert.size();
            fwrite(&nro_vertical_inverts, 1, sizeof(int), fp);

            for(std::vector<bool>::iterator it3 = gameObjectAnimation->verticalInvert.begin();
            it3 != gameObjectAnimation->verticalInvert.end(); ++it3) {
                bool valor_verinv = *it3;
                fwrite(&valor_verinv, 1, sizeof(bool), fp);
            }

            int nro_adjustments = gameObjectAnimation->adjustments.size();
            fwrite(&nro_adjustments, 1, sizeof(int), fp);

            for(std::vector<Point>::iterator it3 = gameObjectAnimation->adjustments.begin();
            it3 != gameObjectAnimation->adjustments.end(); ++it3) {
                Point point = *it3;
                fwrite(&point.x, 1, sizeof(int), fp);
                fwrite(&point.y, 1, sizeof(int), fp);
            }

            /* fim das adicoes - 12 de março */

            saveString(&gameObjectAnimation->name, fp);

            int nro_sprites = gameObjectAnimation->sprites->size();
            fwrite(&nro_sprites, 1, sizeof(int), fp);

            for(std::vector<Sprite*>::iterator it3 = gameObjectAnimation->sprites->begin();
            it3 != gameObjectAnimation->sprites->end(); ++it3) {
                Sprite *sprite = *it3;

                fwrite(&sprite->id, 1, sizeof(int), fp);
                fwrite(&sprite->direction, 1, sizeof(int), fp);

                /* inicio das adicoes - 12 de março - PENDENTES NO RUNTIME */
                fwrite(&sprite->activated, 1, sizeof(bool), fp);
                fwrite(&sprite->hascolorkey, 1, sizeof(bool), fp);
                fwrite(&sprite->r_colorkey, 1, sizeof(int), fp);
                fwrite(&sprite->g_colorkey, 1, sizeof(int), fp);
                fwrite(&sprite->b_colorkey, 1, sizeof(int), fp);



                /* fim das adicoes - 12 de março */
                saveString(&sprite->spriteFileName, fp);
            }

            /* inicio das adicoes - 12 de março - PENDENTES NO RUNTIME */
            int nro_animations = gameObjectAnimation->animations->size();
            fwrite(&nro_animations, 1, sizeof(int), fp);


            for(std::vector<AnimationData*>::iterator it3 = gameObjectAnimation->animations->begin();
                it3 != gameObjectAnimation->animations->end(); ++it3) {
                AnimationData* animationData = *it3;

                if(animationData == NULL) {
                    int nullInt = -1;
                    fwrite(&nullInt, 1, sizeof(int), fp);
                } else {
                    fwrite(&animationData->id, 1, sizeof(int), fp);
                }


            }
            /* fim das adicoes - 12 de março */

            // TODO: fazer loop escrita de animations quando estiverem prontas


        }




    }

    return true;
}

bool GameData::loadObjectList(FILE *fp) {
    objectList->clear();

    int nro_objetos;
    fread(&nro_objetos, 1, sizeof(int), fp);
    for(int i = 0; i < nro_objetos; i++) {
        GameObject *gameObject = new GameObject();

        fread(&gameObject->id, 1, sizeof(int), fp);
        gameObject->name = std::string(loadString(fp));
        fread(&gameObject->type, 1, sizeof(int), fp);

        fread(&gameObject->isObjetoUnico, 1, sizeof(bool), fp);
        fread(&gameObject->formaGrafica, 1, sizeof(int), fp);
        fread(&gameObject->tipoMovimento, 1, sizeof(int), fp);

        fread(&gameObject->formaMovimentoMouse, 1, sizeof(int), fp);
        fread(&gameObject->vx, 1, sizeof(int), fp);
        fread(&gameObject->vy, 1, sizeof(int), fp);
        fread(&gameObject->ax, 1, sizeof(int), fp);
        fread(&gameObject->ay, 1, sizeof(int), fp);
        fread(&gameObject->dax, 1, sizeof(int), fp);
        fread(&gameObject->day, 1, sizeof(int), fp);
        fread(&gameObject->gravidade, 1, sizeof(int), fp);
        fread(&gameObject->intensidadePulo, 1, sizeof(int), fp);
        fread(&gameObject->evolucaoPorNivel, 1, sizeof(int), fp);

        /* inicio das adicoes - 12 de março - PENDENTES NO RUNTIME - OK */

        fread(&gameObject->hp, 1, sizeof(int), fp);
        fread(&gameObject->mp, 1, sizeof(int), fp);
        fread(&gameObject->atk, 1, sizeof(int), fp);
        fread(&gameObject->def, 1, sizeof(int), fp);
        fread(&gameObject->intelig, 1, sizeof(int), fp);
        fread(&gameObject->levelInicial, 1, sizeof(int), fp);
        fread(&gameObject->levelMax, 1, sizeof(int), fp);
        fread(&gameObject->velocidadeEvolucao, 1, sizeof(int), fp);
        fread(&gameObject->resolveCollision, 1, sizeof(int), fp);

        if(gameObject->type == GameObject::INIMIGO || gameObject->type == GameObject::NPC ||
           gameObject->type == GameObject::ITEM) {
            fread(&gameObject->formaMovimentacaoNpcItem, 1, sizeof(int), fp);
            fread(&gameObject->movimentaApenasDentroTela, 1, sizeof(bool), fp);
            fread(&gameObject->raioMovimentacao, 1, sizeof(int), fp);

            if(gameObject->type == GameObject::INIMIGO) {

                fread(&gameObject->derrotaEncostandoInimigo, 1, sizeof(bool), fp);
                fread(&gameObject->derrotaAtirandoItemMagiaInimigo, 1, sizeof(bool), fp);
                fread(&gameObject->derrotaAcertandoEspadaSobreInimigo, 1, sizeof(bool), fp);
                fread(&gameObject->derrotaPulandoSobreInimigo, 1, sizeof(bool), fp);
                fread(&gameObject->atacaEncostaPersonagem, 1, sizeof(bool), fp);
                fread(&gameObject->atacaEncostaPersonagemDano, 1, sizeof(int), fp);
                fread(&gameObject->atacaUsandoEspada, 1, sizeof(bool), fp);
                fread(&gameObject->espadaItemId, 1, sizeof(int), fp);
                fread(&gameObject->atacaUsandoEspadaDano, 1, sizeof(int), fp);

                fread(&gameObject->atiraItemMaginaDirecaoEstiver, 1, sizeof(bool), fp);
                fread(&gameObject->atiraItemMaginaDirecaoEstiverIdItem, 1, sizeof(int), fp);
                fread(&gameObject->atiraItemMaginaDirecaoEstiverDano, 1, sizeof(int), fp);

                fread(&gameObject->atiraItemMagiaDirecaoPersonagem, 1, sizeof(bool), fp);
                fread(&gameObject->atiraItemMagiaDirecaoPersonagemIdItem, 1, sizeof(int), fp);
                fread(&gameObject->atiraItemMagiaDirecaoPersonagemDano, 1, sizeof(int), fp);

                fread(&gameObject->tempoAtaque, 1, sizeof(float), fp);
                fread(&gameObject->magicCost, 1, sizeof(int), fp);

                fread(&gameObject->experiencePoints, 1, sizeof(int), fp);

            } else if(gameObject->type == GameObject::NPC) {
                fread(&gameObject->nroFalas, 1, sizeof(int), fp);
            } else if(gameObject->type == GameObject::ITEM) {
                fread(&gameObject->concedePontos, 1, sizeof(bool), fp);
                fread(&gameObject->concedePontosValor, 1, sizeof(int), fp);
                fread(&gameObject->ganhaPerdeVida, 1, sizeof(bool), fp);
                fread(&gameObject->ganhaPerdeVidaValor, 1, sizeof(int), fp);
                fread(&gameObject->ganhaPerdeMagia, 1, sizeof(bool), fp);
                fread(&gameObject->ganhaPerdeMagiaValor, 1, sizeof(int), fp);
                fread(&gameObject->incrementaVariavel, 1, sizeof(bool), fp);
                fread(&gameObject->incrementaVariavelIdVariavel, 1, sizeof(int), fp);
                fread(&gameObject->incrementaVariavelValor, 1, sizeof(int), fp);
                fread(&gameObject->ativaEvento, 1, sizeof(bool), fp);
                fread(&gameObject->ativaEventoIdEvento, 1, sizeof(int), fp);
                fread(&gameObject->concedeHabilidade, 1, sizeof(bool), fp);
                fread(&gameObject->concedeHabilidadeIdHabilidade, 1, sizeof(int), fp);

                fread(&gameObject->comportamentoEncostarPersonagem, 1, sizeof(int), fp);
                fread(&gameObject->desapareceEncostarPersonagem, 1, sizeof(bool), fp);
                fread(&gameObject->desapareceEncostarParede, 1, sizeof(bool), fp);
            }
        }





        fread(&gameObject->possuiEventos, 1, sizeof(bool), fp);


        /* fim das adicoes - 12 de março */

        int nro_gameobject_animations;
        fread(&nro_gameobject_animations, 1, sizeof(int), fp);

        gameObject->gameObjectAnimations->clear();

        for(int j = 0; j < nro_gameobject_animations; j++) {
            GameObjectAnimation *gameObjectAnimation = new GameObjectAnimation();

            fread(&gameObjectAnimation->id, 1, sizeof(int), fp);
            fread(&gameObjectAnimation->type, 1, sizeof(int), fp);

            /* inicio das adicoes - 12 de março - PENDENTES NO RUNTIME - OK */
            fread(&gameObjectAnimation->numDirectionFactor, 1, sizeof(int), fp);

            int nro_types;
            fread(&nro_types, 1, sizeof(int), fp);

            for(int k = 0; k < nro_types; k++) {
                int valor_type;
                fread(&valor_type, 1, sizeof(int), fp);

                gameObjectAnimation->types->at(k) = valor_type;
            }


            int nro_horizontal_inverts;
            fread(&nro_horizontal_inverts, 1, sizeof(int), fp);

            for(int k = 0; k < nro_horizontal_inverts; k++) {
                bool valor_horinv;
                fread(&valor_horinv, 1, sizeof(bool), fp);
                gameObjectAnimation->horizontalInvert.at(k) = valor_horinv;
            }

            int nro_vertical_inverts;
            fread(&nro_vertical_inverts, 1, sizeof(int), fp);

            for(int k = 0; k < nro_vertical_inverts; k++) {
                bool valor_verinv;
                fread(&valor_verinv, 1, sizeof(bool), fp);
                gameObjectAnimation->verticalInvert.at(k) = valor_verinv;
            }

            int nro_adjustments;
            fread(&nro_adjustments, 1, sizeof(int), fp);

            for(int k = 0; k < nro_adjustments; k++) {
                Point point;
                fread(&point.x, 1, sizeof(int), fp);
                fread(&point.y, 1, sizeof(int), fp);

                gameObjectAnimation->adjustments.at(k) = point;
            }




            /* fim das adicoes - 12 de março */

            gameObjectAnimation->name = std::string(loadString(fp));

            int nro_sprites;
            fread(&nro_sprites, 1, sizeof(int), fp);

            for(int k = 0; k < nro_sprites; k++) {
                Sprite *sprite = new Sprite();

                fread(&sprite->id, 1, sizeof(int), fp);
                fread(&sprite->direction, 1, sizeof(int), fp);

                /* inicio das adicoes - 12 de março - PENDENTES NO RUNTIME - OK */
                fread(&sprite->activated, 1, sizeof(bool), fp);
                fread(&sprite->hascolorkey, 1, sizeof(bool), fp);
                fread(&sprite->r_colorkey, 1, sizeof(int), fp);
                fread(&sprite->g_colorkey, 1, sizeof(int), fp);
                fread(&sprite->b_colorkey, 1, sizeof(int), fp);


                /* fim das adicoes - 12 de março */

                sprite->spriteFileName = std::string(loadString(fp));

                gameObjectAnimation->sprites->at(k) = sprite;
            }

            /* inicio das adicoes - 12 de março - PENDENTES NO RUNTIME - OK */
            int nro_animations;
            fread(&nro_animations, 1, sizeof(int), fp);


            for(int k = 0; k < nro_animations; k++) {
                int animationDataId;
                fread(&animationDataId, 1, sizeof(int), fp);

                if(animationDataId != -1) {
                    gameObjectAnimation->animations->at(k) = searchAnimationDataById(animationDataId);

                    if(gameObjectAnimation->animations->at(k) == NULL) {
                        std::cout << "Problema com leitura de um animationData de um object" << std::endl;
                    }
                }

            }



            /* fim das adicoes - 12 de março */

            // TODO: fazer loop leitura de animations quando estiverem prontas

            gameObject->gameObjectAnimations->push_back(gameObjectAnimation);
        }

        objectList->push_back(gameObject);
    }



    return true;
}

bool GameData::saveObjectSkills(FILE *fp) {
    for(std::vector<GameObject*>::iterator it = objectList->begin(); it != objectList->end(); ++it) {
        GameObject *gameObject = *it;

        int nroListaHabilidades = gameObject->listaHabilidades.size();

        fwrite(&nroListaHabilidades, 1, sizeof(int), fp);

        for(std::vector<SkillData*>::iterator it2 = gameObject->listaHabilidades.begin(); it2 != gameObject->listaHabilidades.end(); ++it2) {
            SkillData* skillData = *it2;

            fwrite(&skillData->id, 1, sizeof(int), fp);
            fwrite(&skillData->intensity, 1, sizeof(int), fp);
            fwrite(&skillData->magicCost, 1, sizeof(int), fp);
            fwrite(&skillData->level, 1, sizeof(int), fp);
            fwrite(&skillData->skill->id, 1, sizeof(int), fp);
            if(skillData->skillObject == NULL) {
                int null_int = -1;
                fwrite(&null_int, 1, sizeof(int), fp);
            } else {
                fwrite(&skillData->skillObject->id, 1, sizeof(int), fp);
            }

            if(skillData->skillProvider == NULL) {
                int null_int = -1;
                fwrite(&null_int, 1, sizeof(int), fp);
            } else {
                fwrite(&skillData->skillProvider->id, 1, sizeof(int), fp);
            }

        }




    }

    return true;
}

bool GameData::loadObjectSkills(FILE *fp) {
    for(std::vector<GameObject*>::iterator it = objectList->begin(); it != objectList->end(); ++it) {
        GameObject *gameObject = *it;

        int nroListaHabilidades;

        fread(&nroListaHabilidades, 1, sizeof(int), fp);

        for(int j = 0; j < nroListaHabilidades; j++) {
            SkillData* skillData = new SkillData();

            fread(&skillData->id, 1, sizeof(int), fp);
            fread(&skillData->intensity, 1, sizeof(int), fp);
            fread(&skillData->magicCost, 1, sizeof(int), fp);
            fread(&skillData->level, 1, sizeof(int), fp);

            int idSkill;
            fread(&idSkill, 1, sizeof(int), fp);
            skillData->skill = searchSkillById(idSkill);
            if(skillData->skill == NULL) {
                printf("Erro na obtenção de uma skill de id: %d\n", idSkill);
                exit(1);
            }


            int idSkillData;
            fread(&idSkillData, 1, sizeof(int), fp);
            int idSkillProvider;
            fread(&idSkillProvider, 1, sizeof(int), fp);

            if(idSkillData == -1) {
                skillData->skillObject = NULL;
            } else {
                skillData->skillObject = searchGameObjectById(idSkillData);
                if(skillData->skillObject == NULL) {
                    printf("Erro na obtenção de um objeto (skillObject) de id: %d\n", idSkillData);
                    exit(1);
                }
            }


            if(idSkillProvider == -1) {
                skillData->skillProvider = NULL;
            } else {
                skillData->skillProvider = searchGameObjectById(idSkillProvider);
                if(skillData->skillProvider == NULL) {
                    printf("Erro na obtenção de um objeto (skillProvider) de id: %d\n", idSkillProvider);
                    exit(1);
                }
            }

            gameObject->listaHabilidades.push_back(skillData);



        }
    }


}

bool GameData::saveAnimationDataList(FILE *fp) {
    int tamanhoLista;

    tamanhoLista = animationDataList->size();
    fwrite(&tamanhoLista, 1, sizeof(int), fp);

    for(std::vector<AnimationData*>::iterator it = animationDataList->begin(); it != animationDataList->end(); ++it) {
        AnimationData* animationData = *it;

        fwrite(&animationData->id, 1, sizeof(int), fp);

        saveString(&animationData->fileName, fp);
        saveString(&animationData->name, fp);

        fwrite(&animationData->colorkey_b, 1, sizeof(int), fp);
        fwrite(&animationData->colorkey_g, 1, sizeof(int), fp);
        fwrite(&animationData->colorkey_r, 1, sizeof(int), fp);

        fwrite(&animationData->frameLoop, 1, sizeof(int), fp);
        fwrite(&animationData->hasColorkey, 1, sizeof(bool), fp);
        fwrite(&animationData->hasLoop, 1, sizeof(bool), fp);
        int valor = animationData->getHorizontalFrameNumber();
        fwrite(&valor, 1, sizeof(int), fp);
        fwrite(&animationData->horizontalSpacing, 1, sizeof(int), fp);
        fwrite(&animationData->order, 1, sizeof(int), fp);
        fwrite(&animationData->velocity, 1, sizeof(int), fp);
        valor = animationData->getVerticalFrameNumber();
        fwrite(&valor, 1, sizeof(int), fp);
        fwrite(&animationData->verticalSpacing, 1, sizeof(int), fp);

        fwrite(&animationData->startX, 1, sizeof(int), fp);
        fwrite(&animationData->startY, 1, sizeof(int), fp);
        fwrite(&animationData->endX, 1, sizeof(int), fp);
        fwrite(&animationData->endY, 1, sizeof(int), fp);


    }

    return true;
}

bool GameData::loadAnimationDataList(FILE *fp) {
    int tamanhoLista;

    fread(&tamanhoLista, 1, sizeof(int), fp);

    for(int i = 0; i < tamanhoLista; i++) {
        AnimationData *animationData = new AnimationData();

        fread(&animationData->id, 1, sizeof(int), fp);

        animationData->fileName = std::string(loadString(fp));
        animationData->name = std::string(loadString(fp));

        fread(&animationData->colorkey_b, 1, sizeof(int), fp);
        fread(&animationData->colorkey_g, 1, sizeof(int), fp);
        fread(&animationData->colorkey_r, 1, sizeof(int), fp);

        fread(&animationData->frameLoop, 1, sizeof(int), fp);
        fread(&animationData->hasColorkey, 1, sizeof(bool), fp);
        fread(&animationData->hasLoop, 1, sizeof(bool), fp);
        int valor_horizontal_frame_number;
        fread(&valor_horizontal_frame_number, 1, sizeof(int), fp);
        animationData->setHorizontalFrameNumber(valor_horizontal_frame_number);
        fread(&animationData->horizontalSpacing, 1, sizeof(int), fp);
        fread(&animationData->order, 1, sizeof(int), fp);
        fread(&animationData->velocity, 1, sizeof(int), fp);
        int valor_vertical_frame_number;
        fread(&valor_vertical_frame_number, 1, sizeof(int), fp);
        animationData->setVerticalFrameNumber(valor_vertical_frame_number);
        fread(&animationData->verticalSpacing, 1, sizeof(int), fp);

        fread(&animationData->startX, 1, sizeof(int), fp);
        fread(&animationData->startY, 1, sizeof(int), fp);
        fread(&animationData->endX, 1, sizeof(int), fp);
        fread(&animationData->endY, 1, sizeof(int), fp);

        animationDataList->push_back(animationData);


    }

    return true;
}


bool GameData::saveBackgroundList(FILE *fp) {
    int tamanhoLista = backgroundList->size();

    fwrite(&tamanhoLista, 1, sizeof(int), fp);

    for(std::vector<Background*>::iterator it = backgroundList->begin(); it != backgroundList->end(); ++it) {
        Background *bg = *it;

        fwrite(&bg->id, 1, sizeof(int), fp);
        saveString(&bg->name, fp);

        int tamanho_layer_list = bg->layerList->size();
        fwrite(&tamanho_layer_list, 1, sizeof(int), fp);

        for(std::vector<BgLayer*>::iterator it2 = bg->layerList->begin(); it2 != bg->layerList->end(); ++it2) {
            BgLayer *bgLayer = *it2;

            saveString(&bgLayer->fileName, fp);

            fwrite(&bgLayer->behavior, 1, sizeof(int), fp);
            fwrite(&bgLayer->displacementX, 1, sizeof(int), fp);
            fwrite(&bgLayer->displacementY, 1, sizeof(int), fp);
            fwrite(&bgLayer->repeatsHorizontally, 1, sizeof(int), fp);
            fwrite(&bgLayer->repeatsVertically, 1, sizeof(int), fp);
            fwrite(&bgLayer->vx, 1, sizeof(int), fp);
            fwrite(&bgLayer->vy, 1, sizeof(int), fp);
        }
    }

    return true;
}

bool GameData::loadBackgroundList(FILE *fp) {
    int tamanhoLista;

    fread(&tamanhoLista, 1, sizeof(int), fp);

    for(int i = 0; i < tamanhoLista; i++) {
        Background *bg = new Background();

        fread(&bg->id, 1, sizeof(int), fp);
        bg->name = std::string(loadString(fp));

        int tamanho_layer_list;
        fread(&tamanho_layer_list, 1, sizeof(int), fp);

        for(int j = 0; j < tamanho_layer_list; j++) {
            BgLayer *bgLayer = new BgLayer();

            bgLayer->fileName = std::string(loadString(fp));

            fread(&bgLayer->behavior, 1, sizeof(int), fp);
            fread(&bgLayer->displacementX, 1, sizeof(int), fp);
            fread(&bgLayer->displacementY, 1, sizeof(int), fp);
            fread(&bgLayer->repeatsHorizontally, 1, sizeof(int), fp);
            fread(&bgLayer->repeatsVertically, 1, sizeof(int), fp);
            fread(&bgLayer->vx, 1, sizeof(int), fp);
            fread(&bgLayer->vy, 1, sizeof(int), fp);

            bg->layerList->push_back(bgLayer);
        }

        backgroundList->push_back(bg);


    }

    return true;
}

bool GameData::saveAllEvents(FILE *fp) {
    // salvando a lista de eventos global
    saveProcedure(procedureGlobalAlways, fp);
    saveProcedure(procedureGlobalStart, fp);
    saveProcedure(procedureGlobalEnd, fp);

    saveProcedureList(fp, procedureList);

    // percorrendo a lista de objetos e salvando seus eventos, em sequência

    for(std::vector<GameObject*>::iterator it = objectList->begin(); it != objectList->end(); ++it) {
        GameObject* gameObject = *it;

        saveProcedure(gameObject->procedureGlobalAlways, fp);
        saveProcedure(gameObject->procedureGlobalStart, fp);
        saveProcedure(gameObject->procedureGlobalEnd, fp);

        saveProcedureList(fp, gameObject->procedureList);
    }



    return true;
}

bool GameData::loadAllEvents(FILE *fp) {
    procedureGlobalAlways = loadProcedure(fp);
    procedureGlobalStart = loadProcedure(fp);
    procedureGlobalEnd = loadProcedure(fp);

    procedureList = loadProcedureList(fp);


    for(std::vector<GameObject*>::iterator it = objectList->begin(); it != objectList->end(); ++it) {
        GameObject* gameObject = *it;

        gameObject->procedureGlobalAlways = loadProcedure(fp);
        gameObject->procedureGlobalStart = loadProcedure(fp);
        gameObject->procedureGlobalEnd = loadProcedure(fp);

        gameObject->procedureList = loadProcedureList(fp);
    }

    return true;
}

bool GameData::saveVariable(VariableData *variable, FILE *fp) {
    fwrite(&variable->id, 1, sizeof(int), fp);
    saveString(&variable->name, fp  );
    fwrite(&variable->type, 1, sizeof(int), fp);
    fwrite(&variable->value, 1, sizeof(float), fp);
}

VariableData* GameData::loadVariable(FILE *fp) {
    VariableData *variable = new VariableData();

    fread(&variable->id, 1, sizeof(int), fp);
    variable->name = std::string(loadString(fp));
    fread(&variable->type, 1, sizeof(int), fp);
    fread(&variable->value, 1, sizeof(float), fp);

    return variable;
}

bool GameData::saveAllVariableLists(FILE *fp) {

    // gravando as variáveis globais
    int count_n_variables = variableList->size();
    fwrite(&count_n_variables, 1, sizeof(int), fp);

    for(std::vector<VariableData*>::iterator it = variableList->begin(); it != variableList->end(); ++it) {
        VariableData *variableData = *it;

        saveVariable(variableData, fp);
    }

    // gravando as variáveis dos objetos
    for(std::vector<GameObject*>::iterator it1 = objectList->begin(); it1 != objectList->end(); ++it1) {
        GameObject *gameObject = *it1;

        count_n_variables = gameObject->variableList->size();
        fwrite(&count_n_variables, 1, sizeof(int), fp);

        for(std::vector<VariableData*>::iterator it2 = gameObject->variableList->begin(); it2 != gameObject->variableList->end(); ++it2) {
            VariableData* variableData = *it2;

            saveVariable(variableData, fp);
        }
    }

    return true;
}

bool GameData::loadAllVariableLists(FILE *fp) {

    // lendo as variáveis globais
    int count_n_variables;
    fread(&count_n_variables, 1, sizeof(int), fp);


    for(int i = 0; i < count_n_variables; i++) {
        variableList->push_back(loadVariable(fp));
    }

    // lendos as variáveis dos objetos
    for(std::vector<GameObject*>::iterator it1 = objectList->begin(); it1 != objectList->end(); ++it1) {
        GameObject *gameObject = *it1;

        fread(&count_n_variables, 1, sizeof(int), fp);

        for(int i = 0; i < count_n_variables; i++) {
            gameObject->variableList->push_back(loadVariable(fp));
        }

    }
    return true;
}


bool GameData::saveProcedureList(FILE *fp, std::vector<ProcedureData *> *procedureList) {
    int sizeProcedureList;
    sizeProcedureList = procedureList->size();

    fwrite(&sizeProcedureList, 1, sizeof(int), fp);

    for(std::vector<ProcedureData*>::iterator it = procedureList->begin(); it != procedureList->end(); ++it) {
        ProcedureData *procedureData = *it;

        saveProcedure(procedureData, fp);
    }


}

std::vector<ProcedureData*>* GameData::loadProcedureList(FILE *fp) {
    int sizeProcedureList;
    std::vector<ProcedureData*>* procedureList = new std::vector<ProcedureData*>();

    fread(&sizeProcedureList, 1, sizeof(int), fp);

    for(int i = 0; i < sizeProcedureList; i++) {
        procedureList->push_back(loadProcedure(fp));
    }


    return procedureList;
}

bool GameData::saveProcedure(ProcedureData *procedureData, FILE *fp) {
    fwrite(&procedureData->id, 1, sizeof(int), fp);
    saveString(&procedureData->name, fp);
    fwrite(&procedureData->nameEditable, 1, sizeof(int), fp);

    saveEventList(fp, &procedureData->events);

}

ProcedureData* GameData::loadProcedure(FILE *fp) {
    ProcedureData *procedureData = new ProcedureData();

    fread(&procedureData->id, 1, sizeof(int), fp);
    procedureData->name = std::string(loadString(fp));
    fread(&procedureData->nameEditable, 1, sizeof(int), fp);

    procedureData->events = loadEventList(fp);

    return procedureData;
}



bool GameData::saveEventList(FILE *fp, std::list<EventData *> *eventFunctionList) {
    int eventListSize;

    if(eventFunctionList == NULL) {
        eventListSize = 0;
        fwrite(&eventListSize, 0, sizeof(int), fp);
    } else {
        eventListSize = eventFunctionList->size();

        fwrite(&eventListSize, 1, sizeof(int), fp);

        for(std::list<EventData*>::iterator it = eventFunctionList->begin(); it != eventFunctionList->end(); ++it) {
            EventData *eventData = *it;


            fwrite(&eventData->newEvent, 1, sizeof(int), fp);
            if(!eventData->newEvent) {
                fwrite(&eventData->type, 1, sizeof(int), fp);
                fwrite(&eventData->conditionType, 1, sizeof(int), fp);

                fwrite(&eventData->opcode, 1, sizeof(int), fp);
                fwrite(&eventData->idAssociatedVariable, 1, sizeof(int), fp);
                fwrite(&eventData->idObject01, 1, sizeof(int), fp);
                fwrite(&eventData->instanceTypeObject01, 1, sizeof(int), fp);
                fwrite(&eventData->idObject02, 1, sizeof(int), fp);
                fwrite(&eventData->instanceTypeObject02, 1, sizeof(int), fp);
                fwrite(&eventData->valueType, 1, sizeof(int), fp);
                fwrite(&eventData->value01, 1, sizeof(int), fp);
                saveString(&eventData->stringValue, fp);

                saveEventList(fp, &eventData->subEvents);

            }





        }
    }



    return true;
}

std::list<EventData*> GameData::loadEventList(FILE *fp, EventData *parent) {
    int eventListSize;
    std::list<EventData*> eventListFunction;

    fread(&eventListSize, 1, sizeof(int), fp);

    for(int i = 0; i < eventListSize; i++) {
        EventData *eventData = new EventData();

        fread(&eventData->newEvent, 1, sizeof(int), fp);
        if(!eventData->newEvent) {
            fread(&eventData->type, 1, sizeof(int), fp);
            fread(&eventData->conditionType, 1, sizeof(int), fp);

            fread(&eventData->opcode, 1, sizeof(int), fp);
            fread(&eventData->idAssociatedVariable, 1, sizeof(int), fp);
            fread(&eventData->idObject01, 1, sizeof(int), fp);
            fread(&eventData->instanceTypeObject01, 1, sizeof(int), fp);
            fread(&eventData->idObject02, 1, sizeof(int), fp);
            fread(&eventData->instanceTypeObject02, 1, sizeof(int), fp);
            fread(&eventData->valueType, 1, sizeof(int), fp);
            fread(&eventData->value01, 1, sizeof(int), fp);
            eventData->stringValue = std::string(loadString(fp));



            eventData->subEvents = loadEventList(fp, eventData);

        }

        eventData->parent = parent;

        eventListFunction.push_back(eventData);
    }

    return eventListFunction;
}
#include "gameobjectanimation.h"

GameObjectAnimation::GameObjectAnimation() :
        horizontalInvert(std::vector<bool>(36)),
        verticalInvert(std::vector<bool>(36)),
        adjustments(std::vector<Point>(36))
{
    sprites = new std::vector<Sprite*>(36);
    animations = new std::vector<AnimationData*>(36);
    types = new std::vector<int>(36);

    for(int i = 0; i < 36; i++) {
        sprites->at(i) = new Sprite();
        animations->at(i) = NULL;
        types->at(i) = 0;
        horizontalInvert.at(i) = false;
        verticalInvert.at(i) = false;
        adjustments.at(i) = Point();
    }
}
#include "gameobject.h"

GameObject::GameObject()
{
    GameData *gameData = GameData::getInstance();

    formaGrafica = 0;
    tipoMovimento = 0;
    evolucaoPorNivel = 0;

    /* inicializando forma sprite default */
    gameObjectAnimations = new std::vector<GameObjectAnimation*>();

    /* inicializando a lista de procedures */
    procedureList = new std::vector<ProcedureData*>();

    /* inicializando a lista de variáveis */
    variableList = new std::vector<VariableData*>();

    GameObjectAnimation *gameObjectAnimation = new GameObjectAnimation();
    gameObjectAnimation->id = 0;
    gameObjectAnimation->name = std::string("Parado");
    gameObjectAnimation->type = GameObjectAnimation::STATIC;



    Sprite *sprite = new Sprite();
    sprite->spriteFileName = std::string("default_object_sprite.png");
    sprite->direction = 0;
    sprite->id = 0;


    gameObjectAnimation->sprites->at(0) = sprite;
    gameObjectAnimation->types->at(0) = 1;
    gameObjectAnimations->push_back(gameObjectAnimation);

    gameObjectAnimation = new GameObjectAnimation();
    gameObjectAnimation->id = 1;
    gameObjectAnimation->name = std::string("Andando");
    gameObjectAnimation->type = GameObjectAnimation::STATIC;
    gameObjectAnimations->push_back(gameObjectAnimation);

    gameObjectAnimation = new GameObjectAnimation();
    gameObjectAnimation->id = 2;
    gameObjectAnimation->name = std::string("Correndo");
    gameObjectAnimation->type = GameObjectAnimation::STATIC;
    gameObjectAnimations->push_back(gameObjectAnimation);


    gameObjectAnimation = new GameObjectAnimation();
    gameObjectAnimation->id = 3;
    gameObjectAnimation->name = std::string("Pulando");
    gameObjectAnimation->type = GameObjectAnimation::STATIC;
    gameObjectAnimations->push_back(gameObjectAnimation);

    gameObjectAnimation = new GameObjectAnimation();
    gameObjectAnimation->id = 4;
    gameObjectAnimation->name = std::string("Caindo");
    gameObjectAnimation->type = GameObjectAnimation::STATIC;
    gameObjectAnimations->push_back(gameObjectAnimation);

    gameObjectAnimation = new GameObjectAnimation();
    gameObjectAnimation->id = 5;
    gameObjectAnimation->name = std::string("Atacando");
    gameObjectAnimation->type = GameObjectAnimation::STATIC;
    gameObjectAnimations->push_back(gameObjectAnimation);

    gameObjectAnimation = new GameObjectAnimation();
    gameObjectAnimation->id = 6;
    gameObjectAnimation->name = std::string("Levando dano");
    gameObjectAnimation->type = GameObjectAnimation::STATIC;
    gameObjectAnimations->push_back(gameObjectAnimation);

    gameObjectAnimation = new GameObjectAnimation();
    gameObjectAnimation->id = 7;
    gameObjectAnimation->name = std::string("Morrendo");
    gameObjectAnimation->type = GameObjectAnimation::STATIC;
    gameObjectAnimations->push_back(gameObjectAnimation);


    this->gravidade = 10;
    this->vx = 15;
    this->vy = 15;
    this->ax = 10;
    this->ay = 10;
    this->dax = 10;
    this->day = 10;
    this->intensidadePulo = 20;

    this->tipoMovimento = 1;


    hp = 5;
    mp = 5;
    atk= 1;
    def = 0;
    intelig = 1;
    evolucaoPorNivel = false;
    levelInicial = 1;
    levelMax = 99;
    velocidadeEvolucao = 50;
    resolveCollision = true;

    formaMovimentacaoNpcItem = 0;
    raioMovimentacao = 80;

    concedePontos = false;
    concedePontosValor = 0;
    ganhaPerdeVida = false;
    ganhaPerdeVidaValor = 0;
    ganhaPerdeMagia = false;
    ganhaPerdeMagiaValor = 0;
    incrementaVariavel = false;
    incrementaVariavelIdVariavel = 0;
    incrementaVariavelValor = 0;
    ativaEvento = false;
    ativaEventoIdEvento = 0;
    concedeHabilidade = false;
    concedeHabilidadeIdHabilidade = 0;

    comportamentoEncostarPersonagem = 0;
    desapareceEncostarPersonagem = false;
    desapareceEncostarParede = false;

    nroFalas = 0;

    movimentaApenasDentroTela = false;


    procedureGlobalAlways = new ProcedureData();
    procedureGlobalAlways->name = QString::fromUtf8("Sempre").toStdString();
    procedureGlobalAlways->nameEditable = false;
    procedureGlobalStart = new ProcedureData();
    procedureGlobalStart->name = QString::fromUtf8("Criação do objeto").toStdString();
    procedureGlobalStart->nameEditable = false;
    procedureGlobalEnd = new ProcedureData();
    procedureGlobalEnd->name = QString::fromUtf8("Destrução do objeto").toStdString();
    procedureGlobalEnd->nameEditable = false;

    experiencePoints = 0;



}

GameObject::GameObject(int specialId) {
    this->type = SPECIAL;
    this->id = specialId;
}

std::string GameObject::getIconString() {
    GameData *gameData = GameData::getInstance();
    return gameData->getProjectDirectory().append("/objects/").append(gameObjectAnimations->at(0)->sprites->at(0)->spriteFileName);
}

QImage GameObject::getIconImage() {
    GameData *gameData = GameData::getInstance();

    if(specialIconPath.empty()) {
        GameObjectAnimation* animationParado = gameObjectAnimations->at(0);
        Sprite *sprite = NULL;
        AnimationData *animationData = NULL;

        int valor = 0;
        int i = 0;
        for(std::vector<int>::iterator it = animationParado->types->begin(); it != animationParado->types->end(); it++) {
            valor = *it;

            if(valor == 1) {
                sprite = animationParado->sprites->at(i);
                break;
            } else if (valor == 2) {
                animationData = animationParado->animations->at(i);
                break;
            }

            i++;

        }

        std::string directory;
        QImage image;

        switch(valor) {
        case 1:

            directory = gameData->getProjectDirectory().append("/objects/").append(sprite->spriteFileName);
            image = QImage(QString(directory.c_str()));
            return image;


            break;
        case 2:
            return animationData->getIconImage();

            break;
        }
    } else {
        return QImage(QString(specialIconPath.c_str()));
    }




    return QImage();
}


int GameObject::generateNewProcedureId() {
    int id = 0;
    int procedureId;
    ProcedureData *procedureItem;

    if(!procedureList->empty()) {
        for(std::vector<ProcedureData*>::iterator it = procedureList->begin(); it != procedureList->end(); ++it) {
            procedureItem = *it;
            procedureId = procedureItem->id;
            if(procedureId > id) id = procedureId;
        }
    }

    return (id + 1);
}

void GameObject::addProcedure(ProcedureData *procedureData) {
    procedureData->id = generateNewProcedureId();

    std::stringstream ss;
    ss << "Procedimento " << procedureData->id;

    procedureData->name = ss.str();

    procedureList->push_back(procedureData);
}

void GameObject::addVariable(VariableData *variableData) {
    variableData->id = generateNewVariableId();

    variableList->push_back(variableData);
}

int GameObject::generateNewVariableId() {
    int id = 0;
    int bgId;
    VariableData *variableItem;

    if(!variableList->empty()) {
        for(std::vector<VariableData*>::iterator it = variableList->begin(); it != variableList->end(); ++it) {
            variableItem = *it;
            bgId = variableItem->id;
            if(bgId > id) id = bgId;
        }
    }

    return (id + 1);
}

ProcedureData* GameObject::getProcedureById(int id) {
    for(std::vector<ProcedureData*>::iterator it = procedureList->begin(); it != procedureList->end(); ++it) {
        ProcedureData *procedureData = *it;

        if(procedureData->id == id) {
            return procedureData;
        }
    }

    return NULL;
}

VariableData* GameObject::getVariableById(int id) {
    for(std::vector<VariableData*>::iterator it = variableList->begin(); it != variableList->end(); ++it) {
        VariableData *variableData = *it;

        if(variableData->id == id) {
            return variableData;
        }
    }

    return NULL;
}
#include "gameobjectinstance.h"

GameObjectInstance::GameObjectInstance(GameObject *gameObject)
{
    this->gameObject = gameObject;
    nroEventos = 0;
    nroFalas = 0;
    id = 0;
    isCenter = false;
    isMainObject = false;
}
#include "imageitem.h"

ImageItem::ImageItem()
{
}
#include "maincontroller.h"

MainController::MainController()
{
}


void MainController::setEventsEditorController(EventsEditorController *eventsEditorController)
{
    this->eventsEditorController = eventsEditorController;
}

void MainController::setMapEditorController(MapEditorController *mapEditorController)
{
    this->mapEditorController = mapEditorController;
}

void MainController::setOptionsController(OptionsController *optionsController)
{
    this->optionsController = optionsController;
}

void MainController::setWizardController(WizardController *wizardController)
{
    this->wizardController = wizardController;
}



void MainController::init()
{


    mainWindow = new MainWindow(0, this);
    QSplashScreen *splash = new QSplashScreen(mainWindow, QPixmap(":/images/data/splash/splash.jpg"));
    splash->show();

    mainWindow->moveToCenter();
    mainWindow->setWindowTitle("Gameka");



    /* inicializando o vboxlayout */
    layout = new QVBoxLayout(mainWindow->getMainWindowWidget());
    layout->setMargin(0);
    layout->setSpacing(0);
    layout->setAlignment(Qt::AlignTop);


    mapEditorController->init(mainWindow, mainWindow->getMainWindowWidget(), layout);
    splash->finish(mainWindow);
    mainWindow->show();


}

void MainController::openNewProjectWindow() {
    newProjectWindow = new NewProjectWindow(mainWindow, this);

    newProjectWindow->setModal(true);
    newProjectWindow->show();

    newProjectWindow->setWindowTitle("Novo Projeto");



}

void MainController::openNewProject(std::string nomeJogo, std::string nomePasta) {
    GameData* gameData;
    gameData = GameData::getInstance();

    gameData->createInstance(nomeJogo, nomePasta);

    mapEditorController->initMapScene();
    //mapEditorController->initTileScene();
    mapEditorController->initMapSelectScene();
    mapEditorController->initObjectsDock();

    mainWindow->enableMainButtons();

    changeWindowTitle();

}

void MainController::changeWindowTitle() {
    GameData* gameData;
    gameData = GameData::getInstance();

    QString nomeTela;
    nomeTela.append("Gameka - ");
    nomeTela.append(gameData->gameName->c_str());

    mainWindow->setWindowTitle(nomeTela);
}

void MainController::loadProject(std::string fileName) {
    GameData* gameData;
    gameData = GameData::getInstance();

    gameData->erase();
    gameData->load(fileName);

    gameData->filePath = fileName;

    mapEditorController->initMapScene();
    //mapEditorController->initTileScene();
    mapEditorController->initMapSelectScene();
    mapEditorController->initObjectsDock();

    mainWindow->enableMainButtons();
    changeWindowTitle();

    QMessageBox messageBox;
    messageBox.setText("Projeto carregado com sucesso!");
    messageBox.exec();
}

void MainController::openConfigsTabWindow() {
    optionsController->openConfigsTabWindow(mainWindow);

}

void MainController::openConfigsTabWindow(GameObject *gameObject) {
    optionsController->openConfigsTabWindow(mainWindow, gameObject);
}

void MainController::saveProject() {
    GameData* gameData;
    gameData = GameData::getInstance();

    QMessageBox messageBox;
    messageBox.setText("Deseja realmente salvar o projeto?");
    messageBox.setStandardButtons(QMessageBox::Save | QMessageBox::Cancel);
    messageBox.setDefaultButton(QMessageBox::Cancel);

    int ret = messageBox.exec();

    if(ret == QMessageBox::Save) {
        gameData->save(gameData->filePath);

        QMessageBox sucessMessageBox;
        sucessMessageBox.setText("Projeto gravado com sucesso!");
        sucessMessageBox.exec();
    }

}

void MainController::runRuntime() {
    QProcess *myProcess = new QProcess(new QObject());
    GameData* gameData;
    gameData = GameData::getInstance();


    printf("Runtime: %s %s\n", gameData->getProjectDirectory().append("/").append("ludo.exe").c_str(),
           gameData->getProjectDirectory().append("/").c_str());

    QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
    env.insert("PATH", QString((env.value("Path").toStdString().append(";").append(gameData->getProjectDirectory().append("/"))).c_str()));

    myProcess->setProcessEnvironment(env);

    myProcess->execute(QString(gameData->getProjectDirectory().append("/").append("ludo.exe").c_str()),
                    QStringList() << gameData->getProjectDirectory().append("/").c_str());



}

void MainController::setEditorMode(int mode) {
    mapEditorController->setEditorMode(mode);
}

void MainController::setEditorModeIconEnabled(int mode) {
    mainWindow->setEditorModeIconEnabled(mode);
}

void MainController::reloadEditorInterface() {
    mapEditorController->reloadEditorInterface();
}

void MainController::setEditorDrawMode(int mode) {
    mapEditorController->setEditorDrawMode(mode);
}

void MainController::openEasyNewGameObjectDialog() {
    optionsController->openEasyNewGameObjectDialog();
}
#include <QtGui/QApplication>
#include <QIcon>

#include "gamedata.h"
#include "maincontroller.h"
#include "builder.h"

class GameData;


int main(int argc, char **argv)
{
    QApplication a(argc, argv);

    /* inicializando uma instância do GameData */
    GameData *gameData;
    gameData = GameData::getInstance();


    /* construindo o sistema */
    Builder *builder;
    MainController *mainController;

    builder = new Builder();
    mainController = builder->build();

    /* inicializa o mainController */
    mainController->init();

    return a.exec();
}
#include "mainwindow.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent, MainController *mainController) :
    QMainWindow(parent),
    m_ui(new Ui::MainWindow)
{
    m_ui->setupUi(this);
    m_ui->actionMapMode->setChecked(true);
    m_ui->actionPintaTile->setChecked(true);
    setWindowIcon(QIcon("data/icons/progicon.png"));
    this->mainController = mainController;

}

MainWindow::~MainWindow()
{
    delete m_ui;
}

void MainWindow::changeEvent(QEvent *e)
{
    QMainWindow::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        m_ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

void MainWindow::moveToCenter()
{
    QDesktopWidget desktopWidget;
    QPoint center;


    center = desktopWidget.availableGeometry(desktopWidget.primaryScreen()).center();
    center.setX(center.x() - (this->width()/2));
    center.setY(center.y() - (this->height()/2));
    move(center);
}

void MainWindow::setEditorModeIconEnabled(int mode) {
    if(mode == MapEditorController::MODE_MAP) {
        m_ui->actionMapMode->setChecked(true);
        m_ui->actionObjectMode->setChecked(false);
    } else if(mode == MapEditorController::MODE_OBJECT) {
        m_ui->actionMapMode->setChecked(false);
        m_ui->actionObjectMode->setChecked(true);
    }
}

void MainWindow::enableMainButtons()
{
    m_ui->actionConfiguracoes->setEnabled(true);
    m_ui->actionDesfazer->setEnabled(true);
    m_ui->actionPintaBloco->setEnabled(true);
    m_ui->actionApagaBloco->setEnabled(true);
    m_ui->actionPintaCirculo->setEnabled(true);
    m_ui->actionPintaQuadrado->setEnabled(true);
    m_ui->actionPintaTile->setEnabled(true);
    m_ui->actionRefazer->setEnabled(true);
    m_ui->actionRodar->setEnabled(true);
    m_ui->actionSalvar_Projeto->setEnabled(true);
    m_ui->actionSelecaoCirculo->setEnabled(true);
    m_ui->actionSelecionaQuadrado->setEnabled(true);
    m_ui->actionMapMode->setEnabled(true);
    m_ui->actionObjectMode->setEnabled(true);
    m_ui->actionEventMode->setEnabled(true);
}

QWidget* MainWindow::getMainWindowWidget()
{
    return m_ui->mainWindowWidget;
}

void MainWindow::on_actionNovo_Projeto_triggered()
{
    mainController->openNewProjectWindow();
}

void MainWindow::on_actionPintaTile_activated()
{
    m_ui->actionPintaTile->setChecked(true);
    m_ui->actionApagaBloco->setChecked(false);
    m_ui->actionPintaBloco->setChecked(false);
    m_ui->actionPintaCirculo->setChecked(false);
    m_ui->actionPintaQuadrado->setChecked(false);
    m_ui->actionSelecaoCirculo->setChecked(false);
    m_ui->actionSelecionaQuadrado->setChecked(false);

    mainController->setEditorDrawMode(MapEditorController::DRAW_MODE_PENCIL);
}

void MainWindow::on_actionPintaQuadrado_activated()
{
    m_ui->actionPintaTile->setChecked(false);
    m_ui->actionApagaBloco->setChecked(false);
    m_ui->actionPintaBloco->setChecked(false);
    m_ui->actionPintaCirculo->setChecked(false);
    m_ui->actionPintaQuadrado->setChecked(true);
    m_ui->actionSelecaoCirculo->setChecked(false);
    m_ui->actionSelecionaQuadrado->setChecked(false);

    mainController->setEditorDrawMode(MapEditorController::DRAW_MODE_SQUARE);
}

void MainWindow::on_actionPintaBloco_activated()
{
    m_ui->actionPintaTile->setChecked(false);
    m_ui->actionApagaBloco->setChecked(false);
    m_ui->actionPintaBloco->setChecked(true);
    m_ui->actionPintaCirculo->setChecked(false);
    m_ui->actionPintaQuadrado->setChecked(false);
    m_ui->actionSelecaoCirculo->setChecked(false);
    m_ui->actionSelecionaQuadrado->setChecked(false);

    mainController->setEditorDrawMode(MapEditorController::DRAW_MODE_PAINT);
}

void MainWindow::on_actionPintaCirculo_activated()
{
    m_ui->actionPintaCirculo->setChecked(true);
    m_ui->actionApagaBloco->setChecked(false);
    m_ui->actionPintaTile->setChecked(false);
    m_ui->actionPintaBloco->setChecked(false);
    m_ui->actionPintaQuadrado->setChecked(false);
    m_ui->actionSelecaoCirculo->setChecked(false);
    m_ui->actionSelecionaQuadrado->setChecked(false);

    mainController->setEditorDrawMode(MapEditorController::DRAW_MODE_CIRCLE);
}

void MainWindow::on_actionSelecionaQuadrado_activated()
{
    m_ui->actionSelecionaQuadrado->setChecked(true);
    m_ui->actionApagaBloco->setChecked(false);
    m_ui->actionPintaTile->setChecked(false);
    m_ui->actionPintaBloco->setChecked(false);
    m_ui->actionPintaCirculo->setChecked(false);
    m_ui->actionPintaQuadrado->setChecked(false);
    m_ui->actionSelecaoCirculo->setChecked(false);

    mainController->setEditorDrawMode(MapEditorController::DRAW_MODE_SELECT_SQUARE);
}

void MainWindow::on_actionSelecaoCirculo_activated()
{
    m_ui->actionSelecaoCirculo->setChecked(true);
    m_ui->actionApagaBloco->setChecked(false);
    m_ui->actionPintaTile->setChecked(false);
    m_ui->actionPintaBloco->setChecked(false);
    m_ui->actionPintaCirculo->setChecked(false);
    m_ui->actionPintaQuadrado->setChecked(false);
    m_ui->actionSelecionaQuadrado->setChecked(false);

    mainController->setEditorDrawMode(MapEditorController::DRAW_MODE_SELECT_CIRCLE);
}

void MainWindow::on_actionApagaBloco_activated()
{
    m_ui->actionApagaBloco->setChecked(true);
    m_ui->actionSelecaoCirculo->setChecked(false);
    m_ui->actionPintaTile->setChecked(false);
    m_ui->actionPintaBloco->setChecked(false);
    m_ui->actionPintaCirculo->setChecked(false);
    m_ui->actionPintaQuadrado->setChecked(false);
    m_ui->actionSelecionaQuadrado->setChecked(false);

    mainController->setEditorDrawMode(MapEditorController::DRAW_MODE_ERASER);
}


void MainWindow::on_actionPintaBloco_triggered()
{

}

void MainWindow::on_actionConfiguracoes_triggered()
{
    mainController->openConfigsTabWindow();
}

void MainWindow::on_actionAbrir_Projeto_triggered()
{
    QString fileName;

    fileName = QFileDialog::getOpenFileName(this, tr("Open Project"), "projects/", tr("(*.ldo)"));

    if(!fileName.isEmpty()) {
        mainController->loadProject(fileName.toStdString());
    }
}

void MainWindow::on_actionSalvar_Projeto_triggered()
{
    mainController->saveProject();
}

void MainWindow::on_actionRodar_triggered()
{
    mainController->runRuntime();
}

void MainWindow::on_actionMapMode_triggered(bool checked)
{
    m_ui->actionMapMode->setChecked(true);
    m_ui->actionObjectMode->setChecked(false);
    m_ui->actionEventMode->setChecked(false);
    mainController->setEditorMode(MapEditorController::MODE_MAP);
}

void MainWindow::on_actionObjectMode_triggered(bool checked)
{
    m_ui->actionMapMode->setChecked(false);
    m_ui->actionObjectMode->setChecked(true);
    m_ui->actionEventMode->setChecked(false);
    mainController->setEditorMode(MapEditorController::MODE_OBJECT);

}


void MainWindow::on_actionEventMode_triggered(bool checked)
{
    m_ui->actionMapMode->setChecked(false);
    m_ui->actionObjectMode->setChecked(false);
    m_ui->actionEventMode->setChecked(true);
    mainController->setEditorMode(MapEditorController::MODE_EVENT);
}

#include "mainwindowwidget.h"

MainWindowWidget::MainWindowWidget(QWidget *parent) : QWidget(parent)
{
}
#include "map.h"

Map::Map() {
    filhos = NULL;

    tileSets = new std::vector<TileSet*>();
    gameObjects = new std::vector<GameObject*>();
    gameObjectInstances = new std::vector<GameObjectInstance*>();
    teleportAreas = new std::vector<TeleportArea*>();

    music = std::string("");
    sound = std::string("");

    loopMusic = -1;
    loopSound = -1;

    background = NULL;

    width = 25;
    height = 18;
}

Map::Map(std::string mapName, int width, int height, int layers)
{
    int i, j, z;

    /* inicializando os parâmetros */
    this->mapName = mapName;
    this->width = width;
    this->height = height;
    this->layers = layers;


    /* determinando o tamanho do mapa */
    map.resize(boost::extents[width][height][layers]);

    /* inicializando a matriz com as posicoes 0 */
    for(i = 0; i < width; i++)
        for(j = 0; j < height; j++)
            for(z = 0; z < layers;  z++) {
                 map[i][j][z].x = -1;
                 map[i][j][z].y = -1;
                 map[i][j][z].z = NULL;
    }


    filhos = NULL;

    tileSets = new std::vector<TileSet*>();
    gameObjects = new std::vector<GameObject*>();
    gameObjectInstances = new std::vector<GameObjectInstance*>();
    teleportAreas = new std::vector<TeleportArea*>();

    music = std::string("");
    sound = std::string("");

    loopMusic = -1;
    loopSound = -1;

    background = NULL;


}

bool Map::isFolder() {
    return (filhos != NULL);
}

Map::Map(std::string folderName, std::vector<Map* > *mapasFilhos) {
    this->mapName = folderName;
    this->filhos = mapasFilhos;
}

void Map::extent(int layers) {
    this->layers = layers;
    map.resize(boost::extents[width][height][layers]);
}

void Map::extent(int width, int height, int layers) {
    this->layers = layers;
    this->width = width;
    this->height = height;

    map.resize(boost::extents[width][height][layers]);
}

void Map::setTile(int i, int j, int layer, int xvalue, int yvalue) {
    map[i][j][layer].x = xvalue;
    map[i][j][layer].y = yvalue;
}

bool Map::verifyTileFilled(int layer) {
    for(int i = 0; i < width; i++) {
        for(int j = 0; j < height; j++) {
            if(map[i][j][layer].z != NULL) {
                return true;
            }
        }

    }

    return false;


}
#include "mapeditorcontroller.h"


MapEditorController::MapEditorController()
{
    iDrawTile = 0;
    jDrawTile = 0;

    editorLayer = 0;
    drawMode = 0;

}

void MapEditorController::setMainController(MainController *mainController)
{
    this->mainController = mainController;
}


void MapEditorController::init(MainWindow *mainWindow, QWidget *parent, QVBoxLayout *layout)
{
    this->mainWindow = mainWindow;

    /* criando as docks */
    tilesetDock = new TilesetDock(mainWindow, this);
    mapSelectDock = new MapSelectDock(mainWindow, this);
    objectsDock = new ObjectsDock(this, mainWindow);


    mainWindow->addDockWidget(Qt::LeftDockWidgetArea, tilesetDock);
    mainWindow->addDockWidget(Qt::LeftDockWidgetArea, mapSelectDock);
    mainWindow->addDockWidget(Qt::RightDockWidgetArea, objectsDock);

    /* criando o mapView e o mapScene */
    tilemapView = new TilemapView(parent);
    layout->addWidget(tilemapView);


    tilemapView->hide();
    mapSelectDock->widget->hide();

    drawTileset = NULL;
    // TODO: inicializar apropriadamente o drawTileset

    editorMode = MODE_MAP;

    mapSceneInitializated = false;
    tileSceneInitializated = false;
    mapSelectSceneInitializated = false;
    objectsDockInitializated = false;


}

void MapEditorController::initMapScene() {
    GameData *gameData = GameData::getInstance();

    if(gameData->editingMap != NULL) {
        tilemapScene = new TilemapScene(32, gameData->editingMap->width, gameData->editingMap->height, gameData->editingMap->layers, this);
        tilemapView->setScene(tilemapScene);
        tilemapView->setAlignment(Qt::AlignLeft);
        tilemapView->horizontalScrollBar()->setValue(tilemapView->horizontalScrollBar()->minimum());

        tilemapView->show();
        initTileScene();

        mapSceneInitializated = true;
    }

}

void MapEditorController::initTileScene() {
    tilesetDock->initTileSetScene();
    tileSceneInitializated = true;
}

void MapEditorController::initMapSelectScene() {
    mapSelectDock->widget->show();
    mapSelectDock->populaArvore();

    Map *map;
    map = mapSelectDock->getMapaSelecionado();
    if(map != NULL) {
        selectMap(map);
    }

    mapSelectSceneInitializated = true;

}

void MapEditorController::initObjectsDock() {
    objectsDock->initDockScene();

    objectsDockInitializated = true;
}

void MapEditorController::reloadEditorInterface() {
    if(mapSceneInitializated) {
        initMapScene();
    }

    if(tileSceneInitializated) {
        initTileScene();
    }

    if(objectsDockInitializated) {
        initObjectsDock();
    }

    if(mapSelectSceneInitializated) {
        initMapSelectScene();
    }

}

void MapEditorController::selectDefaultMap() {

}

void MapEditorController::setDrawTile(int iDrawTile, int jDrawTile, int diDrawTile, int djDrawTile) {
    this->iDrawTile = iDrawTile;
    this->jDrawTile = jDrawTile;
    this->diDrawTile = diDrawTile;
    this->djDrawTile = djDrawTile;
    this->drawTileset = tilesetDock->getSelectedTileset();

    tilemapScene->setSelectionRectangleSize(diDrawTile, djDrawTile);

}

void MapEditorController::changeTile(int i, int j) {
    int m, n;
    GameData *gameData = GameData::getInstance();

    switch(drawMode) {
    case DRAW_MODE_PENCIL:
        // printf("%d %d %d %d %d %d", i, j, iTile, jTile, diTile, djTile);
        for(m = 0; m <= diDrawTile; m++) {
            for(n = 0; n <= djDrawTile; n++) {
                int di = (i + m - iClick)%(diDrawTile + 1);
                int dj = (j + n - jClick)%(djDrawTile + 1);

                if(di < 0) {
                    di = diDrawTile + 1 + di;
                }

                if(dj < 0) {
                    dj = djDrawTile + 1 + dj;
                }

                tilemapScene->changeTile(i + m, j + n, iDrawTile + di, jDrawTile + dj, editorLayer, drawTileset);
                if(i + m < gameData->editingMap->width &&
                   j + n < gameData->editingMap->height && i + m >= 0 && j + n >= 0) {
                    gameData->editingMap->map[i + m][j + n][editorLayer].x = iDrawTile + di;
                    gameData->editingMap->map[i + m][j + n][editorLayer].y = jDrawTile + dj;
                    gameData->editingMap->map[i + m][j + n][editorLayer].z = drawTileset;
                }

            }
        }
        break;
    case DRAW_MODE_ERASER:
        for(m = 0; m <= diDrawTile; m++) {
            for(n = 0; n <= djDrawTile; n++) {


                tilemapScene->changeTile(i + m, j + n, -1, -1, editorLayer, NULL);
                if(i + m < gameData->editingMap->width &&
                   j + n < gameData->editingMap->height && i + m >= 0 && j + n >= 0) {
                    gameData->editingMap->map[i + m][j + n][editorLayer].x = -1;
                    gameData->editingMap->map[i + m][j + n][editorLayer].y = -1;
                    gameData->editingMap->map[i + m][j + n][editorLayer].z = NULL;
                }

            }
        }
        break;
    case DRAW_MODE_PAINT:
        floodFillBrute(i, j, gameData->editingMap->map[i][j][editorLayer].x, gameData->editingMap->map[i][j][editorLayer].y, gameData->editingMap->map[i][j][editorLayer].z, iDrawTile, jDrawTile, drawTileset);
        break;
    default:

        break;
    }



    tilemapView->update();
    tilemapScene->update();


}

void MapEditorController::changeTiles(int iStart, int jStart, int iEnd, int jEnd) {
    int iRealStart, jRealStart, iRealEnd, jRealEnd;
    GameData *gameData = GameData::getInstance();

    iRealStart = std::min(iStart, iEnd);
    jRealStart = std::min(jStart, jEnd);
    iRealEnd = std::max(iStart, iEnd);
    jRealEnd = std::max(jStart, jEnd);

    if(iRealStart < 0) {
        iRealStart = 0;
    }

    if(jRealStart < 0) {
        jRealStart = 0;
    }

    if(iRealEnd > gameData->editingMap->width - 1) {
        iRealEnd = gameData->editingMap->width - 1;
    }

    if(jRealEnd > gameData->editingMap->height - 1) {
        jRealEnd = gameData->editingMap->height - 1;
    }

    for(int i = iRealStart; i <= iRealEnd; i++) {
        for(int j = jRealStart; j <= jRealEnd; j++) {
            int di = (i - iClick)%(diDrawTile + 1);
            int dj = (j - jClick)%(djDrawTile + 1);

            if(di < 0) {
                di = diDrawTile + 1 + di;
            }

            if(dj < 0) {
                dj = djDrawTile + 1 + dj;
            }

            tilemapScene->changeTile(i, j, iDrawTile + di, jDrawTile + dj, editorLayer, drawTileset);
            if(i < gameData->editingMap->width &&
               j < gameData->editingMap->height && i >= 0 && j >= 0) {
                gameData->editingMap->map[i][j][editorLayer].x = iDrawTile + di;
                gameData->editingMap->map[i][j][editorLayer].y = jDrawTile + dj;
                gameData->editingMap->map[i][j][editorLayer].z = drawTileset;
            }

        }
    }

    tilemapView->update();
    tilemapScene->update();
}

void MapEditorController::floodFill(int nodeI, int nodeJ, int targetI, int targetJ, int replacementI, int replacementJ) {
    std::list<Point> queue;
    GameData *gameData = GameData::getInstance();

    if(gameData->editingMap->map[nodeI][nodeJ][editorLayer].x != targetI ||
            gameData->editingMap->map[nodeI][nodeJ][editorLayer].y != targetJ) {
        return;
    }

    queue.push_back(Point(nodeI, nodeJ));

    for(std::list<Point>::iterator it = queue.begin(); it != queue.end(); ++it) {
        Point node = *it;

        if((gameData->editingMap->map[node.x][node.y][editorLayer].x == targetI &&
            gameData->editingMap->map[node.x][node.y][editorLayer].y == targetJ)) {
            Point westNodes = node;
            Point eastNodes = node;

            while(westNodes.x - 1 >= 0 && (gameData->editingMap->map[westNodes.x - 1][westNodes.y][editorLayer].x == targetI &&
                                           gameData->editingMap->map[westNodes.x - 1][westNodes.y][editorLayer].y == targetJ)) {
                westNodes.x--;
            }

            while(eastNodes.x + 1 < gameData->editingMap->width && (gameData->editingMap->map[eastNodes.x + 1][eastNodes.y][editorLayer].x == targetI &&
                                                                    gameData->editingMap->map[eastNodes.x + 1][eastNodes.y][editorLayer].y == targetJ)) {
                eastNodes.x++;
            }

            for(int i = westNodes.x; i <= eastNodes.x; i++) {
                gameData->editingMap->map[i][eastNodes.y][editorLayer].x = replacementI;
                gameData->editingMap->map[i][eastNodes.y][editorLayer].y = replacementJ;
                tilemapScene->changeTile(i, eastNodes.y, replacementI, replacementJ, editorLayer, drawTileset);


                if(eastNodes.y - 1 >= 0 && (gameData->editingMap->map[i][eastNodes.y - 1][editorLayer].x == targetI &&
                                  gameData->editingMap->map[i][eastNodes.y - 1][editorLayer].y == targetJ)) {
                    queue.push_back(Point(i, eastNodes.y - 1));
                }

                if(eastNodes.y + 1 < gameData->editingMap->height && (gameData->editingMap->map[i][eastNodes.y + 1][editorLayer].x == targetI &&
                                  gameData->editingMap->map[i][eastNodes.y + 1][editorLayer].y == targetJ)) {
                    queue.push_back(Point(i, eastNodes.y + 1));
                }


            }
        }
    }
}

void MapEditorController::floodFillBrute(int nodeI, int nodeJ, int targetI, int targetJ, TileSet *targetTileset, int replacementI, int replacementJ, TileSet *replacementTileset) {
    GameData *gameData = GameData::getInstance();

    if(targetI == replacementI && targetJ == replacementJ && targetTileset == replacementTileset) {
        return;
    }

    if(gameData->editingMap->map[nodeI][nodeJ][editorLayer].x != targetI ||
            gameData->editingMap->map[nodeI][nodeJ][editorLayer].y != targetJ ||
            gameData->editingMap->map[nodeI][nodeJ][editorLayer].z != targetTileset) {
        return;
    }

    //gameData->editingMap->map[nodeI][nodeJ][editorLayer].x = replacementI;
    //gameData->editingMap->map[nodeI][nodeJ][editorLayer].y = replacementJ;

    int di = (nodeI - iClick)%(diDrawTile + 1);
    int dj = (nodeJ - jClick)%(djDrawTile + 1);

    if(di < 0) {
        di = diDrawTile + 1 + di;
    }

    if(dj < 0) {
        dj = djDrawTile + 1 + dj;
    }

    gameData->editingMap->map[nodeI][nodeJ][editorLayer].x = replacementI + di;
    gameData->editingMap->map[nodeI][nodeJ][editorLayer].y = replacementJ + dj;
    gameData->editingMap->map[nodeI][nodeJ][editorLayer].z = replacementTileset;
    tilemapScene->changeTile(nodeI, nodeJ, replacementI + di, replacementJ + dj, editorLayer, replacementTileset);

    if(nodeI - 1 >= 0) {
        floodFillBrute(nodeI - 1, nodeJ, targetI, targetJ, targetTileset, replacementI, replacementJ, replacementTileset);
    }

    if(nodeI + 1 < gameData->editingMap->width) {
        floodFillBrute(nodeI + 1, nodeJ, targetI, targetJ, targetTileset, replacementI, replacementJ, replacementTileset);
    }

    if(nodeJ - 1 >= 0) {
        floodFillBrute(nodeI, nodeJ - 1, targetI, targetJ, targetTileset, replacementI, replacementJ, replacementTileset);
    }

    if(nodeJ + 1 < gameData->editingMap->height) {
        floodFillBrute(nodeI, nodeJ + 1, targetI, targetJ, targetTileset, replacementI, replacementJ, replacementTileset);
    }
}

void MapEditorController::openNewMapWindow() {
    newMapWindow = new NewMapWindow(this, NULL, mainWindow);
    newMapWindow->setWindowTitle("Novo Mapa");
    newMapWindow->setModal(true);
    newMapWindow->setVisible(true);
}

void MapEditorController::openEditMapWindow(Map *map) {
    newMapWindow = new NewMapWindow(this, map, mainWindow);
    newMapWindow->setWindowTitle("Editar Mapa");
    newMapWindow->setModal(true);
    newMapWindow->setVisible(true);
}

void MapEditorController::createNewMap(Map *newMap) {
    GameData *gameData = GameData::getInstance();
    Map *mapaSelecionado;

    mapaSelecionado = mapSelectDock->getMapaSelecionado();

    newMap->key = gameData->generateNewMapId();


    if((mapaSelecionado == NULL) || ((mapaSelecionado != NULL) && (mapaSelecionado->filhos == NULL))) {
        gameData->mapList->push_back(newMap);
    } else {
        mapaSelecionado->filhos->push_back(newMap);
    }

    mapSelectDock->populaArvore();

    if(newMap->filhos == NULL) {
        gameData->editingMap = newMap;
        initMapScene();
    }


}

void MapEditorController::refreshMapWidgets() {
    mapSelectDock->populaArvore();
    initMapScene();
}

void MapEditorController::createFolder() {
    GameData* gameData = GameData::getInstance();

    Map *newFolder;
    Map *mapaSelecionado;

    bool ok;

    QString text = QInputDialog::getText(mainWindow, *(new QString("Nova pasta")),
                                         *(new QString("Nome:")), QLineEdit::Normal,
                                            *(new QString("")), &ok);

    if(ok && !text.isEmpty()) {
        newFolder = new Map(text.toStdString(), new std::vector<Map*>());

        mapaSelecionado = mapSelectDock->getMapaSelecionado();

        if((mapaSelecionado == NULL) || ((mapaSelecionado != NULL) && (mapaSelecionado->filhos == NULL))) {
            gameData->mapList->push_back(newFolder);
        } else {
            mapaSelecionado->filhos->push_back(newFolder);
        }

        mapSelectDock->populaArvore();
    }


}

void MapEditorController::selectMap(Map *map) {
    GameData *gameData = GameData::getInstance();

    // só muda se NÃO for pasta
    if(map->filhos == NULL) {
        gameData->editingMap = map;

        objectsDock->populaArvoreObjetos();
        initMapScene();
    }


}

Map* MapEditorController::getSelectedMap() {
    return mapSelectDock->getMapaSelecionado();
}

GameObject* MapEditorController::getSelectedObject() {
    return objectsDock->getCurrentObject();
}


void MapEditorController::setEditorMode(int mode) {
    editorMode = mode;
    mainController->setEditorModeIconEnabled(mode);
    tilemapScene->setEditorMode(mode);
}

void MapEditorController::setEditorDrawMode(int mode) {
    drawMode = mode;
    tilemapScene->setSelectionRectangleSize(diDrawTile, djDrawTile);
}

int MapEditorController::setMapEditorLayer(int layer) {
    GameData *gameData = GameData::getInstance();

    if(layer <= (gameData->editingMap->layers - 1)) {
        editorLayer = layer;
        tilemapScene->setEditionLayer(layer);


        return layer;
    } else {
        layer = gameData->editingMap->layers;

        if(gameData->editingMap->verifyTileFilled(layer-1)) {
            editorLayer = layer;
            gameData->editingMap->extent(layer + 1);
            tilemapScene->setEditionLayer(layer);


            return layer;
        }
    }

    return 0;
}

void MapEditorController::openConfigsTabWindow(GameObject* gameObject) {
    mainController->openConfigsTabWindow(gameObject);
}

void MapEditorController::openEasyNewGameObjectDialog() {
    mainController->openEasyNewGameObjectDialog();
}

void MapEditorController::setCurrentObjectAtCursor() {
    tilemapScene->setCurrentObjectAtCursor();
}
#include "mapselectdock.h"


MapSelectDock::MapSelectDock(QWidget *parent, MapEditorController *mapEditorController) : QDockWidget(parent)
{

    setWindowTitle(tr("Mapas"));
    setMinimumHeight(100);

    this->mapEditorController = mapEditorController;

    widget = new QWidget(this);


    /* inicializando o layout */
    vboxLayout = new QVBoxLayout(widget);
    vboxLayout->setMargin(5);
    vboxLayout->setSpacing(0);


    treeWidget = new QTreeWidget(this);
    treeWidget->setColumnCount(1);

    treeWidget->setDragEnabled(true);



    vboxLayout->addWidget(treeWidget);

    /*
    QList<QTreeWidgetItem *> items;
    for (int i = 0; i < 10; ++i) {
        QTreeWidgetItem* newItem;
        newItem = new QTreeWidgetItem((QTreeWidget*)0, QStringList(QString("item: %1").arg(i)));
        newItem->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled | Qt::ItemIsDragEnabled);
        if(i == 3) {
            newItem->insertChild(0, new QTreeWidgetItem((QTreeWidget*)0, QStringList(QString("item filho"))));
        }

        items.append(newItem);
    }

    treeWidget->insertTopLevelItems(0, items);
    */
    populaArvore();



    //treeView = new QTreeView(this);

    /*
    model = new QStringListModel(this);
    QStringList stringList;
    stringList.append("Mapa 01");
    model->setStringList(stringList);
    treeView->setModel(model);

    */
    /* inicializando o hBoxLayout dos botões */
    hboxLayout = new QHBoxLayout(widget);
    hboxLayout->setMargin(0);
    vboxLayout->setSpacing(0);

    vboxLayout->addLayout(hboxLayout);

    /* inicializando os botoes */
    botaoCriaMapa = new QPushButton("Cria Mapa", widget);
    botaoEditaMapa = new QPushButton("Edita Mapa", widget);
    botaoDeletaMapa = new QPushButton("Deleta Mapa", widget);
    botaoCriaPasta = new QPushButton("Cria Pasta", widget);

    QObject::connect(botaoCriaMapa, SIGNAL(clicked()), this, SLOT(botaoCriaMapaClicked()));
    QObject::connect(botaoCriaPasta, SIGNAL(clicked()), this, SLOT(botaoCriaPastaClicked()));
    QObject::connect(treeWidget, SIGNAL(itemClicked(QTreeWidgetItem*,int)), this, SLOT(treeWidgetItemClicked(QTreeWidgetItem*,int)));
    QObject::connect(botaoEditaMapa, SIGNAL(clicked()), this, SLOT(botaoEditaMapaClicked()));

    hboxLayout->addWidget(botaoCriaMapa);
    hboxLayout->addWidget(botaoEditaMapa);
    hboxLayout->addWidget(botaoDeletaMapa);

    vboxLayout->addWidget(botaoCriaPasta);



    setWidget(widget);
}

void MapSelectDock::botaoCriaMapaClicked() {
    mapEditorController->openNewMapWindow();
}

void MapSelectDock::botaoCriaPastaClicked() {
    mapEditorController->createFolder();
}

void MapSelectDock::initMapSelectScene() {

}


void MapSelectDock::populaArvore() {
    GameData *gameData = GameData::getInstance();

    std::vector<Map *> *arvoreMapas;

    arvoreMapas = gameData->mapList;

    QList<QTreeWidgetItem *> items;

    treeWidget->clear();

    QTreeWidgetItem* firstItem = NULL;

    for(std::vector<Map*>::iterator it = arvoreMapas->begin(); it != arvoreMapas->end(); ++it) {
        Map *mapa = (Map*)(*it);

        QTreeWidgetItem* newItem;
        newItem = new QTreeWidgetItem((QTreeWidget*)0, QStringList(QString(mapa->mapName.c_str())));
        newItem->setData(0, Qt::UserRole, QVariant::fromValue((void*) mapa));
        newItem->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled | Qt::ItemIsDragEnabled);



        if(mapa->filhos != NULL) {
            newItem->setIcon(0, QIcon::fromTheme("folder"));
            populaSubpastas(mapa->filhos, newItem);
        } else {
            newItem->setIcon(0, QIcon::fromTheme("document"));

            if(firstItem == NULL) {
                firstItem = newItem;
            }
        }

        items.append(newItem);

    }

    treeWidget->insertTopLevelItems(0, items);

    if(firstItem != NULL) {
        treeWidget->setCurrentItem(firstItem, 0);
    }

}

void MapSelectDock::populaSubpastas(std::vector<Map *> *subarvore, QTreeWidgetItem *item) {

    for(std::vector<Map *>::iterator it = subarvore->begin(); it != subarvore->end(); ++it) {
        Map *mapa = (Map*)(*it);

        QTreeWidgetItem* newItem;
        newItem = new QTreeWidgetItem((QTreeWidget*)0, QStringList(QString(mapa->mapName.c_str())));
        newItem->setData(0, Qt::UserRole, QVariant::fromValue((void*) mapa));
        newItem->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled | Qt::ItemIsDragEnabled);

        if(mapa->filhos != NULL) {
            newItem->setIcon(0, QIcon::fromTheme("folder"));
            populaSubpastas(mapa->filhos, newItem);
        } else {
            newItem->setIcon(0, QIcon::fromTheme("document"));
        }

        item->addChild(newItem);
    }
}

Map* MapSelectDock::getMapaSelecionado() {

    if(treeWidget->currentItem() == NULL) {
        return NULL;
    } else {
        return (Map*) treeWidget->currentItem()->data(0, Qt::UserRole).value<void*>();
    }

}

void MapSelectDock::treeWidgetItemClicked(QTreeWidgetItem *item, int index) {
    mapEditorController->selectMap((Map*) treeWidget->currentItem()->data(0, Qt::UserRole).value<void*>());

}

void MapSelectDock::botaoEditaMapaClicked() {
    mapEditorController->openEditMapWindow((Map*) treeWidget->currentItem()->data(0, Qt::UserRole).value<void*>());
}
#include "messageboxes.h"

MessageBoxes::MessageBoxes()
{
}

void MessageBoxes::showMessageBox(std::string message) {
    QMessageBox sucessMessageBox;
    sucessMessageBox.setText(QString(message.c_str()));
    sucessMessageBox.exec();
}

void MessageBoxes::showMessageBox(QString message) {
    QMessageBox sucessMessageBox;
    sucessMessageBox.setText(message);
    sucessMessageBox.exec();
}

bool MessageBoxes::showConfirmBox(std::string message) {
    QMessageBox confirmBox;
    confirmBox.setText(QString(message.c_str()));
    confirmBox.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel);
    confirmBox.setDefaultButton(QMessageBox::Cancel);

    int ret = confirmBox.exec();
    if(ret == QMessageBox::Ok) {
        return true;
    } else {
        return false;
    }
}
#include "neweventareadialog.h"
#include "ui_neweventareadialog.h"

NewEventAreaDialog::NewEventAreaDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::NewEventAreaDialog)
{
    ui->setupUi(this);
}

NewEventAreaDialog::~NewEventAreaDialog()
{
    delete ui;
}
#include "neweventdialog.h"
#include "ui_neweventdialog.h"

NewEventDialog::NewEventDialog(EventsEditorController *eventsEditorController, EventData *eventData, GameObject *gameObject, int type, int conditionType, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::NewEventDialog),
    eventsEditorController(eventsEditorController),
    eventData(eventData),
    gameObject(gameObject),
    type(type),
    conditionType(conditionType)
{
    ui->setupUi(this);

    if(type == EventData::TYPE_ACTION) {
        ui->labelCondAction->setText(QString::fromUtf8("Ação:"));
    }

    populaListaObjects();
    freeAttributeData();
}

NewEventDialog::~NewEventDialog()
{
    delete ui;


}

void NewEventDialog::preencheCampos() {
    if(!eventData->newEvent) {
        // TODO: rotina de preencher campos

    }
}

void NewEventDialog::freeAttributeData() {
    for(int i = 0; i < ui->comboBoxAttrib->count(); i++) {
        EventAttributeData *eventAttributeData = (EventAttributeData*) ui->comboBoxAttrib->itemData(i, Qt::UserRole).value<void*>();

        if(eventAttributeData->id == EventComboDataProvider::ATT_VARIABLES) {
            delete eventAttributeData;
        }
    }
}

void NewEventDialog::populaListaObjects() {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::vector<GameObject*>* objectList;

    objectList = gameData->objectList;

    ui->listWidgetObject1->clear();
    ui->listWidgetObject2->clear();


    QListWidgetItem *specialNewItem;

    specialNewItem = new QListWidgetItem();
    specialNewItem->setText(QString::fromUtf8("Especiais: "));
    specialNewItem->setData(Qt::UserRole, QVariant::fromValue((void*) NULL));

    ui->listWidgetObject1->addItem(specialNewItem);

//    specialNewItem = new QListWidgetItem();
//    specialNewItem->setText(QString::fromUtf8("Especiais:"));
//    specialNewItem->setData(Qt::UserRole, QVariant::fromValue((void*) NULL));

//    ui->listWidgetObject2->addItem(specialNewItem);

    std::list<GameObject *> specialGameObjects = eventsEditorController->getSpecialGameObjects(type);

    foreach(GameObject *specialGameObject, specialGameObjects) {
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString(specialGameObject->name.c_str()));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) new std::pair<int, GameObject*>(std::make_pair(-1, specialGameObject))));
        newItem->setIcon(QIcon(QPixmap::fromImage(specialGameObject->getIconImage())));

        ui->listWidgetObject1->addItem(newItem);

//        newItem = new QListWidgetItem();
//        newItem->setText(QString(specialGameObject->name.c_str()));
//        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) new std::pair<int, GameObject*>(std::make_pair(-1, specialGameObject))));
//        newItem->setIcon(QIcon(QPixmap::fromImage(specialGameObject->getIconImage())));

//        ui->listWidgetObject2->addItem(newItem);
    }



    specialNewItem = new QListWidgetItem();
    specialNewItem->setText(QString::fromUtf8("Objetos de classe:"));
    specialNewItem->setData(Qt::UserRole, QVariant::fromValue((void*) NULL));

    ui->listWidgetObject1->addItem(specialNewItem);

    specialNewItem = new QListWidgetItem();
    specialNewItem->setText(QString::fromUtf8("Objetos de classe:"));
    specialNewItem->setData(Qt::UserRole, QVariant::fromValue((void*) NULL));

    ui->listWidgetObject2->addItem(specialNewItem);



    for(std::vector<GameObject*>::iterator it = objectList->begin(); it != objectList->end(); ++it) {
        GameObject *gameObject;
        gameObject = *it;


        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString(gameObject->name.c_str()));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) new std::pair<int, GameObject*>(std::make_pair(-1, gameObject))));
        newItem->setIcon(QIcon(QPixmap::fromImage(gameObject->getIconImage())));

        ui->listWidgetObject1->addItem(newItem);

        newItem = new QListWidgetItem();
        newItem->setText(QString(gameObject->name.c_str()));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) new std::pair<int, GameObject*>(std::make_pair(-1, gameObject))));
        newItem->setIcon(QIcon(QPixmap::fromImage(gameObject->getIconImage())));

        ui->listWidgetObject2->addItem(newItem);

    }


    std::vector<GameObject*> contextObjects = eventsEditorController->getContextObjects(eventData);


    if(!contextObjects.empty() || gameObject != NULL) {
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString::fromUtf8("Objetos de instância:"));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) NULL));

        ui->listWidgetObject1->addItem(newItem);

        newItem = new QListWidgetItem();
        newItem->setText(QString::fromUtf8("Objetos de instância:"));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) NULL));

        ui->listWidgetObject2->addItem(newItem);
    }

    if(gameObject != NULL) {
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString("Este objeto"));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) new std::pair<int, GameObject*>(std::make_pair(0, gameObject))));
        newItem->setIcon(QIcon(QPixmap::fromImage(gameObject->getIconImage())));

        ui->listWidgetObject1->addItem(newItem);

        newItem = new QListWidgetItem();
        newItem->setText(QString("Este objeto"));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) new std::pair<int, GameObject*>(std::make_pair(0, gameObject))));
        newItem->setIcon(QIcon(QPixmap::fromImage(gameObject->getIconImage())));

        ui->listWidgetObject2->addItem(newItem);


    }

    std::stringstream ss;

    int i = 1;
    int contextObjectsSize = contextObjects.size();
    foreach(GameObject* contextObject, contextObjects) {
        int ajusteIndice;
        if(i%2) {
            ajusteIndice = 0;
        } else {
            ajusteIndice = 2;
        }

        if(contextObject != NULL) {
            ss.str("");
            ss << QString::fromUtf8("Inst. de Contexto ").toStdString() <<  contextObjectsSize - i + ajusteIndice << " (" << i << " )";

            QListWidgetItem *newItem = new QListWidgetItem();
            newItem->setText(QString(ss.str().c_str()));
            newItem->setData(Qt::UserRole, QVariant::fromValue((void*) new std::pair<int, GameObject*>(std::make_pair(i, contextObject))));
            newItem->setIcon(QIcon(QPixmap::fromImage(contextObject->getIconImage())));

            ui->listWidgetObject1->addItem(newItem);


            ss.str("");
            ss << QString::fromUtf8("Inst. de Contexto ").toStdString() << contextObjectsSize - i + ajusteIndice << " (" << i << " )";

            newItem = new QListWidgetItem();
            newItem->setText(QString(ss.str().c_str()));
            newItem->setData(Qt::UserRole, QVariant::fromValue((void*) new std::pair<int, GameObject*>(std::make_pair(i, contextObject))));
            newItem->setIcon(QIcon(QPixmap::fromImage(contextObject->getIconImage())));

            ui->listWidgetObject2->addItem(newItem);


        }

        i++;



    }


    ui->listWidgetObject1->setCurrentRow(1);
    ui->listWidgetObject2->setCurrentRow(1);
}

void NewEventDialog::populaComboAtributos() {
    freeAttributeData();
    ui->comboBoxAttrib->clear();


    if(ui->listWidgetObject1->currentItem() != NULL) {
        std::pair<int, GameObject*> *objectPair = (std::pair<int, GameObject*> *) ui->listWidgetObject1->currentItem()->data(Qt::UserRole).value<void*>();
        GameObject *gameObject = objectPair->second;

        if(gameObject != NULL) {
            std::list<EventAttributeData*> listAttributes = eventsEditorController->getComboAttributes(gameObject, type);

            if(!listAttributes.empty()) {
                for(std::list<EventAttributeData*>::iterator it = listAttributes.begin(); it != listAttributes.end(); ++it) {
                    EventAttributeData* eventAttributeData = *it;

                    ui->comboBoxAttrib->addItem(QString(eventAttributeData->name.c_str()), QVariant::fromValue((void*) eventAttributeData));
                }

                ui->groupBoxRel->setVisible(true);
            } else {
                 ui->groupBoxRel->setVisible(false);
            }


        } else {
            ui->groupBoxRel->setVisible(false);
        }

    } else {
        ui->groupBoxRel->setVisible(false);
    }


}

void NewEventDialog::populaComboConditions() {
    ui->comboBoxCondit->clear();

    EventAttributeData *eventAttributeData = (EventAttributeData*)
            ui->comboBoxAttrib->itemData(ui->comboBoxAttrib->currentIndex(), Qt::UserRole).value<void*>();

    if(eventAttributeData != NULL) {

        for(std::list<int>::iterator it = eventAttributeData->conditions->begin(); it != eventAttributeData->conditions->end(); ++it) {
            int index = *it;

            ui->comboBoxCondit->addItem(eventsEditorController->getComboConditionString(index), QVariant::fromValue(index));
        }
    }
}

void NewEventDialog::populaComboActions() {
    ui->comboBoxCondit->clear();

    EventAttributeData *eventAttributeData = (EventAttributeData*)
            ui->comboBoxAttrib->itemData(ui->comboBoxAttrib->currentIndex(), Qt::UserRole).value<void*>();

    if(eventAttributeData != NULL) {

        for(std::list<int>::iterator it = eventAttributeData->actions->begin(); it != eventAttributeData->actions->end(); ++it) {
            int index = *it;

            ui->comboBoxCondit->addItem(eventsEditorController->getComboActionString(index), QVariant::fromValue(index));
        }
    }
}

void NewEventDialog::habilitaGroupValues() {

    EventAttributeData *eventAttributeData = (EventAttributeData*)
            ui->comboBoxAttrib->itemData(ui->comboBoxAttrib->currentIndex(), Qt::UserRole).value<void*>();

    if(eventAttributeData != NULL) {
        ui->groupBoxVal->setVisible(true);

        ui->checkBoxVariable->setVisible(eventAttributeData->showVariableValueCombo);
        ui->comboBoxVariable->setVisible(eventAttributeData->showVariableValueCombo);

        ui->checkBoxNumber->setVisible(eventAttributeData->showVariableValueCombo);
        ui->spinBoxNumber->setVisible(eventAttributeData->showVariableValueCombo);

        ui->checkBoxFieldObject02->setVisible(eventAttributeData->showObjectFieldCombo);
        ui->comboBoxFieldObject2->setVisible(eventAttributeData->showObjectFieldCombo);

        ui->groupBoxObj2->setVisible(eventAttributeData->showObject02);

        if(eventAttributeData->showObject02) {
            ui->groupBoxObj2->setVisible(true);
            populaComboAtributosObject02();
        }

        populaComboVariables();



        switch(eventAttributeData->specialComboType) {
        case 0:
            ui->checkBoxSpecial->setVisible(false);
            ui->comboBoxSpecial->setVisible(false);
            break;

        default:
            ui->checkBoxSpecial->setVisible(true);
            ui->comboBoxSpecial->setVisible(true);
            populaComboSpecial(eventAttributeData->specialComboType);
            break;
        }

        ui->dialDirection->setVisible(eventAttributeData->showDirectionInput);

        int currentOperation = ui->comboBoxCondit->itemData(ui->comboBoxCondit->currentIndex(), Qt::UserRole).value<int>();

        if(type == EventData::TYPE_ACTION) {
            if(eventsEditorController->isNoValueAction(currentOperation)) {
                ui->groupBoxVal->setVisible(false);
            } else {
                ui->groupBoxVal->setVisible(eventAttributeData->showValueGroup());
            }


        } else {
            if(eventsEditorController->isNoValueCondition(currentOperation)) {
                ui->groupBoxVal->setVisible(false);
            } else {
                ui->groupBoxVal->setVisible(eventAttributeData->showValueGroup());
            }
        }
    }




}

void NewEventDialog::populaComboVariables() {
    GameData *gameData = GameData::getInstance();

    ui->comboBoxVariable->clear();

    foreach(VariableData *variableData, *gameData->variableList) {
        std::stringstream ss;
        ss << "(Global)" << variableData->name;
        ui->comboBoxVariable->addItem(QString(ss.str().c_str()), QVariant(variableData->id));
    }

    if(gameObject != NULL) {
        foreach(VariableData *variableData, *gameObject->variableList) {
            ui->comboBoxVariable->addItem(QString(variableData->name.c_str()), QVariant(-variableData->id));
        }


    }
}

void NewEventDialog::populaComboSpecial(int type) {
    ui->comboBoxSpecial->clear();





    std::list<SpecialComboValueData*> specialList = eventsEditorController->getSpecialComboValueList(type, this->gameObject);

    foreach(SpecialComboValueData *special, specialList) {
        ui->comboBoxSpecial->addItem(QString(special->string.c_str()), QVariant::fromValue((void*) special));
    }
}

void NewEventDialog::populaComboAtributosObject02() {
    ui->comboBoxFieldObject2->clear();


    if(ui->listWidgetObject2->currentItem() != NULL) {
        std::pair<int, GameObject*> *objectPair = (std::pair<int, GameObject*> *) ui->listWidgetObject2->currentItem()->data(Qt::UserRole).value<void*>();
        GameObject *gameObject = objectPair->second;

        if(gameObject != NULL) {
            std::list<EventAttributeData*> listAttributes = eventsEditorController->getComboAttributes(gameObject, type);

            if(!listAttributes.empty()) {
                for(std::list<EventAttributeData*>::iterator it = listAttributes.begin(); it != listAttributes.end(); ++it) {
                    EventAttributeData* eventAttributeData = *it;

                    ui->comboBoxFieldObject2->addItem(QString(eventAttributeData->name.c_str()), QVariant::fromValue((void*) eventAttributeData));

                }

            }


        }

    }
}




void NewEventDialog::on_listWidgetObject2_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{


    if(current->data(Qt::UserRole).value<void*>() == NULL) {
        ui->listWidgetObject2->setCurrentItem(previous);
        ui->listWidgetObject2->setItemSelected(previous, true);
        ui->listWidgetObject2->setItemSelected(current, false);
    } else {
        populaComboAtributosObject02();
        populaComboVariables();
    }
}


void NewEventDialog::on_listWidgetObject1_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    if(current->data(Qt::UserRole).value<void*>() == NULL) {
        ui->listWidgetObject1->setCurrentItem(previous);
        ui->listWidgetObject1->setItemSelected(previous, true);
        ui->listWidgetObject1->setItemSelected(current, false);
    } else {
        populaComboAtributos();
        if(type == EventData::TYPE_CONDITION) {
            populaComboConditions();
        } else {
            populaComboActions();
        }
    }




}

void NewEventDialog::on_comboBoxAttrib_currentIndexChanged(int index)
{
    if(type == EventData::TYPE_CONDITION) {
        populaComboConditions();
    } else {
        populaComboActions();
    }
}


void NewEventDialog::on_comboBoxCondit_currentIndexChanged(int index)
{
    habilitaGroupValues();
}



void NewEventDialog::on_checkBoxNumber_toggled(bool checked)
{
    if(checked) {
        ui->checkBoxVariable->setChecked(false);
        ui->checkBoxFieldObject02->setChecked(false);
    }

}

void NewEventDialog::on_checkBoxVariable_toggled(bool checked)
{
    if(checked) {
        ui->checkBoxNumber->setChecked(false);
        ui->checkBoxFieldObject02->setChecked(false);
    }
}

void NewEventDialog::on_checkBoxFieldObject02_toggled(bool checked)
{
    if(checked) {
        ui->checkBoxNumber->setChecked(false);
        ui->checkBoxVariable->setChecked(false);
    }
}



void NewEventDialog::on_buttonBox_2_accepted()
{
    EventAttributeData *attributeData = ((EventAttributeData*) ui->comboBoxAttrib->itemData(ui->comboBoxAttrib->currentIndex(),
                                                        Qt::UserRole).value<void*>());

    int currentOperation = ui->comboBoxCondit->itemData(ui->comboBoxCondit->currentIndex(), Qt::UserRole).value<int>();
    bool isNoAction = false;

    if(type == EventData::TYPE_ACTION) {
        isNoAction = eventsEditorController->isNoValueAction(currentOperation);
    } else {
        isNoAction = eventsEditorController->isNoValueCondition(currentOperation);
    }


    if(!isNoAction && !attributeData->isObjectType() && !attributeData->isNothingType() && !ui->checkBoxFieldObject02->isChecked() &&
            !ui->checkBoxNumber->isChecked() &&
            !ui->checkBoxSpecial->isChecked() &&
            !ui->checkBoxVariable->isChecked()) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Ao menos uma das caixas de valores deve ser marcada."));
        return;
    }

    eventData->newEvent = false;
    eventData->type = type;
    eventData->conditionType = conditionType;

    std::pair<int, GameObject*> *objectPair01 = (std::pair<int, GameObject*> *) ui->listWidgetObject1->currentItem()->data(Qt::UserRole).value<void*>();
    GameObject *gameObject01 = objectPair01->second;
    eventData->idObject01 = gameObject01->id;
    eventData->instanceTypeObject01 = objectPair01->first;
    eventData->opcode = ui->comboBoxCondit->itemData(ui->comboBoxCondit->currentIndex(), Qt::UserRole).value<int>();
    eventData->idAssociatedVariable = ((EventAttributeData*) ui->comboBoxAttrib->itemData(ui->comboBoxAttrib->currentIndex(),
                                                                                          Qt::UserRole).value<void*>())->id;

    std::pair<int, GameObject*> *objectPair02 = (std::pair<int, GameObject*> *) ui->listWidgetObject2->currentItem()->data(Qt::UserRole).value<void*>();
    GameObject *gameObject02 = objectPair02->second;




    // determina inicialmente o valueType como TYPE_OBJECT2, que é o caso de não
    // entrar em nenhum dos ifs a seguir
    eventData->valueType = EventData::VALUE_TYPE_OBJECT2;

//    if(attributeData->isObjectType() || ui->checkBoxFieldObject02->isChecked()) {
//        eventData->idObject02 = gameObject02->id;
//        eventData->instanceTypeObject02 = objectPair02->first;
//    } else {
//        eventData->idObject02 = -1;
//    }

    eventData->idObject02 = gameObject02->id;
    eventData->instanceTypeObject02 = objectPair02->first;


    if(ui->checkBoxNumber->isChecked()) {
         eventData->value01 = ui->spinBoxNumber->value();
         eventData->valueType = EventData::VALUE_TYPE_NUMBER;

    }

    if(ui->checkBoxVariable->isChecked()) {
        eventData->value01 = ui->comboBoxVariable->itemData(ui->comboBoxVariable->currentIndex(), Qt::UserRole).toInt();
        eventData->valueType = EventData::VALUE_TYPE_VARIABLE;
    }

    if(ui->checkBoxFieldObject02->isChecked()) {
        eventData->value01 = ((EventAttributeData*)ui->comboBoxFieldObject2->itemData(ui->comboBoxFieldObject2->currentIndex(), Qt::UserRole).value<void*>())->id;
        eventData->valueType = EventData::VALUE_TYPE_OBJECT_ATTRIBUTE;
    }

    if(ui->checkBoxSpecial->isChecked()) {


        SpecialComboValueData *specialComboValuedata = (SpecialComboValueData*)
                ui->comboBoxSpecial->itemData(ui->comboBoxSpecial->currentIndex(), Qt::UserRole).value<void*>();


        EventAttributeData *eventAttributeData = (EventAttributeData*)
                ui->comboBoxAttrib->itemData(ui->comboBoxAttrib->currentIndex(), Qt::UserRole).value<void*>();


        switch(eventAttributeData->specialComboType) {
        case EventAttributeData::COMBO_TYPE_KEY:
            eventData->value01 = specialComboValuedata->code;
            break;
        case EventAttributeData::COMBO_TYPE_MAP:
            eventData->value01 = specialComboValuedata->code;
            break;
        case EventAttributeData::COMBO_TYPE_MOUSE:
            eventData->value01 = specialComboValuedata->code;
            break;
        case EventAttributeData::COMBO_TYPE_MUSIC:
            eventData->stringValue = specialComboValuedata->string;
            break;
        case EventAttributeData::COMBO_TYPE_SOUND:
            eventData->stringValue = specialComboValuedata->string;
            break;
        case EventAttributeData::COMBO_TYPE_PROCEDURE:
            eventData->value01 = specialComboValuedata->code;
            break;
        }

        eventData->valueType = EventData::VALUE_TYPE_SPECIAL;
    }




    accept();

}

void NewEventDialog::on_buttonBox_2_rejected()
{
    reject();
}
#include "newmapwindow.h"
#include "ui_newmapwindow.h"

NewMapWindow::NewMapWindow(MapEditorController *mapEditorController, Map *parameterMap, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::NewMapWindow)
{
    ui->setupUi(this);
    this->mapEditorController = mapEditorController;

    if(parameterMap == NULL) {
        map = new Map();
        mode = MODE_NEW;
    } else {
        map = parameterMap;
        mode = MODE_EDIT;
    }


    this->ui->tab_geral->map = map;
    this->ui->tab_tilesets->map = map;
    this->ui->tab_objetos->map = map;

    this->ui->tab_geral->preencheDados();

    this->ui->tab_tilesets->populaListaDisponiveis();
    this->ui->tab_tilesets->populaListaEscolhidos();

    this->ui->tab_objetos->populaListaObjetosDisponiveis();
    this->ui->tab_objetos->populaListObjetosEscolhidos();
}

NewMapWindow::~NewMapWindow()
{
    delete ui;
}



void NewMapWindow::changeEvent(QEvent *e)
{
    QDialog::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

void NewMapWindow::on_buttonBox_accepted()
{
    map->mapName = ui->tab_geral->getNomeMapa().toStdString();


    if(mode == MODE_NEW) {
        map->extent(ui->tab_geral->getTamanhoWidth(), ui->tab_geral->getTamanhoHeight(), 1);
        mapEditorController->createNewMap(map);
    } else {
        map->extent(ui->tab_geral->getTamanhoWidth(), ui->tab_geral->getTamanhoHeight(), map->layers);
        mapEditorController->refreshMapWidgets();
    }


}
#include "newmapwindowgeneralwidget.h"
#include "ui_newmapwindowgeneralwidget.h"

NewMapWindowGeneralWidget::NewMapWindowGeneralWidget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::NewMapWindowGeneralWidget)
{
    ui->setupUi(this);


}

void NewMapWindowGeneralWidget::preencheDados() {
    ui->nome_mapa->setText(QString(map->mapName.c_str()));
    ui->tamanho_height->setValue(map->height);
    ui->tamanho_width->setValue(map->width);
    ui->musica_input->setText(QString(map->music.c_str()));
    ui->som_input->setText(QString(map->sound.c_str()));

    if(map->background != NULL) {
        ui->lineEditBackground->setText(QString(map->background->name.c_str()));
    }

}

NewMapWindowGeneralWidget::~NewMapWindowGeneralWidget()
{
    delete ui;
}

void NewMapWindowGeneralWidget::changeEvent(QEvent *e)
{
    QWidget::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

QString NewMapWindowGeneralWidget::getNomeMapa() {
    return ui->nome_mapa->text();
}

int NewMapWindowGeneralWidget::getTamanhoWidth() {
    return ui->tamanho_width->value();
}

int NewMapWindowGeneralWidget::getTamanhoHeight() {
    return ui->tamanho_height->value();
}

void NewMapWindowGeneralWidget::on_toolButtonMusic_clicked()
{
    SoundPickerDialog *soundPickerDialog = new SoundPickerDialog(SoundPickerDialog::MUSICA, this);
    soundPickerDialog->exec();

    if(soundPickerDialog->okPressed()) {
        ui->musica_input->setText(QString(soundPickerDialog->getSelectedFile().c_str()));
        map->music = soundPickerDialog->getSelectedFile();
    }


    delete soundPickerDialog;
}

void NewMapWindowGeneralWidget::on_toolButtonSound_clicked()
{
    SoundPickerDialog *soundPickerDialog = new SoundPickerDialog(SoundPickerDialog::SOM, this);
    soundPickerDialog->exec();

    if(soundPickerDialog->okPressed()) {
        ui->som_input->setText(QString(soundPickerDialog->getSelectedFile().c_str()));
        map->sound = soundPickerDialog->getSelectedFile();
    }

}

void NewMapWindowGeneralWidget::on_toolButtonBackgroundChooser_pressed()
{
    GameData *gameData = GameData::getInstance();
    if(gameData->backgroundList->empty()) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Nao existe nenhum fundo cadastrado."));
    } else {
        BackgroundPickerDialog *backgroundPickerDialog;
        backgroundPickerDialog = new BackgroundPickerDialog(this);
        backgroundPickerDialog->setWindowTitle("Selecionar fundo");

        Background *bg = backgroundPickerDialog->exec();

        if(bg != NULL) {
            ui->lineEditBackground->setText(QString(bg->name.c_str()));
            map->background = bg;
        }
    }
}

void NewMapWindowGeneralWidget::on_toolButtonRemoveBackground_pressed()
{
    if(MessageBoxes::showConfirmBox(std::string("Tem certeza que deseja remover o fundo do mapa?"))) {
        map->background = NULL;
        ui->lineEditBackground->setText(QString(""));
    }

}

void NewMapWindowGeneralWidget::on_toolButtonRemoveMusic_pressed()
{
    if(MessageBoxes::showConfirmBox(std::string("Tem certeza que deseja remover a musica do mapa?"))) {
        map->music = std::string("");
        ui->musica_input->setText(QString(""));
    }
}

void NewMapWindowGeneralWidget::on_toolButtonRemoveSound_pressed()
{
    if(MessageBoxes::showConfirmBox(std::string("Tem certeza que deseja remover o som do mapa?"))) {
        map->sound = std::string("");
        ui->som_input->setText(QString(""));
    }
}
#include "newmapwindowobjectwidget.h"
#include "ui_newmapwindowobjectwidget.h"

NewMapWindowObjectWidget::NewMapWindowObjectWidget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::NewMapWindowObjectWidget)
{
    ui->setupUi(this);
}

NewMapWindowObjectWidget::~NewMapWindowObjectWidget()
{
    delete ui;
}

void NewMapWindowObjectWidget::populaListaObjetosDisponiveis() {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::vector<GameObject*> *objectList;

    objectList = gameData->objectList;

    ui->listObjectsDispon->clear();

    for(std::vector<GameObject*>::iterator it = objectList->begin(); it != objectList->end(); ++it) {
        GameObject *gameObject = *it;

        if(std::find(map->gameObjects->begin(), map->gameObjects->end(), gameObject) == map->gameObjects->end()) {
            QListWidgetItem *newItem = new QListWidgetItem();
            newItem->setText(QString(gameObject->name.c_str()));
            newItem->setData(Qt::UserRole, QVariant::fromValue((void*) gameObject));
            newItem->setIcon(QIcon(QPixmap::fromImage(gameObject->getIconImage())));
            ui->listObjectsDispon->addItem(newItem);
        }
    }
}

void NewMapWindowObjectWidget::populaListObjetosEscolhidos() {
    std::vector<GameObject*> *objectList;

    objectList = map->gameObjects;

    ui->listObjectsEscolhidas->clear();

    for(std::vector<GameObject*>::iterator it = objectList->begin(); it != objectList->end(); ++it) {
        GameObject* gameObject = *it;

        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString(gameObject->name.c_str()));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) gameObject));
        newItem->setIcon(QIcon(QPixmap::fromImage(gameObject->getIconImage())));
        ui->listObjectsEscolhidas->addItem(newItem);
    }
}

void NewMapWindowObjectWidget::on_pushButton_clicked()
{
    QListWidgetItem* currentItem = ui->listObjectsDispon->currentItem();

    if(currentItem != NULL) {
        GameObject* gameObject;
        gameObject = (GameObject*) currentItem->data(Qt::UserRole).value<void*>();
        map->gameObjects->push_back(gameObject);

        populaListaObjetosDisponiveis();
        populaListObjetosEscolhidos();
    }
}
#include "newmapwindowtilesetwidget.h"
#include "ui_newmapwindowtilesetwidget.h"

NewMapWindowTilesetWidget::NewMapWindowTilesetWidget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::NewMapWindowTilesetWidget)
{
    ui->setupUi(this);

}

NewMapWindowTilesetWidget::~NewMapWindowTilesetWidget()
{
    delete ui;
}

void NewMapWindowTilesetWidget::changeEvent(QEvent *e)
{
    QWidget::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

void NewMapWindowTilesetWidget::populaListaDisponiveis() {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::vector<TileSet*>* tileSetList;


    tileSetList = gameData->tileSetList;

    ui->listTilesetsDispon->clear();

    for(std::vector<TileSet*>::iterator it = tileSetList->begin(); it != tileSetList->end(); ++it) {
        TileSet *iterationItem;

        iterationItem = *it;

        if(std::find(map->tileSets->begin(), map->tileSets->end(), iterationItem) == map->tileSets->end()) {
            QListWidgetItem *newItem = new QListWidgetItem();
            newItem->setText(QString(iterationItem->name.c_str()));
            newItem->setData(Qt::UserRole, QVariant::fromValue((void*) iterationItem));
            ui->listTilesetsDispon->addItem(newItem);
        }


    }
}

void NewMapWindowTilesetWidget::populaListaEscolhidos() {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::vector<TileSet*>* tileSetList;


    tileSetList = map->tileSets;

    ui->listTilesetsEscolhidas->clear();

    for(std::vector<TileSet*>::iterator it = tileSetList->begin(); it != tileSetList->end(); ++it) {
        TileSet *iterationItem;

        iterationItem = *it;
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(QString(iterationItem->name.c_str()));
        newItem->setData(Qt::UserRole, QVariant::fromValue((void*) iterationItem));
        ui->listTilesetsEscolhidas->addItem(newItem);

    }
}

void NewMapWindowTilesetWidget::on_pushButton_clicked()
{

    if(ui->listTilesetsDispon->currentItem() != NULL) {
        QList<QListWidgetItem*> selectedItems = ui->listTilesetsDispon->selectedItems();

        TileSet* selectedTileset = (TileSet*) ui->listTilesetsDispon->currentItem()->data(Qt::UserRole).value<void*>();



        // o if abaixo verifica se o selectedTileset não está na lista de tilesets do map
        if(std::find(map->tileSets->begin(), map->tileSets->end(), selectedTileset) == map->tileSets->end()) {
            map->tileSets->push_back(selectedTileset);
        }

        populaListaDisponiveis();
        populaListaEscolhidos();
    }


}
#include "newprojectwindow.h"
#include "ui_newprojectwindow.h"

NewProjectWindow::NewProjectWindow(QWidget *parent, MainController *mainController) :
    QDialog(parent),
    ui(new Ui::NewProjectWindow)
{
    ui->setupUi(this);
    this->mainController = mainController;

    textNomeJogoChanged = false;
    textNomePastaChanged = false;
}

NewProjectWindow::~NewProjectWindow()
{
    delete ui;
}

void NewProjectWindow::changeEvent(QEvent *e)
{
    QDialog::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}

void NewProjectWindow::on_buttonBox_accepted()
{
    if(ui->textNomeJogo->text().isEmpty() || ui->textNomePasta->text().isEmpty()) {
        MessageBoxes::showMessageBox(QString::fromUtf8("Preencha todos os campos."));
        this->show();
    } else {
        mainController->openNewProject(ui->textNomeJogo->text().toStdString(), ui->textNomePasta->text().toStdString());
    }

}

void NewProjectWindow::on_buttonBox_rejected()
{

}

void NewProjectWindow::on_textNomePasta_textChanged(QString )
{
    if(!textNomeJogoChanged) {
        ui->textNomeJogo->setText(ui->textNomePasta->text());
    }
}

void NewProjectWindow::on_textNomeJogo_textChanged(QString )
{
    if(!textNomePastaChanged) {
        ui->textNomePasta->setText(ui->textNomeJogo->text());
    }
}

void NewProjectWindow::on_textNomePasta_textEdited(QString )
{
    textNomePastaChanged = true;
}

void NewProjectWindow::on_textNomeJogo_textEdited(QString )
{
    textNomeJogoChanged = true;
}
#include "newteleportareadialog.h"
#include "ui_newteleportareadialog.h"

NewTeleportAreaDialog::NewTeleportAreaDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::NewTeleportAreaDialog)
{
    ui->setupUi(this);
    teleportArea = new TeleportArea();
    populaComboMapa();
}

NewTeleportAreaDialog::NewTeleportAreaDialog(TeleportArea *teleportArea, QWidget *parent) :
        QDialog(parent),
        ui(new Ui::NewTeleportAreaDialog),
        teleportArea(teleportArea)
{
    ui->setupUi(this);
    populaComboMapa();

    int i;
    for(i = 0; i < ui->comboMap->count(); i++) {
        int id = ui->comboMap->itemData(i).toInt();
        if(id == teleportArea->mapId) {
            ui->comboMap->setCurrentIndex(i);
            break;
        }
    }

    ui->checkBoxMostraAnimVit->setChecked(teleportArea->showVictoryAnimation);

    if(teleportArea->mapPositionDetermined) {
        std::stringstream ss1, ss2;
        ss1 << teleportArea->x;
        ss2 << teleportArea->y;


        ui->lineEditPosX->setText(QString(ss1.str().c_str()));
        ui->lineEditPosY->setText(QString(ss2.str().c_str()));
    }
}

NewTeleportAreaDialog::~NewTeleportAreaDialog()
{
    delete ui;
}

void NewTeleportAreaDialog::populaComboMapa() {
    GameData *gameData = GameData::getInstance();

    ui->comboMap->clear();
    populaComboMapaPercorreArvore(gameData->mapList, std::string(""));
}

void NewTeleportAreaDialog::populaComboMapaPercorreArvore(std::vector<Map*> *mapList, std::string prefix) {
    for(std::vector<Map*>::iterator it = mapList->begin(); it != mapList->end(); ++it) {
        Map* map = *it;
        if(map->isFolder()) {
            populaComboMapaPercorreArvore(map->filhos, std::string(prefix.c_str()).append(map->mapName).append(" > "));
        } else {
            ui->comboMap->addItem(QString(prefix.c_str()).append(map->mapName.c_str()), QVariant(map->key));
            std::cout << "map-key: " << map->key << std::endl;
        }
    }
}

TeleportArea* NewTeleportAreaDialog::exec() {
    if(QDialog::exec()) {
        teleportArea->id = 0;
        teleportArea->mapId = ui->comboMap->itemData(ui->comboMap->currentIndex()).toInt();
        if(ui->lineEditPosX->text().isEmpty()) {
            teleportArea->mapPosX = 0;
        } else {
            teleportArea->mapPosX = ui->lineEditPosX->text().toInt();
        }

        if(ui->lineEditPosY->text().isEmpty()) {
            teleportArea->mapPosY = 0;
        } else {
            teleportArea->mapPosY = ui->lineEditPosY->text().toInt();
        }

        if(ui->lineEditPosX->text().isEmpty() &&
           ui->lineEditPosY->text().isEmpty()) {
            teleportArea->mapPositionDetermined = false;
        } else {
            teleportArea->mapPositionDetermined = true;
        }

        teleportArea->showVictoryAnimation = ui->checkBoxMostraAnimVit->isChecked();

        return teleportArea;
    }

    return NULL;






}
#include "newvariabledialog.h"
#include "ui_newvariabledialog.h"

NewVariableDialog::NewVariableDialog(VariableData *variableData, QWidget *parent) :
    QDialog(parent),
    variableData(variableData),
    ui(new Ui::NewVariableDialog)
{
    ui->setupUi(this);

    habilitaElementos();
    preencheCampos();

}

NewVariableDialog::~NewVariableDialog()
{
    delete ui;
}

VariableData* NewVariableDialog::exec() {
    QDialog::exec();


    return variableData;
}

void NewVariableDialog::habilitaElementos() {
    if(ui->comboBoxVariableType->currentIndex() == 0) {
        ui->spinBoxValue->setVisible(true);
        ui->comboBoxBooleanValue->setVisible(false);
    } else {
        ui->spinBoxValue->setVisible(false);
        ui->comboBoxBooleanValue->setVisible(true);
    }
}

void NewVariableDialog::preencheCampos() {

    if(variableData != NULL) {
        ui->lineEditVariableName->setText(QString(variableData->name.c_str()));
        ui->comboBoxVariableType->setCurrentIndex(variableData->type);
        if(variableData->type == VariableData::TYPE_NUMBER) {
            ui->spinBoxValue->setValue(variableData->value);
        } else {
            ui->comboBoxBooleanValue->setCurrentIndex(!((int) variableData->value));
        }


    }

}

void NewVariableDialog::on_buttonBox_accepted()
{
    if(ui->lineEditVariableName->text().isEmpty()) {
        MessageBoxes::showMessageBox(QString::fromUtf8("É necessário que a variável tenha um nome!"));
        return;
    }

    if(variableData == NULL) {
        variableData = new VariableData();
    }

    variableData->name =ui->lineEditVariableName->text().toStdString();
    variableData->type = ui->comboBoxVariableType->currentIndex();

    if(variableData->type == VariableData::TYPE_NUMBER) {
        variableData->value = ui->spinBoxValue->value();
    } else {
        variableData->value = !ui->comboBoxBooleanValue->currentIndex();
    }


    accept();
}



void NewVariableDialog::on_comboBoxVariableType_currentIndexChanged(int index)
{
    habilitaElementos();
}
#include "objectgraphicsitem.h"

ObjectGraphicsItem::ObjectGraphicsItem(GameObjectInstance *gameObjectInstance,
                                       std::vector<GameObjectInstance *> *mapGameObjectInstances,
                                       MapEditorController *mapEditorController)
{
    this->gameObjectInstance = gameObjectInstance;
    this->image = new QImage(gameObjectInstance->gameObject->getIconImage());
    this->width = image->width();
    this->height = image->height();
    this->setRect(0, 0, width, height);
    this->mapGameObjectInstances = mapGameObjectInstances;
    this->mapEditorController = mapEditorController;

    colorizeEffect = new QGraphicsColorizeEffect();
    colorizeEffect->setColor(QColor(255, 255, 255, 255));
    colorizeEffect->setStrength(0.2);
    colorizeEffect->setEnabled(false);

    setGraphicsEffect(colorizeEffect);
}

void ObjectGraphicsItem::setVisible(bool visible) {
    this->visible = visible;
}

void ObjectGraphicsItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    painter->drawImage(QRectF(0, 0, width, height), *image, QRectF(0, 0,  width, height), NULL);
}

void ObjectGraphicsItem::mouseReleaseEvent(QGraphicsSceneMouseEvent *event) {
    QGraphicsRectItem::mouseReleaseEvent(event);

    gameObjectInstance->x = this->pos().x();
    gameObjectInstance->y = this->pos().y();
}

void ObjectGraphicsItem::updateObjectInstancePosition() {
    gameObjectInstance->x = this->pos().x();
    gameObjectInstance->y = this->pos().y();
}

void ObjectGraphicsItem::setColorizeEffect(bool value) {
    if(value) {
        colorizeEffect->setEnabled(true);
    } else {
        colorizeEffect->setEnabled(false);
    }
}

void ObjectGraphicsItem::contextMenuEvent(QGraphicsSceneContextMenuEvent *event) {
    QMenu menu;
    QAction *mainObjectAction = menu.addAction("Objeto Principal");
    QAction *cameraCenterAction = menu.addAction("Centro da camera");
    menu.addSeparator();
    QAction *editarPropriedadesAction = menu.addAction("Editar propriedades");
    QAction *removeAction = menu.addAction("Remover");


    mainObjectAction->setCheckable(true);
    mainObjectAction->setChecked(gameObjectInstance->isMainObject);
    cameraCenterAction->setCheckable(true);
    cameraCenterAction->setChecked(gameObjectInstance->isCenter);


    QAction *selectedAction = menu.exec(event->screenPos());

    if(selectedAction == mainObjectAction) {
        gameObjectInstance->isMainObject = !gameObjectInstance->isMainObject;


        for(std::vector<GameObjectInstance*>::iterator it = mapGameObjectInstances->begin();
                           it != mapGameObjectInstances->end(); ++it) {
            GameObjectInstance *currentGameObjectInstance = *it;
            if(currentGameObjectInstance != gameObjectInstance) {
                currentGameObjectInstance->isMainObject = false;
            }
        }
    } else if(selectedAction == cameraCenterAction) {
        gameObjectInstance->isCenter = !gameObjectInstance->isCenter;

        for(std::vector<GameObjectInstance*>::iterator it = mapGameObjectInstances->begin();
                           it != mapGameObjectInstances->end(); ++it) {
            GameObjectInstance *currentGameObjectInstance = *it;
            if(currentGameObjectInstance != gameObjectInstance) {
                currentGameObjectInstance->isCenter = false;
            }
        }
    } else if(selectedAction == removeAction) {
        if(MessageBoxes::showConfirmBox(std::string("Deseja mesmo remover?"))) {
            GameData *gameData = GameData::getInstance();
            gameData->editingMap->gameObjectInstances->erase(
                    std::find(gameData->editingMap->gameObjectInstances->begin(),
                              gameData->editingMap->gameObjectInstances->end(),
                              gameObjectInstance));
            /* TODO: se for objeto principal, transferir */

            delete this;
        }


    } else if(selectedAction == editarPropriedadesAction) {
        mapEditorController->openConfigsTabWindow(gameObjectInstance->gameObject);
    }
}
#include "objectsdock.h"
#include "ui_objectsdock.h"

ObjectsDock::ObjectsDock(MapEditorController *mapEditorController, QWidget *parent) :
    QDockWidget(parent),
    ui(new Ui::ObjectsDock), mapEditorController(mapEditorController)
{
    ui->setupUi(this);
    this->widget()->setVisible(false);

    populaArvoreObjetos();
}

ObjectsDock::~ObjectsDock()
{
    delete ui;
}

void ObjectsDock::initDockScene() {
    this->widget()->setVisible(true);
}

void ObjectsDock::populaArvoreObjetos() {
    GameData *gameData = GameData::getInstance();

    std::vector<GameObject*> *objectList;

    objectList = gameData->objectList;

    QTreeWidgetItem *itemPersonagem, *itemNPC, *itemItem, *itemEstatico;

    itemPersonagem = new QTreeWidgetItem((QTreeWidget*)0);
    itemPersonagem->setText(0, QString("Personagem"));
    itemPersonagem->setData(0, Qt::UserRole, QVariant::fromValue((void*) NULL));

    itemNPC = new QTreeWidgetItem((QTreeWidget*)0);
    itemNPC->setText(0, QString("NPC"));
    itemNPC->setData(0, Qt::UserRole, QVariant::fromValue((void*) NULL));

    itemItem = new QTreeWidgetItem((QTreeWidget*)0);
    itemItem->setText(0, QString("Item"));
    itemItem->setData(0, Qt::UserRole, QVariant::fromValue((void*) NULL));

    itemEstatico = new QTreeWidgetItem((QTreeWidget*)0);
    itemEstatico->setText(0, QString("Estatico"));
    itemEstatico->setData(0, Qt::UserRole, QVariant::fromValue((void*) NULL));

    ui->treeWidget->clear();

    ui->treeWidget->addTopLevelItem(itemPersonagem);
    ui->treeWidget->addTopLevelItem(itemNPC);
    ui->treeWidget->addTopLevelItem(itemItem);
    ui->treeWidget->addTopLevelItem(itemEstatico);

    for(std::vector<GameObject*>::iterator it = objectList->begin(); it != objectList->end(); ++it) {
        GameObject* gameObject = *it;

        QTreeWidgetItem *newItem = new QTreeWidgetItem((QTreeWidget*)0);
        newItem->setText(0, QString(gameObject->name.c_str()));
        newItem->setIcon(0, QIcon(QPixmap::fromImage(gameObject->getIconImage())));
        newItem->setData(0, Qt::UserRole, QVariant::fromValue((void*) gameObject));
        itemPersonagem->addChild(newItem);
    }

    ui->treeWidget->expandAll();
}

GameObject* ObjectsDock::getCurrentObject() {
    if(ui->treeWidget->currentItem() != NULL) {
        return (GameObject*) ui->treeWidget->currentItem()->data(0, Qt::UserRole).value<void*>();
    } else {
        return NULL;
    }
}

void ObjectsDock::on_treeWidget_itemClicked(QTreeWidgetItem* item, int column)
{
    mapEditorController->setEditorMode(MapEditorController::MODE_OBJECT);
    mapEditorController->setCurrentObjectAtCursor();
}

void ObjectsDock::on_treeWidget_customContextMenuRequested(QPoint pos)
{
    if(ui->treeWidget->currentItem() != NULL) {
        QMenu menu;
        QAction *editarPropriedadesAction = menu.addAction("Editar propriedades");
        GameObject* gameObject = (GameObject*) ui->treeWidget->currentItem()->data(0, Qt::UserRole).value<void*>();


        if(gameObject != NULL) {
            QAction *selectedAction = menu.exec(QCursor::pos());

            if(selectedAction == editarPropriedadesAction) {
                mapEditorController->openConfigsTabWindow(gameObject);
            }
        }


    }

}

void ObjectsDock::on_pushButtonCreateObject_pressed()
{
    mapEditorController->openEasyNewGameObjectDialog();
    populaArvoreObjetos();

}
#include "optionscontroller.h"

OptionsController::OptionsController()
{
}

void OptionsController::setMainController(MainController *mainController)
{
    this->mainController = mainController;
}

void OptionsController::setEventsEditorController(EventsEditorController *eventsEditorController)
{
    this->eventsEditorController = eventsEditorController;
}

void OptionsController::setGameScreen(std::string fileName, int option) {
    GameData *gameData;
    gameData = GameData::getInstance();

    switch(option) {
    case EditorConstants::IMPORT_OPTION_TITLE_SCREEN:
        gameData->setTitleScreenFile(fileName);
        break;
    case EditorConstants::IMPORT_OPTION_OPTION_SCREEN:
        gameData->setOptionsScreenFile(fileName);
        break;
    case EditorConstants::IMPORT_OPTION_GAME_OVER_SCREEN:
        gameData->setGameOverScreenFile(fileName);
        break;
    }

    this->configsTabWindow->getDadosGeraisTab()->atualizaImagensTelas();

}

void OptionsController::openConfigsTabWindow(QWidget *parent)
{
    this->configsTabWindow = new ConfigsTabWindow(this, eventsEditorController, parent);
    this->configsTabWindow->setWindowTitle(QString::fromUtf8("Configurações"));


    this->configsTabWindow->exec();

    mainController->reloadEditorInterface();
}

void OptionsController::openConfigsTabWindow(QWidget *parent, GameObject *gameObject) {
    this->configsTabWindow = new ConfigsTabWindow(this, eventsEditorController, parent);
    this->configsTabWindow->selectObject(gameObject);

    this->configsTabWindow->exec();

    mainController->reloadEditorInterface();
}

void OptionsController::importResource(std::string filePathToImport, int importType) {
    QFile *qFile = new QFile(filePathToImport.c_str());
    GameData *gameData;
    gameData = GameData::getInstance();

    int posicaoUltimaBarra;

    posicaoUltimaBarra = filePathToImport.find_last_of("/");

    std::string nome_arq = filePathToImport.substr(posicaoUltimaBarra);

    std::string diretorio;

    switch(importType) {
    case ConfigsImportDialog::IMPORT_TILESETS:
        diretorio = gameData->getProjectDirectory().append("/tilesets/");
        break;
    case ConfigsImportDialog::IMPORT_TITLESCREENS:
        diretorio = gameData->getProjectDirectory().append("/images/");
        break;
    case ConfigsImportDialog::IMPORT_ANIMATIONS:
        diretorio = gameData->getProjectDirectory().append("/animations/");
        break;
    case ConfigsImportDialog::IMPORT_SPRITE:
        diretorio = gameData->getProjectDirectory().append("/objects/");
        break;
    case ConfigsImportDialog::IMPORT_BACKGROUND:
        diretorio = gameData->getProjectDirectory().append("/images/");
        break;
    case ConfigsImportDialog::IMPORT_LAYER:
        diretorio = gameData->getProjectDirectory().append("/images/");
        break;
    }



    diretorio.append(nome_arq);

    qFile->copy(QString(diretorio.c_str()));

}

void OptionsController::addTileset(std::string fileName) {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::string filePath;

    filePath.append("tilesets/");
    filePath.append(fileName.c_str());

    TileSet *tileSet;
    tileSet = new TileSet(filePath, 32);

    gameData->addTileset(tileSet);


    configsTabWindow->getTilesetTab()->populaLista();


}

void OptionsController::addAnimation(std::string fileName, int animationImportPattern) {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::string filePath;
    filePath.append("animations/");
    filePath.append(fileName.c_str());

    AnimationData *animationData;
    QImage *image;

    std::stringstream ss;



    switch(animationImportPattern) {
    case 0:
        animationData = new AnimationData();
        animationData->fileName = filePath;
        animationData->name = fileName;

        gameData->addAnimation(animationData);


        break;
    case 1:
        image = new QImage(QString(gameData->getProjectDirectory().append("/").append(filePath).c_str()));
        if(image->width() > 96) {

            int k = 1;

            for(int i = 0; i < 4; i++) {
                for(int j = 0; j < 2; j++) {
                    animationData = new AnimationData();
                    animationData->fileName = filePath;
                    ss.str("");
                    ss << fileName << " (" << k << ")" << " Parado Baixo";
                    animationData->name = ss.str();

                    animationData->setHorizontalFrameNumber(12);
                    animationData->setVerticalFrameNumber(8);
                    animationData->startX = 2 + i*3;
                    animationData->endX = 2 + i*3;
                    animationData->startY = 1 + j*4;
                    animationData->endY = 1 + j*4;

                    gameData->addAnimation(animationData);

                    animationData = new AnimationData();
                    animationData->fileName = filePath;
                    ss.str("");
                    ss << fileName << " (" << k << ")" << " Parado Esquerda";
                    animationData->name = ss.str();

                    animationData->setHorizontalFrameNumber(12);
                    animationData->setVerticalFrameNumber(8);
                    animationData->startX = 2 + i*3;
                    animationData->endX = 2 + i*3;
                    animationData->startY = 2 + j*4;
                    animationData->endY = 2 + j*4;

                    gameData->addAnimation(animationData);

                    animationData = new AnimationData();
                    animationData->fileName = filePath;
                    ss.str("");
                    ss << fileName << " (" << k << ")" << " Parado Direita";
                    animationData->name = ss.str();

                    animationData->setHorizontalFrameNumber(12);
                    animationData->setVerticalFrameNumber(8);
                    animationData->startX = 2 + i*3;
                    animationData->endX = 2 + i*3;
                    animationData->startY = 3 + j*4;
                    animationData->endY = 3 + j*4;

                    gameData->addAnimation(animationData);

                    animationData = new AnimationData();
                    animationData->fileName = filePath;
                    ss.str("");
                    ss << fileName << " (" << k << ")" << " Parado Cima";
                    animationData->name = ss.str();

                    animationData->setHorizontalFrameNumber(12);
                    animationData->setVerticalFrameNumber(8);
                    animationData->startX = 2 + i*3;
                    animationData->endX = 2 + i*3;
                    animationData->startY = 4 + j*4;
                    animationData->endY = 4 + j*4;

                    gameData->addAnimation(animationData);

                    animationData = new AnimationData();
                    animationData->fileName = filePath;
                    ss.str("");
                    ss << fileName << " (" << k << ")" << " Andando Baixo";
                    animationData->name = ss.str();

                    animationData->setHorizontalFrameNumber(12);
                    animationData->setVerticalFrameNumber(8);
                    animationData->startX = 1 + i*3;
                    animationData->endX = 3 + i*3;
                    animationData->startY = 1 + j*4;
                    animationData->endY = 1 + j*4;

                    gameData->addAnimation(animationData);

                    animationData = new AnimationData();
                    animationData->fileName = filePath;
                    ss.str("");
                    ss << fileName << " (" << k << ")" << " Andando Esquerda";
                    animationData->name = ss.str();

                    animationData->setHorizontalFrameNumber(12);
                    animationData->setVerticalFrameNumber(8);
                    animationData->startX = 1 + i*3;
                    animationData->endX = 3 + i*3;
                    animationData->startY = 2 + j*4;
                    animationData->endY = 2 + j*4;

                    gameData->addAnimation(animationData);

                    animationData = new AnimationData();
                    animationData->fileName = filePath;
                    ss.str("");
                    ss << fileName << " (" << k << ")" << " Andando Direita";
                    animationData->name = ss.str();

                    animationData->setHorizontalFrameNumber(12);
                    animationData->setVerticalFrameNumber(8);
                    animationData->startX = 1 + i*3;
                    animationData->endX = 3 + i*3;
                    animationData->startY = 3 + j*4;
                    animationData->endY = 3 + j*4;

                    gameData->addAnimation(animationData);

                    animationData = new AnimationData();
                    animationData->fileName = filePath;
                    ss.str("");
                    ss << fileName << " (" << k << ")" << " Andando Cima";
                    animationData->name = ss.str();

                    animationData->setHorizontalFrameNumber(12);
                    animationData->setVerticalFrameNumber(8);
                    animationData->startX = 1 + i*3;
                    animationData->endX = 3 + i*3;
                    animationData->startY = 4 + j*4;
                    animationData->endY = 4 + j*4;

                    gameData->addAnimation(animationData);

                    animationData = new AnimationData();
                    animationData->fileName = filePath;
                    ss.str("");
                    ss << fileName << " (" << k << ")" << " Girando";
                    animationData->name = ss.str();

                    animationData->setHorizontalFrameNumber(12);
                    animationData->setVerticalFrameNumber(8);
                    animationData->startX = 2 + i*3;
                    animationData->endX = 2 + i*3;
                    animationData->startY = 1 + j*4;
                    animationData->endY = 4 + j*4;

                    animationData->velocity = 90;

                    gameData->addAnimation(animationData);





                    k++;
                }
            }


        } else {
            animationData = new AnimationData();
            animationData->fileName = filePath;
            ss.str("");
            ss << fileName << " Parado Baixo";
            animationData->name = ss.str();

            animationData->setHorizontalFrameNumber(3);
            animationData->setVerticalFrameNumber(4);
            animationData->startX = 2;
            animationData->endX = 2;
            animationData->startY = 1;
            animationData->endY = 1;

            gameData->addAnimation(animationData);

            animationData = new AnimationData();
            animationData->fileName = filePath;
            ss.str("");
            ss << fileName <<  " Parado Esquerda";
            animationData->name = ss.str();

            animationData->setHorizontalFrameNumber(3);
            animationData->setVerticalFrameNumber(4);
            animationData->startX = 2;
            animationData->endX = 2;
            animationData->startY = 2;
            animationData->endY = 2;

            gameData->addAnimation(animationData);

            animationData = new AnimationData();
            animationData->fileName = filePath;
            ss.str("");
            ss << fileName << " Parado Direita";
            animationData->name = ss.str();

            animationData->setHorizontalFrameNumber(3);
            animationData->setVerticalFrameNumber(4);
            animationData->startX = 2;
            animationData->endX = 2;
            animationData->startY = 3;
            animationData->endY = 3;

            gameData->addAnimation(animationData);

            animationData = new AnimationData();
            animationData->fileName = filePath;
            ss.str("");
            ss << fileName << " Parado Cima";
            animationData->name = ss.str();

            animationData->setHorizontalFrameNumber(3);
            animationData->setVerticalFrameNumber(4);
            animationData->startX = 2;
            animationData->endX = 2;
            animationData->startY = 4;
            animationData->endY = 4;

            gameData->addAnimation(animationData);

            animationData = new AnimationData();
            animationData->fileName = filePath;
            ss.str("");
            ss << fileName << " Andando Baixo";
            animationData->name = ss.str();

            animationData->setHorizontalFrameNumber(3);
            animationData->setVerticalFrameNumber(4);
            animationData->startX = 1;
            animationData->endX = 3;
            animationData->startY = 1;
            animationData->endY = 1;

            gameData->addAnimation(animationData);

            animationData = new AnimationData();
            animationData->fileName = filePath;
            ss.str("");
            ss << fileName << " Andando Esquerda";
            animationData->name = ss.str();

            animationData->setHorizontalFrameNumber(3);
            animationData->setVerticalFrameNumber(4);
            animationData->startX = 1;
            animationData->endX = 3;
            animationData->startY = 2;
            animationData->endY = 2;

            gameData->addAnimation(animationData);

            animationData = new AnimationData();
            animationData->fileName = filePath;
            ss.str("");
            ss << fileName <<  " Andando Direita";
            animationData->name = ss.str();

            animationData->setHorizontalFrameNumber(3);
            animationData->setVerticalFrameNumber(4);
            animationData->startX = 1;
            animationData->endX = 3;
            animationData->startY = 3;
            animationData->endY = 3;

            gameData->addAnimation(animationData);

            animationData = new AnimationData();
            animationData->fileName = filePath;
            ss.str("");
            ss << fileName << " Andando Cima";
            animationData->name = ss.str();

            animationData->setHorizontalFrameNumber(3);
            animationData->setVerticalFrameNumber(4);
            animationData->startX = 1;
            animationData->endX = 3;
            animationData->startY = 4;
            animationData->endY = 4;

            gameData->addAnimation(animationData);

            animationData = new AnimationData();
            animationData->fileName = filePath;
            ss.str("");
            ss << fileName <<  " Girando";
            animationData->name = ss.str();

            animationData->setHorizontalFrameNumber(3);
            animationData->setVerticalFrameNumber(4);
            animationData->startX = 2;
            animationData->endX = 2;
            animationData->startY = 1;
            animationData->endY = 4;

            animationData->velocity = 90;

            gameData->addAnimation(animationData);
        }


        break;
    default:

        break;
    }

    configsTabWindow->getAnimationsTab()->populaListaAnimation();


}

void OptionsController::addBackground(std::string fileName) {
    GameData *gameData;
    gameData = GameData::getInstance();

    std::string filePath;
    filePath.append("images/");
    filePath.append(fileName.c_str());

    Background *background = new Background();
    background->name = fileName;

    BgLayer *bgLayer = new BgLayer();
    bgLayer->fileName = filePath;

    background->layerList->push_back(bgLayer);

    gameData->addBackground(background);

    configsTabWindow->getBackgroundsTab()->populaListaBackgrounds(false);

}

void OptionsController::addObjectSkill(GameObject *gameObject, SkillData *skillData) {
    int id = 0;

    for(std::vector<SkillData*>::iterator it = gameObject->listaHabilidades.begin(); it != gameObject->listaHabilidades.end(); it++) {
        SkillData *skillDataIt = *it;

        if(skillDataIt->id > id) {
            id = skillDataIt->id;
        }

    }

    skillData->id = id + 1;

    gameObject->listaHabilidades.push_back(skillData);
}

void OptionsController::removeObjectSkill(GameObject *gameObject, SkillData *skillData) {
    gameObject->listaHabilidades.erase(std::find(gameObject->listaHabilidades.begin(), gameObject->listaHabilidades.end(), skillData));

}

void OptionsController::addObject(std::string name, int type) {
    GameData *gameData;
    gameData = GameData::getInstance();

    GameObject *gameObject;
    gameObject = new GameObject();

    gameObject->name = name;
    gameObject->type = type;

    gameData->addGameObject(gameObject);
    configsTabWindow->getObjectTab()->populaListaPersonagem();

}

void OptionsController::determinaValorResolucaoCombo(int index) {
    GameData *gameData = GameData::getInstance();

    switch(index) {
    case 0:
        gameData->resWidth = 320;
        gameData->resHeight = 240;
        break;
    case 1:
        gameData->resWidth = 640;
        gameData->resHeight = 480;
        break;
    case 2:
        gameData->resWidth = 640;
        gameData->resHeight = 400;
        break;
    case 3:
        gameData->resWidth = 800;
        gameData->resHeight = 600;
        break;
    case 4:
        gameData->resWidth = 1024;
        gameData->resHeight = 786;
        break;
    case 5:
        gameData->resWidth = 1280;
        gameData->resHeight = 800;
        break;
    }
}

void OptionsController::openEasyNewGameObjectDialog() {
    EasyNewGameObjectDialog *easyNewGameObjectDialog = new EasyNewGameObjectDialog(this);
    easyNewGameObjectDialog->setWindowTitle(QString("Criar objeto"));
    GameObject *gameObject = easyNewGameObjectDialog->exec();

    delete easyNewGameObjectDialog;

    if(gameObject != NULL) {
        GameData *gameData = GameData::getInstance();

        gameData->addGameObject(gameObject);
    }
}
#include "point.h"

Point::Point()
{
    z = NULL;
    x = 0;
    y = 0;
}

Point::Point(int x, int y) : x(x), y(y), z(NULL)
{
}
#include "proceduredata.h"

ProcedureData::ProcedureData()
{
    EventData *nextEvent = new EventData();
    events.push_back(nextEvent);
    nameEditable = true;
}
#include "project.h"

Project* Project::singleton = NULL;

Project::Project()
{
}

Project *Project::getInstance() {
    if(singleton == NULL) singleton = new Project();

    return singleton;
}

void Project::newProject() {
    gameData = GameData::getInstance();
}
#include "skill.h"

Skill::Skill(int id, std::string name, std::string description, std::vector<int> objectTypes, bool hasObject, bool hasIntensity)
    : id(id), name(name), description(description), objectTypes(objectTypes), hasObject(hasObject), hasIntensity(hasIntensity) {
}

std::vector<Skill*>* Skill::getEditorSkills() {
    std::vector<Skill*> *skillList;


    skillList = new std::vector<Skill*>();

    skillList->push_back(createSkill(0, "Atira objeto", "", true, true, 6,
                GameObject::CAR_MOVEMENT_OBJECT,
                GameObject::EIGHT_MOVEMENT_OBJECT,
                GameObject::FIGHTING_MOVEMENT_OBJECT,
                GameObject::MOUSE_MOVEMENT_OBJECT,
                GameObject::PLATFORM_MOVEMENT_OBJECT,
                GameObject::PONG_BALL_OBJECT));

    skillList->push_back(createSkill(1, "Atira objeto (clique)", "", true, true, 6,
                GameObject::CAR_MOVEMENT_OBJECT,
                GameObject::EIGHT_MOVEMENT_OBJECT,
                GameObject::FIGHTING_MOVEMENT_OBJECT,
                GameObject::MOUSE_MOVEMENT_OBJECT,
                GameObject::PLATFORM_MOVEMENT_OBJECT,
                GameObject::PONG_BALL_OBJECT));

    skillList->push_back(createSkill(2, "Usa espada", "", true, false, 6,
                GameObject::CAR_MOVEMENT_OBJECT,
                GameObject::EIGHT_MOVEMENT_OBJECT,
                GameObject::FIGHTING_MOVEMENT_OBJECT,
                GameObject::MOUSE_MOVEMENT_OBJECT,
                GameObject::PLATFORM_MOVEMENT_OBJECT,
                GameObject::PONG_BALL_OBJECT));

    skillList->push_back(createSkill(3, "Pulo", "", false, true, 2,
                GameObject::CAR_MOVEMENT_OBJECT,
                GameObject::EIGHT_MOVEMENT_OBJECT));

    skillList->push_back(createSkill(4, "Pulo duplo", "", false, true, 4,
                GameObject::CAR_MOVEMENT_OBJECT,
                GameObject::EIGHT_MOVEMENT_OBJECT,
                GameObject::FIGHTING_MOVEMENT_OBJECT,
                GameObject::PLATFORM_MOVEMENT_OBJECT));

    skillList->push_back(createSkill(5, "Correr", "", false, true, 6,
                GameObject::CAR_MOVEMENT_OBJECT,
                GameObject::EIGHT_MOVEMENT_OBJECT,
                GameObject::FIGHTING_MOVEMENT_OBJECT,
                GameObject::MOUSE_MOVEMENT_OBJECT,
                GameObject::PLATFORM_MOVEMENT_OBJECT,
                GameObject::PONG_BALL_OBJECT));

    skillList->push_back(createSkill(6, "Quicar paredes", "", false, true, 1,
                GameObject::PLATFORM_MOVEMENT_OBJECT));

    skillList->push_back(createSkill(7, "Planar", "", false, true, 4,
                GameObject::CAR_MOVEMENT_OBJECT,
                GameObject::EIGHT_MOVEMENT_OBJECT,
                GameObject::FIGHTING_MOVEMENT_OBJECT,
                GameObject::PLATFORM_MOVEMENT_OBJECT));

    skillList->push_back(createSkill(8, "Voar", "", false, true, 4,
                GameObject::CAR_MOVEMENT_OBJECT,
                GameObject::EIGHT_MOVEMENT_OBJECT,
                GameObject::FIGHTING_MOVEMENT_OBJECT,
                GameObject::PLATFORM_MOVEMENT_OBJECT));


    return skillList;
}

Skill* Skill::createSkill(int id, std::string name, std::string description, bool hasObject, bool hasIntensity, int count, ...) {
    va_list objectTypeArgs;
    va_start(objectTypeArgs, count);

    std::vector<int> objectTypes;

    for(int i = 0; i < count; i++) {
        int arg = va_arg(objectTypeArgs, int);
        objectTypes.push_back(arg);

    }

    Skill *skill = new Skill(id, name, description, objectTypes, hasObject, hasIntensity);

    return skill;
}

bool Skill::containsObjectType(int type) {
    for(std::vector<int>::iterator it = objectTypes.begin(); it != objectTypes.end(); ++it) {
        int value = *it;

        if(value == type) {
            return true;
        }
    }

    return false;
}
#include "skilldata.h"

SkillData::SkillData()
{
}
#include "soundpickerdialog.h"
#include "ui_soundpickerdialog.h"

SoundPickerDialog::SoundPickerDialog(int tipo, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::SoundPickerDialog)
{
    ui->setupUi(this);
    setWindowTitle(QString("Escolher som/musica."));

    populaListaMusica();
    populaListaSom();
    selectedMusicFile = std::string("");
    selectedSoundFile = std::string("");

    if(tipo == MUSICA) {
        ui->tabWidget->setCurrentIndex(MUSICA);
        ui->tab_sound->setEnabled(false);
        ui->tabWidget->removeTab(SOM);
    } else {
        ui->tabWidget->setCurrentIndex(SOM);
        ui->tab_music->setEnabled(false);
        ui->tabWidget->removeTab(MUSICA);
    }

    this->type = tipo;
    ok = false;
    sound = NULL;
}

SoundPickerDialog::~SoundPickerDialog()
{
    delete ui;
}


void SoundPickerDialog::populaListaSom() {
    GameData *gameData;
    gameData = GameData::getInstance();

    QDir *dir;
    QStringList files;
    QStringList filters;


    dir = new QDir(gameData->getProjectDirectory().append("/sfx/").c_str());
    filters << "*.wav" << "*.mp3" << "*.gif" << "*.bmp";


    dir->setNameFilters(filters);

    files = dir->entryList();


    ui->listWidgetSound->clear();
    for(QStringList::Iterator it = files.begin(); it != files.end(); ++it) {
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(*it);
        ui->listWidgetSound->addItem(newItem);
    }
}

void SoundPickerDialog::populaListaMusica() {
    GameData *gameData;
    gameData = GameData::getInstance();

    QDir *dir;
    QStringList files;
    QStringList filters;


    dir = new QDir(gameData->getProjectDirectory().append("/musics/").c_str());
    filters << "*.wav" << "*.mp3" << "*.gif" << "*.bmp";
    std::cout << gameData->getProjectDirectory().append("/musics/");


    dir->setNameFilters(filters);

    files = dir->entryList();


    ui->listWidgetMusic->clear();
    for(QStringList::Iterator it = files.begin(); it != files.end(); ++it) {
        QListWidgetItem *newItem = new QListWidgetItem();
        newItem->setText(*it);
        ui->listWidgetMusic->addItem(newItem);
    }
}

/**
  Botão de selecionar
  */
void SoundPickerDialog::on_pushButton_4_clicked()
{
    ok = true;
    this->close();
}

/**
  Botão de importar
  */
void SoundPickerDialog::on_pushButton_5_clicked()
{
    GameData *gameData = GameData::getInstance();
    QStringList fileNames;


    fileNames = QFileDialog::getOpenFileNames(this, tr("Importar Musica"), "", tr("(*.wav *.mp3)"));


    for(QStringList::Iterator it = fileNames.begin(); it != fileNames.end(); ++it) {
        QString fileName = *it;

        if(!fileName.isEmpty()) {
            int posicaoUltimaBarra;

            posicaoUltimaBarra = fileName.toStdString().find_last_of("/");

            std::string nome_arq = fileName.toStdString().substr(posicaoUltimaBarra);

            std::string diretorio;

            switch(ui->tabWidget->currentIndex()) {
            case 0:
                diretorio = gameData->getProjectDirectory().append("/musics/");
                break;

            case 1:
                diretorio = gameData->getProjectDirectory().append("/sfx/");

                break;
            }

            diretorio.append(nome_arq);

            QFile *file = new QFile(fileName);
            file->copy(diretorio.c_str());

            switch(ui->tabWidget->currentIndex()) {
            case 0:
                populaListaMusica();
                break;

            case 1:
                populaListaSom();
                break;
            }


        }
    }
}

/**
  Botão de cancelar
  */
void SoundPickerDialog::on_pushButton_6_clicked()
{

    this->close();
}

/**
  Botão de tocar
  */
void SoundPickerDialog::on_pushButton_clicked()
{
    GameData *gameData = GameData::getInstance();

    std::string diretorio;
    switch(type) {
    case MUSICA:
        diretorio = gameData->getProjectDirectory().append("/musics/");
        if(ui->listWidgetMusic->currentItem() != NULL) {
            diretorio.append(ui->listWidgetMusic->currentItem()->text().toStdString());
        }
        break;

    case SOM:
        diretorio = gameData->getProjectDirectory().append("/sfx/");
        if(ui->listWidgetSound->currentItem() != NULL) {
            diretorio.append(ui->listWidgetMusic->currentItem()->text().toStdString());
        }
        break;
    }


    // TODO: tocar o som do diretorio aqui

}

/**
  Botão de pausar
  */
void SoundPickerDialog::on_pushButton_3_clicked()
{

}

/**
  Botão de parar
  */
void SoundPickerDialog::on_pushButton_2_clicked()
{

}

void SoundPickerDialog::on_listWidgetMusic_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    selectedMusicFile = current->text().toStdString();
}

std::string SoundPickerDialog::getSelectedFile() {
    switch(type) {
    case MUSICA:
        return selectedMusicFile;
        break;

    case SOM:
        return selectedSoundFile;
        break;
    }

    return selectedMusicFile;
}

void SoundPickerDialog::on_listWidgetSound_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous)
{
    selectedSoundFile = current->text().toStdString();
}

bool SoundPickerDialog::okPressed() {
    return ok;
}
#include "specialcombovaluedata.h"

SpecialComboValueData::SpecialComboValueData()
{
}
#include "sprite.h"

Sprite::Sprite()
{
    activated = false;
    hascolorkey = false;
}
#include "teleportarea.h"

TeleportArea::TeleportArea()
{
}
#include "teleportareagraphicsitem.h"

TeleportAreaGraphicsItem::TeleportAreaGraphicsItem()
{
    littleBoxAtTopLeft = NULL;
}

void TeleportAreaGraphicsItem::addLittleBoxAtTopLeftMarkToScene(QGraphicsScene *graphicsScene) {
    littleBoxAtTopLeft = graphicsScene->addRect(this->rect().x(), this->rect().y(), 15, 20, QPen(QColor(0, 0, 180, 255)), QBrush(QColor(0, 0, 255, 255)));
    std::cout << this->x() << std::endl;
    std::cout << this->y() << std::endl;


    rectText = new QGraphicsTextItem();
    rectText->setHtml(QString("<strong>T</strong>"));
    rectText->setPos(this->rect().x(), this->rect().y());
    rectText->setDefaultTextColor(QColor(255, 255, 255, 255));

    graphicsScene->addItem(rectText);



}

void TeleportAreaGraphicsItem::contextMenuEvent(QGraphicsSceneContextMenuEvent *event) {
    QGraphicsRectItem::contextMenuEvent(event);

    QMenu menu;
    QAction *actionEdit = menu.addAction("Editar teletransporte");
    QAction *actionRemove = menu.addAction("Remover teletransporte");

    QAction *selectedAction = menu.exec(event->screenPos());

    if(selectedAction == actionEdit) {
        NewTeleportAreaDialog *newTeleportAreaDialog = new NewTeleportAreaDialog(teleportArea);
        teleportArea = newTeleportAreaDialog->exec();

        delete newTeleportAreaDialog;
    } else if(selectedAction == actionRemove) {
        // TODO: melhorar isso aqui depois, ficou meio tosco
        if(MessageBoxes::showConfirmBox(std::string("Deseja mesmo remover?"))) {
            GameData *gameData = GameData::getInstance();
            gameData->editingMap->teleportAreas->erase(
                    std::find(gameData->editingMap->teleportAreas->begin(),
                              gameData->editingMap->teleportAreas->end(),
                              teleportArea));


            delete this;
            delete littleBoxAtTopLeft;
            delete rectText;
        }

    }
}
#include "tileitem.h"

TileItem::TileItem(TilemapGridVisual *mapGridVisual, int i, int j)
{
    this->image = mapGridVisual->image;
    this->size = mapGridVisual->tileSize;
    this->i = i;
    this->j = j;
    this->visible = true;

    setRect(0, 0, size, size);


}

TileItem::TileItem(QImage *image, int size, int i, int j)
{
    this->image = image;
    this->size = size;
    this->i = i;
    this->j = j;
    this->visible = true;


    setRect(0, 0, size, size);
}

void TileItem::updateTileset(TileSet *tileset) {
    if(tileset != NULL)
        this->image = tileset->tilesetImage;
}

void TileItem::updateTile(int i, int j, TileSet *tileset)
{
    this->i = i;
    this->j = j;

    GameData *gameData = GameData::getInstance();


    if(tileset != NULL) {
        this->image = tileset->tilesetImage;
    } else {
        this->image = NULL;
    }


}

bool TileItem::isVisible() {
    return visible;
}

void TileItem::setVisible(bool visibility) {
    this->visible = visibility;
}

void TileItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    if(i >= 0 && j >= 0 && visible)
        painter->drawImage(QRectF(0, 0, size, size), *image, QRectF(i*size,j*size, size, size), NULL);


}
#include "tilemapgridvisual.h"

TilemapGridVisual::TilemapGridVisual(QGraphicsScene *scene, QImage *image,
                                 int tileSize, int width, int height, int layers)
{


    this->image = image;
    this->tileSize = tileSize;
    this->scene = scene;
    this->layers = layers;

    this->width = width;
    this->height = height;
    int i, j;


    GameData *gameData = GameData::getInstance();

    tileMap.resize(boost::extents[width][height][layers]);

    for(i = 0; i < width; i++) {
        for(j = 0; j < height; j++) {
            for(int z = 0; z < layers; z++) {
                tileMap[i][j][z] = new TileItem(this, gameData->editingMap->map[i][j][z].x, gameData->editingMap->map[i][j][z].y);
                tileMap[i][j][z]->setPos(i*tileSize, j*tileSize);
                tileMap[i][j][z]->updateTileset(gameData->editingMap->map[i][j][z].z);
                tileMap[i][j][z]->setZValue(2*z);
            }
        }
    }

    addTilesToScene();

    linesGenerator = new TilesetLinesGenerator(scene, tileSize, width, height, Qt::DotLine);


}

void TilemapGridVisual::addTilesToScene() {
    int i, j, z;

    for(i = 0; i < width; i++)
        for(j = 0; j < height; j++)
            for(z = 0; z < layers; z++)
                scene->addItem(tileMap[i][j][z]);
}


void TilemapGridVisual::changeTile(int i, int j, int tileI, int tileJ, int layer, TileSet *tileset) {
    if(i >= 0 && j >= 0 && i < width && j < height && tileI >= 0 && tileJ >= 0 && tileset != NULL) {
        tileMap[i][j][layer]->updateTile(tileI, tileJ, tileset);
    }


    if((tileI < 0 || tileJ < 0) && tileset == NULL) {
        tileMap[i][j][layer]->updateTile(tileI, tileJ, tileset);
    }

}

bool TilemapGridVisual::isVisible() {
    return visible;
}

void TilemapGridVisual::setVisible(bool visibility) {
    int i, j;

    for(i = 0; i < width; i++) {
        for(j = 0; j < width; i++) {
            tileMap[i][j][0]->setVisible(visibility);
        }
    }

    visible = visibility;
}

void TilemapGridVisual::setOpacity(float opacity) {
    for(int i = 0; i < width; i++) {
        for(int j = 0; j < height; j++) {
            tileMap[i][j][0]->setOpacity(opacity);

        }
    }
}

int TilemapGridVisual::getLayerCount() {
    return layers;
}

void TilemapGridVisual::expandLayer() {
    GameData *gameData = GameData::getInstance();

    layers++;
    tileMap.resize(boost::extents[width][height][layers]);

    int z = layers - 1;
    for(int i = 0; i < width; i++) {
        for(int j = 0; j < height; j++) {
            tileMap[i][j][z] = new TileItem(this, gameData->editingMap->map[i][j][z].x, gameData->editingMap->map[i][j][z].y);
            tileMap[i][j][z]->setPos(i*tileSize, j*tileSize);
            tileMap[i][j][z]->updateTileset(gameData->editingMap->map[i][j][z].z);
            tileMap[i][j][z]->setZValue(2*z);
            scene->addItem(tileMap[i][j][z]);
        }
    }

}
#include "tilemapscene.h"

TilemapScene::TilemapScene(int size, int width,
                           int height, int layers, MapEditorController *mapEditorController) : QGraphicsScene()
{
    GameData *gameData = GameData::getInstance();
    this->mapEditorController = mapEditorController;

    setSceneRect(0, 0, size*width, size*height);
    mapGridVisual = new TilemapGridVisual(this, new QImage("tile_example.png"), size, width, height, layers);
    //gridView->addTilesToScene();

    //shape = addRect(3, 3, size-6, size-6, QPen(), QBrush(QColor(0, 0, 255, 255), Qt::SolidPattern));
    shape1 = addRect(3, 3, size-6, size-6, QPen(QColor(255, 255, 255, 255)));
    shape2 = addRect(2, 2, size-4, size-4, QPen());


    shape1->setOpacity(1);




    currentObjectItem = NULL;



    shape1->setZValue(30);
    shape2->setZValue(30);
    mousePressed = false;

    setEditorMode(mapEditorController->editorMode);

    /* carregando objetos para a tela */
    gameObjectInstances = gameData->editingMap->gameObjectInstances;
    for(std::vector<GameObjectInstance*>::iterator it = gameObjectInstances->begin(); it != gameObjectInstances->end(); ++it) {
        GameObjectInstance *gameObjectInstance = *it;

        ObjectGraphicsItem *item = new ObjectGraphicsItem(gameObjectInstance, gameObjectInstances, mapEditorController);
        item->setFlag(QGraphicsItem::ItemIsMovable);
        item->setFlag(QGraphicsItem::ItemIsSelectable);
        item->setZValue(35);
        item->setPos(gameObjectInstance->x, gameObjectInstance->y);
        this->addItem(item);
    }

    objectSelectionShape = NULL;

    teleportAreaGraphicsItems = new std::vector<TeleportAreaGraphicsItem*>();
    std::vector<TeleportArea*> *teleportAreas = gameData->editingMap->teleportAreas;
    for(std::vector<TeleportArea*>::iterator it = teleportAreas->begin(); it != teleportAreas->end(); ++it) {
        TeleportArea *teleportArea = *it;

        TeleportAreaGraphicsItem *teleportAreaGraphicsItem;
        teleportAreaGraphicsItem = new TeleportAreaGraphicsItem();
        teleportAreaGraphicsItem->setRect(teleportArea->x, teleportArea->y, teleportArea->w, teleportArea->h);
        teleportAreaGraphicsItem->setPen(QPen(QColor(0, 0, 255, 255)));
        teleportAreaGraphicsItem->setBrush(QBrush(QColor(0, 0, 255, 30)));

        addItem(teleportAreaGraphicsItem);

        teleportAreaGraphicsItem->addLittleBoxAtTopLeftMarkToScene(this);

        teleportAreaGraphicsItem->teleportArea = teleportArea;

        teleportAreaGraphicsItems->push_back(teleportAreaGraphicsItem);

    }

    layerRect = new QGraphicsRectItem(QRectF(0, 0, width*size, height*size), 0, this);
    layerRect->setBrush(QBrush(QColor(255, 255, 255, 150)));
    layerRect->setZValue(-1);
    addItem(layerRect);
}


void TilemapScene::mousePressEvent(QGraphicsSceneMouseEvent *event) {
    QGraphicsScene::mousePressEvent(event);


    int i, j;
    if(event->button() == Qt::LeftButton) {
        switch(mapEditorController->drawMode) {
        case MapEditorController::DRAW_MODE_PAINT:
        case MapEditorController::DRAW_MODE_ERASER:
        case MapEditorController::DRAW_MODE_PENCIL:
            mousePressed = true;
            if(mapEditorController->editorMode == MapEditorController::MODE_MAP) {

                i = floor(event->scenePos().x()/32);
                j = floor(event->scenePos().y()/32);

                mapEditorController->iClick = i;
                mapEditorController->jClick = j;

                mapEditorController->changeTile(i, j);
                break;
            }
        case MapEditorController::DRAW_MODE_SQUARE:
            i = floor(event->scenePos().x()/32);
            j = floor(event->scenePos().y()/32);

            mapEditorController->iClick = i;
            mapEditorController->jClick = j;

            squareCircleDrawStartPosition = event->scenePos();
            mousePressed = true;

            break;

        }



    } else if(mapEditorController->editorMode == MapEditorController::MODE_OBJECT ||
              mapEditorController->editorMode == MapEditorController::MODE_EVENT ) {
        GameData *gameData = GameData::getInstance();

        /* TODO: este código é provisório, colocar o código de adicionar objeto AQUI */
        GameObject *selectedObject;
        if((selectedObject = mapEditorController->getSelectedObject()) != NULL) {
            GameObjectInstance* gameObjectInstance;
            gameObjectInstance = new GameObjectInstance(selectedObject);


            gameObjectInstance->x = (int) currentObjectItem->pos().x();
            gameObjectInstance->y = (int) currentObjectItem->pos().y();

            if(gameData->editingMap->gameObjectInstances->empty()) {
                gameObjectInstance->isCenter = true;
                gameObjectInstance->isMainObject = true;
            }

            gameData->editingMap->gameObjectInstances->push_back(gameObjectInstance);

            ObjectGraphicsItem *item = new ObjectGraphicsItem(gameObjectInstance, gameObjectInstances, mapEditorController);
            item->setFlag(QGraphicsItem::ItemIsMovable);
            item->setFlag(QGraphicsItem::ItemIsSelectable);
            item->setZValue(30);
            item->setPos(currentObjectItem->pos());
            this->addItem(item);
        }

        objectSelectionStartPosition = event->scenePos();
        objectSelectionEndPosition = event->scenePos();
        if(objectSelectionShape != NULL) {
            objectSelectionShape->setVisible(false);
        }




    }

    cleanColorizeSelectedItems();
    colorizeSelectedItems();
}







void TilemapScene::mouseMoveEvent(QGraphicsSceneMouseEvent *event)
{
    QGraphicsScene::mouseMoveEvent(event);
    if(mapEditorController->editorMode == MapEditorController::MODE_MAP) {
        shape1->setPos(floor(event->scenePos().x()/32)*32, floor(event->scenePos().y()/32)*32);
        shape2->setPos(shape1->pos());

        int i, j;

        switch(mapEditorController->drawMode) {
        case MapEditorController::DRAW_MODE_PAINT:
        case MapEditorController::DRAW_MODE_ERASER:
        case MapEditorController::DRAW_MODE_PENCIL:

            if(mousePressed) {
                i = floor(event->scenePos().x()/32);
                j = floor(event->scenePos().y()/32);

                mapEditorController->changeTile(i, j);
            }
            break;
        case MapEditorController::DRAW_MODE_SQUARE:
            if(mousePressed) {
                i = floor(event->scenePos().x()/32);
                j = floor(event->scenePos().y()/32);

                int iInicial = squareCircleDrawStartPosition.x()/32;
                int jInicial = squareCircleDrawStartPosition.y()/32;
                int iStart, jStart;
                int diff_i, diff_j;

                if(i < 0) i = 0;
                if(j < 0) j = 0;

                if(i > (mapGridVisual->width-1)) {
                    i = mapGridVisual->width-1;
                }
                if(j > (mapGridVisual->height-1)) {
                    j = mapGridVisual->height-1;
                }

                diff_i = (i - iInicial);
                diff_j = (j - jInicial);

                if(diff_i < 0) {
                    iStart = iInicial + diff_i;
                } else {
                    iStart = iInicial;
                }

                if(diff_j < 0) {
                    jStart = jInicial + diff_j;
                } else {
                    jStart = jInicial;
                }

                setSelectionRectangleSize((abs(diff_i)), (abs(diff_j)));
                shape1->setPos(iStart*32, jStart*32);
                shape2->setPos(iStart*32, jStart*32);
            }



            break;

        }





    } else if(mapEditorController->editorMode == MapEditorController::MODE_OBJECT ||
              mapEditorController->editorMode == MapEditorController::MODE_EVENT) {
        if(currentObjectItem != NULL) {
            QPointF currentObjectItemPos = event->scenePos();

            currentObjectItemPos.setX(currentObjectItemPos.x() - currentObjectItem->boundingRect().width()/2);
            currentObjectItemPos.setY(currentObjectItemPos.y() - currentObjectItem->boundingRect().height()/2);
            currentObjectItem->setPos(currentObjectItemPos);
        }

        if(mousePressed) {
            objectSelectionEndPosition = event->scenePos();
            drawObjectSelectionRectangle();
        }



    }


}

void TilemapScene::mouseReleaseEvent(QGraphicsSceneMouseEvent *event) {
    QGraphicsScene::mouseReleaseEvent(event);



    if(event->button() == Qt::LeftButton) {
        mousePressed = false;
    }

    if(mapEditorController->editorMode == MapEditorController::MODE_OBJECT) {
        if(event->button() == Qt::LeftButton) {

            // verifica quais os itens que deverao ser selecionados
            float xmin = std::min(objectSelectionStartPosition.x(), objectSelectionEndPosition.x());
            float ymin = std::min(objectSelectionStartPosition.y(), objectSelectionEndPosition.y());
            float xmax = std::max(objectSelectionStartPosition.x(), objectSelectionEndPosition.x());
            float ymax = std::max(objectSelectionStartPosition.y(), objectSelectionEndPosition.y());


            if(objectSelectionShape != NULL) {
                objectSelectionShape->setVisible(false);
            }


            if(selectedItems().empty()) {
                QList<QGraphicsItem*> toSelectItemList = items(xmin, ymin, xmax-xmin, ymax-ymin);

                for(QList<QGraphicsItem*>::iterator it = toSelectItemList.begin(); it != toSelectItemList.end(); ++it) {
                    QGraphicsItem *qGraphicsItem = *it;

                    if(typeid(*qGraphicsItem) == typeid(ObjectGraphicsItem)) {
                        qGraphicsItem->setSelected(true);

                    }
                }
            }

            QList<QGraphicsItem*> selectedItemList = selectedItems();

            for(QList<QGraphicsItem*>::iterator it = selectedItemList.begin(); it != selectedItemList.end(); ++it) {
                QGraphicsItem *qGraphicsItem = *it;

                if(typeid(*qGraphicsItem) == typeid(ObjectGraphicsItem)) {
                    ObjectGraphicsItem *objGraphicsItem = (ObjectGraphicsItem*) qGraphicsItem;
                    objGraphicsItem->updateObjectInstancePosition();
                }
            }


            cleanColorizeSelectedItems();
            colorizeSelectedItems();
        }
    } else if(mapEditorController->editorMode == MapEditorController::MODE_EVENT) {
        if(event->button() == Qt::LeftButton) {
            QMenu menu;
            QAction *newEventAction = menu.addAction("Novo evento");
            QAction *newTeleportAction = menu.addAction("Novo teletransporte");

            QAction *selectedAction = menu.exec(event->screenPos());

            if(selectedAction == newEventAction) {
                NewEventAreaDialog *newEventAreaDialog = new NewEventAreaDialog();
                newEventAreaDialog->setWindowTitle(QString("Novo evento"));
                newEventAreaDialog->exec();
            } else if(selectedAction == newTeleportAction) {
                GameData *gameData = GameData::getInstance();
                TeleportArea *newTeleportArea;
                NewTeleportAreaDialog *newTeleportAreaDialog = new NewTeleportAreaDialog();
                newTeleportAreaDialog->setWindowTitle(QString("Novo teletransporte"));
                newTeleportArea = newTeleportAreaDialog->exec();

                delete newTeleportAreaDialog;

                if(newTeleportArea != NULL) {
                    float xmin = std::min(objectSelectionStartPosition.x(), objectSelectionEndPosition.x());
                    float ymin = std::min(objectSelectionStartPosition.y(), objectSelectionEndPosition.y());
                    float xmax = std::max(objectSelectionStartPosition.x(), objectSelectionEndPosition.x());
                    float ymax = std::max(objectSelectionStartPosition.y(), objectSelectionEndPosition.y());

                    newTeleportArea->x = xmin;
                    newTeleportArea->y = ymin;
                    newTeleportArea->w = xmax - xmin;
                    newTeleportArea->h = ymax - ymin;

                    if(newTeleportArea->w < 30) {
                        newTeleportArea->w = 30;
                    }

                    if(newTeleportArea->h < 30) {
                        newTeleportArea->h = 30;
                    }

                    gameData->editingMap->teleportAreas->push_back(newTeleportArea);

                    TeleportAreaGraphicsItem *teleportAreaGraphicsItem;
                    teleportAreaGraphicsItem = new TeleportAreaGraphicsItem();
                    teleportAreaGraphicsItem->setRect(xmin, ymin, newTeleportArea->w, newTeleportArea->h);
                    teleportAreaGraphicsItem->setPen(QPen(QColor(0, 0, 255, 255)));
                    teleportAreaGraphicsItem->setBrush(QBrush(QColor(0, 0, 255, 30)));

                    addItem(teleportAreaGraphicsItem);

                    teleportAreaGraphicsItem->addLittleBoxAtTopLeftMarkToScene(this);

                    teleportAreaGraphicsItem->teleportArea = newTeleportArea;

                    teleportAreaGraphicsItems->push_back(teleportAreaGraphicsItem);
                }




            }

            if(objectSelectionShape != NULL) {
                objectSelectionShape->setVisible(false);
            }
        }

    } else if(mapEditorController->editorMode == MapEditorController::MODE_MAP) {
        switch(mapEditorController->drawMode) {
        case MapEditorController::DRAW_MODE_PAINT:
        case MapEditorController::DRAW_MODE_ERASER:
        case MapEditorController::DRAW_MODE_PENCIL:

            break;
        case MapEditorController::DRAW_MODE_SQUARE:
            squareCircleDrawEndPosition = event->scenePos();

            mapEditorController->changeTiles(squareCircleDrawStartPosition.x()/32, squareCircleDrawStartPosition.y()/32,
                                             squareCircleDrawEndPosition.x()/32, squareCircleDrawEndPosition.y()/32);

            int i, j;
            i = floor(event->scenePos().x()/32);
            j = floor(event->scenePos().y()/32);

            setSelectionRectangleSize(0, 0);

            shape1->setPos(i*32, j*32);
            break;

        }
    }




}

void TilemapScene::drawObjectSelectionRectangle() {
    float w, h, xmin, ymin;

    if(objectSelectionShape != NULL) {
        removeItem(objectSelectionShape);
    }

    w = (objectSelectionStartPosition.x() - objectSelectionEndPosition.x());
    h = (objectSelectionStartPosition.y() - objectSelectionEndPosition.y());

    xmin = (objectSelectionStartPosition.x());
    ymin = (objectSelectionStartPosition.y());


    if(w > 0) {
        xmin -= w;
    }

    if(h > 0) {
        ymin -= h;
    }


    w = fabs(w);
    h = fabs(h);

    objectSelectionShape = addRect(xmin, ymin, w, h, QPen(QColor(255, 255, 255, 255)), QBrush(QColor(255, 255, 255, 30)));
    objectSelectionShape->setZValue(50);

    if(selectedItems().empty()) {
        objectSelectionShape->setVisible(true);
    } else {
        objectSelectionShape->setVisible(false);
    }
}

void TilemapScene::changeTile(int i, int j, int tileI, int tileJ, int layer, TileSet* tileset) {
    mapGridVisual->changeTile(i, j, tileI, tileJ, layer, tileset);
}

void TilemapScene::wheelEvent(QGraphicsSceneWheelEvent *event) {
    update();
}

void TilemapScene::setSelectionRectangleSize(int di, int dj) {
    removeItem(shape1);
    removeItem(shape2);

    printf("di: %d\n", di);

    shape1 = addRect(3, 3, (di+1)*mapGridVisual->tileSize-6, (dj+1)*mapGridVisual->tileSize-6, QPen(QColor(255, 255, 255, 255)));
    shape2 = addRect(2, 2, (di+1)*mapGridVisual->tileSize-4, (dj+1)*mapGridVisual->tileSize-4, QPen());

    shape1->setOpacity(1);

    shape1->setZValue(30);
    shape2->setZValue(30);
}

void TilemapScene::setCurrentObjectAtCursor() {
    if(currentObjectItem != NULL) {
        this->removeItem(currentObjectItem);
        delete currentObjectItem;
    }

    if(mapEditorController->getSelectedObject() != NULL) {
        QPixmap *currentObjectImage;
        currentObjectImage = new QPixmap(QPixmap::fromImage(mapEditorController->getSelectedObject()->getIconImage()));
        currentObjectItem = new QGraphicsPixmapItem(*currentObjectImage);
        currentObjectItem->setOpacity(0.5);
        currentObjectItem->setPos(-1000, -1000);
        this->addItem(currentObjectItem);
    } else {
        currentObjectItem = NULL;
    }
}

void TilemapScene::setEditorMode(int mode) {
    if(mode == MapEditorController::MODE_MAP) {
        shape1->setVisible(true);
        shape2->setVisible(true);
        if(currentObjectItem != NULL) {
            currentObjectItem->setVisible(false);
        }
        //mapGridVisual->setOpacity(1.0f);

    } else if(mode == MapEditorController::MODE_OBJECT) {
        shape1->setVisible(false);
        shape2->setVisible(false);
        if(currentObjectItem != NULL) {
            currentObjectItem->setVisible(true);
        }
        //mapGridVisual->setOpacity(0.5f);
    }
}

void TilemapScene::cleanColorizeSelectedItems() {
    QList<QGraphicsItem*> itemList = items();

    for(QList<QGraphicsItem*>::iterator it = itemList.begin(); it != itemList.end(); ++it) {
        QGraphicsItem *qGraphicsItem = *it;

        if(typeid(*qGraphicsItem) == typeid(ObjectGraphicsItem)) {
            ObjectGraphicsItem *objGraphicsItem = (ObjectGraphicsItem*) qGraphicsItem;
            objGraphicsItem->setColorizeEffect(false);
        }
    }
}

void TilemapScene::colorizeSelectedItems() {
    QList<QGraphicsItem*> selectedItemList = selectedItems();

    for(QList<QGraphicsItem*>::iterator it = selectedItemList.begin(); it != selectedItemList.end(); ++it) {
        QGraphicsItem *qGraphicsItem = *it;

        if(typeid(*qGraphicsItem) == typeid(ObjectGraphicsItem)) {
            ObjectGraphicsItem *objGraphicsItem = (ObjectGraphicsItem*) qGraphicsItem;
            objGraphicsItem->setColorizeEffect(true);
        }
    }
}

void TilemapScene::setEditionLayer(int layer) {
    if(layer + 1 > mapGridVisual->getLayerCount()) {
        mapGridVisual->expandLayer();


    }

    layerRect->setZValue(layer*2 - 1);

}
#include "tilemapview.h"

TilemapView::TilemapView(QWidget *parent) : QGraphicsView(parent)
{
    this->setMouseTracking(true);
}
#include "tilesetcolmapscene.h"

TilesetColMapScene::TilesetColMapScene(TileSet *tileset, QObject *parent) :
    QGraphicsScene(parent),
    tileset(tileset)
{
    TilesetLinesGenerator *tilesetLinesGenerator = new TilesetLinesGenerator(this, tileset->tileSize,
                                                                             tileset->width, tileset->height,
                                                                             Qt::DotLine);
    tilesetLinesGenerator->addLinesToScene();

    QPixmap pixmap = QPixmap::fromImage(*tileset->tilesetImage);
    tilesetPixmapItem= new QGraphicsPixmapItem(pixmap, 0, this);
    this->addItem(tilesetPixmapItem);

    setBackgroundBrush(QBrush(QColor(255, 255, 255, 255)));
    setSceneRect(0, 0, pixmap.width(), pixmap.height());




    textArray.resize(boost::extents[tileset->width][tileset->height]);

    int i, j;
    for(i = 0; i < tileset->width; i++) {
        for(j = 0; j < tileset->height; j++) {
            QGraphicsDropShadowEffect *qgdse = new QGraphicsDropShadowEffect(0);
            qgdse->setColor(QColor(0, 0, 0));
            qgdse->setOffset(1);

            textArray[i][j] = new QGraphicsTextItem(0, this);
            textArray[i][j]->setPos(i*tileset->tileSize, j*tileset->tileSize);
            if(tileset->collisionMatrix[i][j] == NO_COLLISION) {
                textArray[i][j]->setHtml("<strong>O</strong>");
            } else {
                textArray[i][j]->setHtml("<strong>X</strong>");
            }

            textArray[i][j]->setDefaultTextColor(QColor(255, 255, 255, 255));
            textArray[i][j]->setGraphicsEffect(qgdse);
            this->addItem(textArray[i][j]);
        }
    }



}

void TilesetColMapScene::mousePressEvent(QGraphicsSceneMouseEvent *event) {
    QGraphicsScene::mousePressEvent(event);

    int i, j;
    i = floor(event->scenePos().x()/tileset->tileSize);
    j = floor(event->scenePos().y()/tileset->tileSize);

    tileset->collisionMatrix[i][j] = !tileset->collisionMatrix[i][j];

    if(tileset->collisionMatrix[i][j] == NO_COLLISION) {
        textArray[i][j]->setHtml("<strong>O</strong>");
    } else {
        textArray[i][j]->setHtml("<strong>X</strong>");
    }
}
#include "tileset.h"

TileSet::TileSet() {

}

TileSet::TileSet(std::string file, int tileSize)
{
    int i, j;

    /* determina os valores dos atributos */
    this->file = file;
    this->tileSize = tileSize;
    this->name = file;

    GameData *gameData = GameData::getInstance();

    /* abre a imagem pra ver a largura/altura */
    tilesetImage = new QImage(gameData->getProjectDirectory().append("/").append(file).c_str());

    maxX = floor(tilesetImage->width()/tileSize);
    maxY = floor(tilesetImage->height()/tileSize);


    height = maxY;
    width = maxX;

    //height = floor((maxY*maxX)/8);
    //width = 8;



    /* inicializa a tabela de colisoes */
    collisionMatrix.resize(boost::extents[maxX][maxY]);

    for(i = 0; i < maxX; i++)
        for(j = 0; j < maxY; j++) {
            collisionMatrix[i][j] = NO_COLLISION;
    }


    /* TODO: elimina o espaco da QImage */

}

void TileSet::reloadTilesetImage() {
    GameData *gameData = GameData::getInstance();

    printf("ProjectDirectory: %s\n", gameData->getProjectDirectory().c_str());

    printf("t:: %s\n", gameData->getProjectDirectory().append("/").append(file).c_str());

    tilesetImage = new QImage(gameData->getProjectDirectory().append("/").append(file).c_str());
}

void TileSet::setCollision(int tileI, int tileJ, int collisionType) {
    collisionMatrix[tileI][tileJ] = collisionType;
}
#include "tilesetdock.h"

TilesetDock::TilesetDock(QWidget *parent, MapEditorController *mapEditorController)
        : QDockWidget(parent)
{
    widget = new QWidget(this);
    this->mapEditorController = mapEditorController;

    setMinimumSize(285, 300);

    QSpacerItem *spacer = new QSpacerItem(0, 100);

    /* inicializando o layout */
    layout = new QVBoxLayout(widget);
    layout->setMargin(5);
    layout->setSpacing(0);

    tabWidget = new QTabWidget(widget);
    tabWidget->setTabPosition(QTabWidget::South);

    layerSlider = new QSlider(Qt::Horizontal, this);
    layerSlider->setMinimum(0);
    layerSlider->setMaximum(4);





    /* adicionando o tilesetview e o tilesetscene */

    QObject::connect(layerSlider, SIGNAL(valueChanged(int)), this, SLOT(layerSliderMudada(int)));

    QLabel *layerLabel = new QLabel(this);
    layerLabel->setText(QString("Camada: "));

    layout->addWidget(tabWidget);
    layout->addWidget(layerLabel);
    layout->addWidget(layerSlider);

    tabWidget->setEnabled(false);

    std::stringstream ss;
    ss << layerSlider->value();

    layerSlider->setToolTip(QString(ss.str().c_str()));
    layerSlider->setEnabled(false);



    setWidget(widget);
    setWindowTitle(tr("Tileset"));


}


void TilesetDock::setDrawTile(int iTile, int jTile, int diTile, int djTile) {
    mapEditorController->setDrawTile(iTile, jTile, diTile, djTile);
}

void TilesetDock::setEditorMode(int mode) {
    mapEditorController->setEditorMode(mode);
}

void TilesetDock::initTileSetScene() {
    GameData *gameData = GameData::getInstance();

    std::vector<TileSet*> *listaTilesets = gameData->editingMap->tileSets;

    tabWidget->clear();

    for(std::vector<TileSet*>::iterator it = listaTilesets->begin(); it != listaTilesets->end(); ++it) {
        TileSet* tileset = (*it);


        tilesetView = new TilesetView(widget);
        tilesetView->hide();


        tilesetScene = new TilesetScene(this, tileset);
        tilesetView->setScene(tilesetScene);
        tilesetView->setAlignment(Qt::AlignLeft);


        tabWidget->addTab(tilesetView, tileset->name.c_str());






        tilesetView->show();

    }

    tabWidget->setEnabled(true);
    layerSlider->setEnabled(true);




}

TileSet* TilesetDock::getSelectedTileset() {
    TilesetView *currentView;
    TilesetScene *currentScene;
    currentView = (TilesetView*) tabWidget->currentWidget();

    if(currentView == NULL) return NULL;

    currentScene = (TilesetScene*) currentView->scene();

    return currentScene->tileSet;
}

void TilesetDock::layerSliderMudada(int valor) {
    std::stringstream ss;
    ss << layerSlider->value();
    layerSlider->setToolTip(QString(ss.str().c_str()));

    layerSlider->setValue(mapEditorController->setMapEditorLayer(valor));
}
#include "tilesetgridvisual.h"

TilesetGridVisual::TilesetGridVisual(QGraphicsScene *scene, QImage *image, int tileSize)
{
    this->image = image;
    this->tileSize = tileSize;
    this->scene = scene;
    int i, j, k;
    int maxX, maxY;

    maxX = floor(image->width()/tileSize);
    maxY = floor(image->height()/tileSize);

    height = maxY;
    width = maxX;



    tileMap.resize(boost::extents[width][height]);

    k = 0;
    for(j = 0; j < height; j++)
        for(i = 0; i < width; i++) {
            printf("%d, %d\n", i, j);
            tileMap[i][j] = new TileItem(image, tileSize, i, j);
            tileMap[i][j]->setPos((k%width)*tileSize, (floor(k/width))*tileSize);
            scene->addItem(tileMap[i][j]);
            k++;
    }
    
    






}
#include "tilesetlinesgenerator.h"

TilesetLinesGenerator::TilesetLinesGenerator(QGraphicsScene *scene, int size, int width, int height, Qt::PenStyle penStyle)
{
    int i;
    this->scene = scene;
    this->width = width;
    this->height = height;

    lines = (QGraphicsLineItem**)calloc(width + height + 2, sizeof(QGraphicsLineItem*));
    for(i = 0; i <= height; i++) {
        lines[i] = new QGraphicsLineItem(0, i*size, width*size, i*size);
        lines[i]->setZValue(15);
        lines[i]->setPen(QPen(penStyle));
    }

    for(i = 0; i <= width; i++) {
        lines[i+height+1] = new QGraphicsLineItem(i*size, 0, i*size, height*size);
        lines[i+height+1]->setZValue(15);
        lines[i+height+1]->setPen(QPen(penStyle));
    }


    addLinesToScene();
}

void TilesetLinesGenerator::addLinesToScene()
{
    int i;
    for(i = 0; i < width + height + 2; i++) {
        scene->addItem(lines[i]);
    }
}
#include "tilesetscene.h"

TilesetScene::TilesetScene(TilesetDock *tilesetDock, TileSet *tileSet)
{
    GameData *gameData = GameData::getInstance();

    this->tileSet = tileSet;


    size = 32;
    this->tilesetDock = tilesetDock;
    gridVisual = new TilesetGridVisual(this, new QImage(gameData->getProjectDirectory().append("/").append(tileSet->file).c_str()), size);

    shape1 = addRect(3, 3, size-6, size-6, QPen(QColor(255, 255, 255, 255)));
    shape2 = addRect(2, 2, size-4, size-4, QPen());

    shape3 = addRect(3, 3, size-6, size-6, QPen(QColor(255, 0, 0, 255)));
    shape4 = addRect(2, 2, size-4, size-4, QPen());


    shape1->setOpacity(1);

    shape1->setZValue(10);
    shape2->setZValue(10);

    shape3->setOpacity(1);

    shape3->setZValue(10);
    shape4->setZValue(10);

    mousePressed = false;
}

void TilesetScene::mouseMoveEvent(QGraphicsSceneMouseEvent *event) {
    int i, j, diff_i, diff_j, iStart, jStart;

    if(!mousePressed) {
        shape1->setPos(floor(event->scenePos().x()/32)*32, floor(event->scenePos().y()/32)*32);
        shape2->setPos(shape1->pos());
    } else {
        shape1->setPos(floor(event->scenePos().x()/32)*32, floor(event->scenePos().y()/32)*32);
        shape2->setPos(shape1->pos());
        removeItem(shape1);
        removeItem(shape2);
        removeItem(shape3);
        removeItem(shape4);

        i = floor(event->scenePos().x()/32);
        j = floor(event->scenePos().y()/32);

        if(i < 0) i = 0;
        if(j < 0) j = 0;
        
        if(i > (gridVisual->width-1)) {
            i = gridVisual->width-1;
        }
        if(j > (gridVisual->height-1)) {
            j = gridVisual->height-1;
        }

        diff_i = (i - iInicial);
        diff_j = (j - jInicial);

        if(diff_i < 0) {
            iStart = iInicial + diff_i;
        } else {
            iStart = iInicial;
        }

        if(diff_j < 0) {
            jStart = jInicial + diff_j;
        } else {
            jStart = jInicial;
        }


        shape1 = addRect(3, 3, (abs(diff_i) + 1)*size-6, (abs(diff_j) + 1)*size-6, QPen(QColor(255, 255, 255, 255)));
        shape2 = addRect(2, 2, (abs(diff_i) + 1)*size-4, (abs(diff_j) + 1)*size-4, QPen());
        shape3 = addRect(3, 3, (abs(diff_i) + 1)*size-6, (abs(diff_j) + 1)*size-6, QPen(QColor(255, 0, 0, 255)));
        shape4 = addRect(2, 2, (abs(diff_i) + 1)*size-4, (abs(diff_j) + 1)*size-4, QPen());



        shape1->setPos(iStart*size, jStart*size);
        shape2->setPos(iStart*size, jStart*size);
        shape3->setPos(iStart*size, jStart*size);
        shape4->setPos(iStart*size, jStart*size);



        update();
    }
    
}

void TilesetScene::mousePressEvent(QGraphicsSceneMouseEvent *event) {
    int i, j;
    mousePressed = true;

    tilesetDock->setEditorMode(MapEditorController::MODE_MAP);

    i = floor(event->scenePos().x()/32);
    j = floor(event->scenePos().y()/32);

    if(i < 0) i = 0;
    if(j < 0) j = 0;

    if(i > (gridVisual->width-1)) {
        i = gridVisual->width-1;
    }
    if(j > (gridVisual->height-1)) {
        j = gridVisual->height-1;
    }


    iAnt = i;
    jAnt = j;

    iInicial = i;
    jInicial = j;

    tilesetDock->setDrawTile(i, j, 0, 0);

    removeItem(shape3);
    removeItem(shape4);

    shape3 = addRect(3, 3, (i - iInicial + 1)*size-6, (j - jInicial + 1)*size-6, QPen(QColor(255, 0, 0, 255)));
    shape4 = addRect(2, 2, (i - iInicial + 1)*size-4, (j - jInicial + 1)*size-4, QPen());

    shape3->setPos(i*32, j*32);
    shape4->setPos(shape1->pos());

    update();


}

void TilesetScene::mouseReleaseEvent(QGraphicsSceneMouseEvent *event) {
    int i, j, di, dj;

    int iStart, jStart;

    mousePressed = false;

    i = floor(event->scenePos().x()/32);
    j = floor(event->scenePos().y()/32);

    if (i < 0) i = 0;
    if (i < 0) i = 0;

    if(i > (gridVisual->width-1)) {
        i = gridVisual->width-1;
    }
    if(j > (gridVisual->height-1)) {
        j = gridVisual->height-1;
    }

    if(i != iAnt || j != jAnt) {
        di = i - iAnt;
        dj = j - jAnt;

        if(di < 0) {
            iStart = iAnt + di;
        } else {
            iStart = iAnt;
        }

        if(dj < 0) {
            jStart = jAnt + dj;
        } else {
            jStart = jAnt;
        }


        tilesetDock->setDrawTile(iStart, jStart, abs(di), abs(dj));
    }

    /* reestabelecendo os shapes 1 e 2 */

    removeItem(shape1);
    removeItem(shape2);

    shape1 = addRect(3, 3, size-6, size-6, QPen(QColor(255, 255, 255, 255)));
    shape2 = addRect(2, 2, size-4, size-4, QPen());
}
#include "tilesetview.h"

TilesetView::TilesetView(QWidget *parent) : QGraphicsView(parent)
{
    this->setMouseTracking(true);
}
#include "titlescreendata.h"

TitleScreenData::TitleScreenData()
{
}
#include "variabledata.h"

VariableData::VariableData()
{
}
#include "wizardcontroller.h"

WizardController::WizardController()
{
}

void WizardController::setMainController(MainController *mainController)
{
    this->mainController = mainController;
}
#ifndef ANIMATIONDATA_H
#define ANIMATIONDATA_H

#include <string>
#include <QImage>

#include "gamedata.h"

class GameData;

class AnimationData
{
public:
    AnimationData();

    int id;
    std::string name;
    std::string fileName;

    int horizontalSpacing;
    int verticalSpacing;
    int order;
    int velocity;
    bool hasLoop;
    int frameLoop;

    bool hasColorkey;
    int colorkey_r, colorkey_g, colorkey_b;

    bool activated;

    int startX, startY, endX, endY;

    void setHorizontalFrameNumber(int number);
    void setVerticalFrameNumber(int number);
    int getHorizontalFrameNumber();
    int getVerticalFrameNumber();
    QImage getIconImage();

private:
    int horizontalFrameNumber;
    int verticalFrameNumber;


};

#endif // ANIMATIONDATA_H
#ifndef ANIMATIONGRAPHICSITEM_H
#define ANIMATIONGRAPHICSITEM_H

#include <QGraphicsRectItem>
#include <QImage>
#include <QPainter>
#include <QDebug>


#include <string>

#include "gamedata.h"

class GameData;

class AnimationGraphicsItem : public QGraphicsRectItem
{
public:
    AnimationGraphicsItem(std::string string, int horizontalFrameNumber, int verticalFrameNumber, int order,
                          int startX, int startY, int endX, int endY);
    AnimationGraphicsItem(std::string string);

    void doStep();
private:
    QImage *image;
    QRect animationRect;

    int stepX, stepY;
    int animX, animY;
    int horizontalFrameNumber, verticalFrameNumber;
    int order;
    bool isAnimation;

    int startX, startY, endX, endY;



protected:
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);
};

#endif // ANIMATIONGRAPHICSITEM_H
#ifndef ANIMATIONGRAPHICSSCENE_H
#define ANIMATIONGRAPHICSSCENE_H

#include <QGraphicsScene>
#include <QGraphicsView>
#include <QImage>
#include <QRgb>
#include <QBrush>

#include <iostream>

#include "animationgraphicsitem.h"
#include "animationdata.h"

class AnimationGraphicsItem;
class AnimationData;

class AnimationGraphicsScene : public QGraphicsScene
{
public:
    AnimationGraphicsScene(QGraphicsView *graphicsView);
    ~AnimationGraphicsScene();

    AnimationGraphicsItem *animationGraphicsItem;
    QGraphicsView *graphicsView;

    void addAnimationData(AnimationData *animationData);
    void addSpriteData(std::string sprite);
    void setAdjustPoint(int x, int y);
    void removeGraphics();
    int timerId;

    QGraphicsLineItem *crossLine1;
    QGraphicsLineItem *crossLine2;




protected:
    void timerEvent(QTimerEvent *);
};

#endif // ANIMATIONGRAPHICSSCENE_H
#ifndef BACKGROUND_H
#define BACKGROUND_H

#include <vector>

#include "backgroundlayer.h"

class BgLayer;

class Background
{
public:
    Background();


    int id;
    std::string name;
    std::vector<BgLayer*> *layerList;

};

#endif // BACKGROUND_H
#ifndef BACKGROUNDLAYER_H
#define BACKGROUNDLAYER_H

#include <string>

class BgLayer
{
public:
    BgLayer();

    std::string fileName;

    int displacementX, displacementY;
    bool repeatsHorizontally;
    bool repeatsVertically;
    int behavior;
    int vx, vy;

};

#endif // BACKGROUNDLAYER_H
#ifndef BACKGROUNDPICKERDIALOG_H
#define BACKGROUNDPICKERDIALOG_H

#include <QDialog>
#include <QListWidgetItem>
#include <QAbstractButton>
#include <QDialogButtonBox>

#include <iostream>

#include "gamedata.h"
#include "background.h"
#include "backgroundsgraphicsscene.h"

class GameData;
class Background;
class BackgroundsGraphicsScene;

namespace Ui {
    class BackgroundPickerDialog;
}

class BackgroundPickerDialog : public QDialog
{
    Q_OBJECT

public:
    explicit BackgroundPickerDialog(QWidget *parent = 0);
    ~BackgroundPickerDialog();

    void populaListaFundos();
    Background* exec();

private:
    Ui::BackgroundPickerDialog *ui;
    BackgroundsGraphicsScene *backgroundGraphicsScene;

    Background *chosenBackground;


private slots:
    void on_buttonBox_clicked(QAbstractButton* button);
    void on_buttonBox_rejected();
    void on_buttonBox_accepted();
    void on_listWidget_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
};

#endif // BACKGROUNDPICKERDIALOG_H
#ifndef BACKGROUNDSGRAPHICSSCENE_H
#define BACKGROUNDSGRAPHICSSCENE_H

#include <QGraphicsScene>
#include <QGraphicsPixmapItem>

#include <vector>
#include <iostream>

#include <stdlib.h>

#include "background.h"
#include "backgroundlayer.h"
#include "gamedata.h"

class Background;
class BgLayer;
class GameData;

class BackgroundsGraphicsScene : public QGraphicsScene
{
public:
    BackgroundsGraphicsScene();

    void setBackground(Background *background);
    void reloadBackground();

    std::vector<QGraphicsPixmapItem*> pixmapItems;

    Background *background;


};

#endif // BACKGROUNDSGRAPHICSSCENE_H
#ifndef BUILDER_H
#define BUILDER_H

#include "maincontroller.h"

class MainController;

class Builder
{
public:
    Builder();
    MainController* build();
};

#endif // BUILDER_H
#ifndef CONFIGSANIMATIONS_H
#define CONFIGSANIMATIONS_H

#include <QWidget>

#include "gamedata.h"
#include "optionscontroller.h"
#include "animationdata.h"
#include "configsimportdialog.h"
#include "animationgraphicsscene.h"

class GameData;
class OptionsController;
class AnimationData;
class ConfigsImportDialog;
class AnimationGraphicsScene;

namespace Ui {
    class ConfigsAnimations;
}

class ConfigsAnimations : public QWidget
{
    Q_OBJECT

public:
    explicit ConfigsAnimations(QWidget *parent = 0);
    ~ConfigsAnimations();

    void populaListaAnimation();
    void populaCampos();

    void setOptionsController(OptionsController *optionsController);


private:
    Ui::ConfigsAnimations *ui;
    OptionsController *optionsController;
    AnimationData* currentAnimationData;
    AnimationGraphicsScene *animationsGraphicsScene;

    bool ativaMudancas;

private slots:
    void on_spinBoxLinhaFinal_valueChanged(int );
    void on_spinBoxColunaFinal_valueChanged(int );
    void on_spinBoxLinhaInicial_valueChanged(int );
    void on_spinBoxColunaInicial_valueChanged(int );
    void on_comboBoxOrder_currentIndexChanged(int index);
    void on_spinBoxFrameLoop_valueChanged(int );
    void on_checkBox_toggled(bool checked);
    void on_horizontalSliderVelocity_valueChanged(int value);
    void on_spinBoxVerticalSpacing_valueChanged(int );
    void on_spinBoxHorizontalSpacing_valueChanged(int );
    void on_spinBoxVerticalFrameNumber_valueChanged(int );
    void on_spinBoxHorizontalFramesNumber_valueChanged(int );
    void on_listWidget_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_pushButtonAddAnimation_clicked();
};

#endif // CONFIGSANIMATIONS_H




#ifndef CONFIGSBACKGROUNDS_H
#define CONFIGSBACKGROUNDS_H

#include <QWidget>

#include "optionscontroller.h"
#include "configsimportdialog.h"
#include "backgroundsgraphicsscene.h"
#include "messageboxes.h"


class OptionsController;
class ConfigsImportDialog;
class BackgroundsGraphicsScene;
class MessageBoxes;

namespace Ui {
    class ConfigsBackgrounds;
}

class ConfigsBackgrounds : public QWidget
{
    Q_OBJECT

public:
    explicit ConfigsBackgrounds(QWidget *parent = 0);
    ~ConfigsBackgrounds();

    void populaListaBackgrounds(bool firstTime);
    void populaListaLayers();

    void preencheCamposBg();
    void preencheCamposLayer();

    void setOptionsController(OptionsController *optionsController);

private:
    Ui::ConfigsBackgrounds *ui;
    OptionsController *optionsController;
    BackgroundsGraphicsScene *backgroundsGraphicsScene;

private slots:
    void on_pushButtonRemoveLayer_pressed();
    void on_pushButtonAddLayer_pressed();
    void on_pushButtonAddLayer_clicked();
    void on_listWidgetLayers_itemChanged(QListWidgetItem* item);
    void on_spinBoxVy_valueChanged(int );
    void on_spinBoxVx_valueChanged(int );
    void on_comboBoxBehavior_currentIndexChanged(int index);
    void on_checkBoxRepeatVer_toggled(bool checked);
    void on_checkBoxRepeatHor_toggled(bool checked);
    void on_spinBoxDy_valueChanged(int );
    void on_spinBoxDx_valueChanged(int );
    void on_pushButton_clicked();
    void on_listWidgetLayers_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_lineEditName_textChanged(QString );
    void on_listWidgetBgs_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_pushButtonAddBg_clicked();
};

#endif // CONFIGSBACKGROUNDS_H
#ifndef CONFIGSGENERALWIDGET_H
#define CONFIGSGENERALWIDGET_H

#include <stdio.h>
#include <stdlib.h>
#include <iostream>

#include <QWidget>
#include <iostream>
#include <vector>

#include "optionscontroller.h"
#include "gamedata.h"
#include "configsimportdialog.h"
#include "editorconstants.h"
#include "map.h"
#include "soundpickerdialog.h"

class OptionsController;
class GameData;
class ConfigsImportDialog;
class EditorConstants;
class Map;
class SoundPickerDialog;

namespace Ui {
    class ConfigsGeneralWidget;
}

class ConfigsGeneralWidget : public QWidget {
    Q_OBJECT
public:
    ConfigsGeneralWidget(QWidget *parent = 0);
    ~ConfigsGeneralWidget();

    void setOptionsController(OptionsController *optionsController);
    void preencheDadosGerais();
    void preencheEditsResolucao();
    void preencheEditsMusicas();
    void preencheCurrentIndexComboInicialMap();
    void atualizaImagensTelas();
    void atualizaVisualizacaoEditsResolucao();
    void populaComboMapaInicial();
    void populaComboMapaInicialPercorreArvore(std::vector<Map*> *mapList, std::string prefix);

    bool ativaMudancaComboMapaInicial;

protected:
    void changeEvent(QEvent *e);

private:
    Ui::ConfigsGeneralWidget *ui;
    OptionsController *optionsController;

private slots:
    void on_toolButtonMusicaTelaGameOver_clicked();
    void on_toolButtonMusicaTelaOpcoes_clicked();
    void on_toolButtonMusicaTelaInicial_clicked();
    void on_comboInitialMap_currentIndexChanged(int index);
    void on_editResolutionHeight_textChanged(QString );
    void on_editResolutionWidth_textChanged(QString );
    void on_editGameName_textChanged(QString );
    void on_comboResolution_currentIndexChanged(int index);
    void on_buttonAlterarTelaGameOver_clicked();
    void on_buttonAlterarTelaOpcoes_clicked();
    void on_buttonAlterarTelaInicial_clicked();
};

#endif // CONFIGSGENERALWIDGET_H
#ifndef CONFIGSIMPORTDIALOG_H
#define CONFIGSIMPORTDIALOG_H

#include <QDialog>
#include <QDir>
#include <QFileDialog>
#include <QListWidgetItem>

#include "gamedata.h"
#include "messageboxes.h"
#include "optionscontroller.h"

class GameData;
class MessageBoxes;
class OptionsController;


namespace Ui {
    class ConfigsImportDialog;
}

class ConfigsImportDialog : public QDialog
{
    Q_OBJECT

public:
    explicit ConfigsImportDialog(OptionsController *optionsController, int importType, QWidget *parent = 0);
    explicit ConfigsImportDialog(OptionsController *optionsController, int importType, int importOption, QWidget *parent = 0);
    ~ConfigsImportDialog();

    void populaLista();

    std::string *getReturnString();

    int importType;
    int importOption;

    int animationImportPattern;

    static const int IMPORT_TILESETS = 0;
    static const int IMPORT_TITLESCREENS = 1;
    static const int IMPORT_ANIMATIONS = 2;
    static const int IMPORT_SPRITE = 3;
    static const int IMPORT_BACKGROUND = 4;
    static const int IMPORT_LAYER = 5;

private:
    Ui::ConfigsImportDialog *ui;
    OptionsController *optionsController;

    std::string *returnString;

private slots:
    void on_comboBoxTipo_currentIndexChanged(int index);
    void on_listWidget_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_botaoCancelar_clicked();
    void on_botaoImportar_clicked();
    void on_botaoSelecionar_clicked();
};

#endif // CONFIGSIMPORTDIALOG_H
#ifndef CONFIGSNEWOBJECTWINDOW_H
#define CONFIGSNEWOBJECTWINDOW_H

#include <QDialog>

#include "optionscontroller.h"

#include "messageboxes.h"

class OptionsController;
class MessageBoxes;

namespace Ui {
    class ConfigsNewObjectWindow;
}

class ConfigsNewObjectWindow : public QDialog {
    Q_OBJECT
public:
    ConfigsNewObjectWindow(OptionsController *optionsController, QWidget *parent = 0);
    ~ConfigsNewObjectWindow();

protected:
    void changeEvent(QEvent *e);

private:
    Ui::ConfigsNewObjectWindow *ui;
    OptionsController *optionsController;

private slots:
    void on_buttonBox_accepted();
};

#endif // CONFIGSNEWOBJECTWINDOW_H
#ifndef CONFIGSOBJANIMATIONCHOOSERWINDOW_H
#define CONFIGSOBJANIMATIONCHOOSERWINDOW_H

#include <QDialog>

#include <vector>
#include <string>

#include "optionscontroller.h"
#include "gameobject.h"
#include "gamedata.h"
#include "gameobjectanimation.h"
#include "configsimportdialog.h"
#include "animationgraphicsscene.h"
#include "messageboxes.h"

class OptionsController;
class GameObject;
class GameData;
class GameObjectAnimation;
class ConfigsImportDialog;
class AnimationGraphicsScene;
class MessageBoxes;

namespace Ui {
    class ConfigsObjAnimationChooserWindow;
}

class ConfigsObjAnimationChooserWindow : public QDialog
{
    Q_OBJECT

public:
    explicit ConfigsObjAnimationChooserWindow(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem, QWidget *parent = 0);
    ~ConfigsObjAnimationChooserWindow();

    void populaListaEstados();
    void populaListaAnimacoes();
    void copyGameObjectAnimation();
    void preencheCamposCurrentDirection();
    void mostraAnimacaoVisualizacao();
    void mostraSpriteVisualizacao();
    void atualizaVisualizacao();

    bool verificaSeParadoTemAnimacao();
    void corrigeDadosArmazenamento();
    void limpaDadosAntigos();

private:
    Ui::ConfigsObjAnimationChooserWindow *ui;
    OptionsController *optionsController;
    GameObject *gameObject;
    QListWidgetItem *currentListItem;

    std::vector<GameObjectAnimation*> *gameObjectAnimations;

    GameObjectAnimation *currentGameObjectAnimation;
    AnimationGraphicsScene *animationGraphicsScene;

    int getDialConvertedValue();




private slots:
    void on_spinBoxAdjustY2_valueChanged(int );
    void on_spinBoxAdjustX2_valueChanged(int );
    void on_spinBoxAdjustY_valueChanged(int );
    void on_spinBoxAdjustX_valueChanged(int );
    void on_buttonBox_accepted();
    void on_listWidget_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_pushButtonSpriteChooser_pressed();
    void on_checkBoxInvertVertically2_toggled(bool checked);
    void on_checkBoxInvertHorizontal2_toggled(bool checked);
    void on_checkBoxInvertVertical_toggled(bool checked);
    void on_checkBoxInvertHorizontal_toggled(bool checked);
    void on_tabWidgetSpriteAnim_currentChanged(int index);
    void on_listWidgetEstados_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_dial_valueChanged(int value);
    void on_horizontalSliderDirectionNumber_valueChanged(int value);
};

#endif // CONFIGSOBJANIMATIONCHOOSERWINDOW_H
#ifndef CONFIGSOBJATTRIBUTESWIDGET_H
#define CONFIGSOBJATTRIBUTESWIDGET_H

#include <QWidget>

#include "optionscontroller.h"
#include "gameobject.h"

class OptionsController;
class GameObject;


namespace Ui {
    class ConfigsObjAttributesWidget;
}

class ConfigsObjAttributesWidget : public QWidget
{
    Q_OBJECT

public:
    explicit ConfigsObjAttributesWidget(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem, QWidget *parent = 0);
    ~ConfigsObjAttributesWidget();



    void decideLevelEvolutionVisibility();
    void populaCampos();

private:
    Ui::ConfigsObjAttributesWidget *ui;
    OptionsController *optionsController;
    GameObject *gameObject;
    QListWidgetItem *currentListItem;

private slots:
    void on_horizontalSliderEvolutionVelocity_valueChanged(int value);
    void on_spinBoxMaxLevel_valueChanged(int );
    void on_spinBoxInitialLevel_valueChanged(int );
    void on_spinBoxInt_valueChanged(int );
    void on_spinBoxDef_valueChanged(int );
    void on_spinBoxAtk_valueChanged(int );
    void on_spinBoxMp_valueChanged(int );
    void on_spinBoxHp_valueChanged(int );
    void on_checkBoxLevelEvolution_toggled(bool checked);
};

#endif // CONFIGSOBJATTRIBUTESWIDGET_H

#ifndef CONFIGSOBJDADOSGERAISWIDGET_H
#define CONFIGSOBJDADOSGERAISWIDGET_H

#include <QWidget>

#include "optionscontroller.h"
#include "gameobject.h"

#include "configsobjanimationchooserwindow.h"

class OptionsController;
class GameObject;
class ConfigsObjAnimationChooserWindow;

namespace Ui {
    class ConfigsObjDadosGeraisWidget;
}

class ConfigsObjDadosGeraisWidget : public QWidget
{
    Q_OBJECT

public:
    explicit ConfigsObjDadosGeraisWidget(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem, QWidget *parent = 0);
    ~ConfigsObjDadosGeraisWidget();

private:
    Ui::ConfigsObjDadosGeraisWidget *ui;
    OptionsController *optionsController;
    GameObject *gameObject;
    QListWidgetItem *currentListItem;
    QGraphicsPixmapItem *item;
    QGraphicsScene *scene;

private slots:
    void on_botaoEditarFormaGrafica_clicked();
    void on_comboFormaGrafica_currentIndexChanged(int index);
    void on_checkBoxObjUnico_toggled(bool checked);
    void on_editNome_textChanged(QString );
};

#endif // CONFIGSOBJDADOSGERAISWIDGET_H
#ifndef CONFIGSOBJECTSWIDGET_H
#define CONFIGSOBJECTSWIDGET_H

#include <QWidget>
#include <vector>
#include <QListWidgetItem>

#include "optionscontroller.h"
#include "configsnewobjectwindow.h"
#include "gamedata.h"
#include "gameobject.h"
#include "configsobjgenericwidget.h"
#include "configstabwidget.h"

class ConfigsNewObjectWindow;
class OptionsController;
class GameData;
class GameObject;
class ConfigsObjGenericWidget;
class ConfigsTabWidget;


namespace Ui {
    class ConfigsObjectsWidget;
}

class ConfigsObjectsWidget : public QWidget {
    Q_OBJECT
public:
    ConfigsObjectsWidget(QWidget *parent = 0);
    ~ConfigsObjectsWidget();

    void setOptionsController(OptionsController *optionsController);
    void populaListaPersonagem();

    void selectObject(GameObject *gameObject);
    void setConfigsTabWidget(ConfigsTabWidget *configsTabWidget);




protected:
    void changeEvent(QEvent *e);

private:
    Ui::ConfigsObjectsWidget *ui;
    ConfigsObjGenericWidget *specificWidget;
    ConfigsNewObjectWindow *configsNewObjectWindow;
    OptionsController *optionsController;
    ConfigsTabWidget *configsTabWidget;

private slots:
    void on_listPersonagem_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_pushButton_clicked();
};

#endif // CONFIGSOBJECTSWIDGET_H

#ifndef CONFIGSOBJGENERICWIDGET_H
#define CONFIGSOBJGENERICWIDGET_H

#include <QWidget>
#include <QVBoxLayout>
#include <QListWidgetItem>
#include <stdlib.h>

#include "optionscontroller.h"
#include "gameobject.h"
#include "configsobjdadosgeraiswidget.h"
#include "configsobjhabilidadeswidget.h"
#include "configsobjphysicswidget.h"
#include "configsobjnpcbehaviorwidget.h"
#include "configsobjitem.h"
#include "configsobjattributeswidget.h"
#include "configstabwidget.h"

class OptionsController;
class GameObject;
class ConfigsObjDadosGeraisWidget;
class ConfigsObjHabilidadesWidget;
class ConfigsObjPhysicsWidget;
class ConfigsObjNpcBehaviorWidget;
class ConfigsObjAttributesWidget;
class ConfigsObjItem;
class ConfigsTabWidget;

namespace Ui {
    class ConfigsObjGenericWidget;
}

class ConfigsObjGenericWidget : public QWidget
{
    Q_OBJECT

public:
    explicit ConfigsObjGenericWidget(QWidget *parent);
    ~ConfigsObjGenericWidget();



    void addWidgets(OptionsController *optionsController,GameObject *gameObject, QListWidgetItem *currentListItem);
    void removeAllWidgets();

    void setConfigsTabWidget(ConfigsTabWidget *configsTabWidget);

private:
    Ui::ConfigsObjGenericWidget *ui;
    OptionsController *optionsController;
    GameObject *gameObject;
    QListWidgetItem *currentListItem;
    QVBoxLayout *layout;
    QWidget *parent;
    ConfigsObjDadosGeraisWidget *configsObjDadosGeraisWidget;
    ConfigsObjAttributesWidget *configsObjAttributesWidget;
    ConfigsObjNpcBehaviorWidget *configsObjBehaviorWidget;
    ConfigsObjItem *configsObjItem;
    ConfigsObjPhysicsWidget *configsObjPhysicsWidget;
    ConfigsObjHabilidadesWidget *configsObjHabilidadesWidget;

    ConfigsTabWidget *configsTabWidget;

};

#endif // CONFIGSOBJGENERICWIDGET_H
#ifndef CONFIGSOBJHABILIDADESWIDGET_H
#define CONFIGSOBJHABILIDADESWIDGET_H

#include <QWidget>
#include <QListWidgetItem>
#include <QTreeWidgetItem>

#include <sstream>

#include "optionscontroller.h"
#include "gameobject.h"
#include "configsobjnewskilldialog.h"
#include "skilldata.h"
#include "configstabwidget.h"

class OptionsController;
class GameObject;
class ConfigsObjNewSkillDialog;
class SkillData;
class ConfigsTabWidget;

namespace Ui {
    class ConfigsObjHabilidadesWidget;
}

class ConfigsObjHabilidadesWidget : public QWidget
{
    Q_OBJECT

public:
    explicit ConfigsObjHabilidadesWidget(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem, QWidget *parent = 0);
    ~ConfigsObjHabilidadesWidget();

    void setConfigsTabWidget(ConfigsTabWidget *configsTabWidget);

private:
    Ui::ConfigsObjHabilidadesWidget *ui;

    OptionsController *optionsController;
    GameObject *gameObject;
    QListWidgetItem *currentListItem;
    ConfigsTabWidget *configsTabWidget;

    void populaListaSkills();

private slots:
    void on_pushButtonEdit_pressed();
    void on_pushButtonRemove_pressed();
    void on_listHabilidades_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_botaoAddHabilidade_pressed();
    void on_botaoEditorEventos_clicked();
    void on_botaoAddHabilidade_clicked();
    void on_botaoOpcoes_clicked();
    void on_comboEvoNivel_currentIndexChanged(int index);
    void on_botaoEditorEventos_pressed();
};

#endif // CONFIGSOBJHABILIDADESWIDGET_H





#ifndef CONFIGSOBJITEM_H
#define CONFIGSOBJITEM_H

#include <QWidget>

#include "optionscontroller.h"
#include "gameobject.h"

class OptionsController;
class GameObject;


namespace Ui {
    class ConfigsObjItem;
}

class ConfigsObjItem : public QWidget
{
    Q_OBJECT

public:
    explicit ConfigsObjItem(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem, QWidget *parent = 0);
    ~ConfigsObjItem();

    void populaCampos();




private:
    Ui::ConfigsObjItem *ui;
    OptionsController *optionsController;
    GameObject *gameObject;
    QListWidgetItem *currentListItem;


private slots:
    void on_comboBoxConcedeHabilidade_currentIndexChanged(int index);
    void on_checkBoxConcedeHabilidade_toggled(bool checked);
    void on_checkBoxComportamentoDesapareceEncParedes_toggled(bool checked);
    void on_checkBoxComportamentoDesapareceEncPers_toggled(bool checked);
    void on_comboMovimentacaoItem_currentIndexChanged(int index);
    void on_radioButtonEnviaInventario_toggled(bool checked);
    void on_radioButtonAtivaEfeitoImediatamente_toggled(bool checked);
    void on_comboBoxAtivaEvento_currentIndexChanged(int index);
    void on_spinBoxIncrementaVariavel_valueChanged(int );
    void on_comboBoxIncrementaVariavel_currentIndexChanged(int index);
    void on_spinBoxGanhaPerdeMagia_valueChanged(int );
    void on_spinBoxGanhaPerdeVida_valueChanged(int );
    void on_spinBoxConcedePontos_valueChanged(int );
    void on_checkBoxAtivaEvento_toggled(bool checked);
    void on_checkBoxIncrementaVariavel_toggled(bool checked);
    void on_checkBoxGanhaPerdeMagia_toggled(bool checked);
    void on_checkBoxGanhaPerdeVida_toggled(bool checked);
    void on_checkBoxConcedePontos_toggled(bool checked);
};

#endif // CONFIGSOBJITEM_H
#ifndef CONFIGSOBJNEWSKILLDIALOG_H
#define CONFIGSOBJNEWSKILLDIALOG_H

#include <QDialog>

#include "gamedata.h"
#include "skilldata.h"
#include "gameobject.h"
#include "messageboxes.h"

class GameData;
class SkillData;
class GameObject;
class MessageBoxes;

namespace Ui {
    class ConfigsObjNewSkillDialog;
}

class ConfigsObjNewSkillDialog : public QDialog
{
    Q_OBJECT

public:
    explicit ConfigsObjNewSkillDialog(GameObject *gameObject, SkillData *skillData = 0, QWidget *parent = 0);
    ~ConfigsObjNewSkillDialog();

    SkillData *exec();

private:
    void preencheCampos(SkillData *skillData);
    void populaComboObjetos();
    void populaComboHabilidades();

    Ui::ConfigsObjNewSkillDialog *ui;
    SkillData *skillData;
    GameObject *gameObject;
    bool accepeted;

private slots:
    void on_buttonBox_rejected();
    void on_buttonBox_accepted();
    void on_checkBoxGetItem_released();
    void on_checkBoxAlways_released();
    void on_checkBoxLevel_released();
    void on_checkBoxGetItem_pressed();
    void on_checkBoxLevel_pressed();
    void on_checkBoxAlways_pressed();
    void on_checkBoxGetItem_toggled(bool checked);
    void on_checkBoxLevel_toggled(bool checked);
    void on_checkBoxAlways_toggled(bool checked);
    void on_comboBoxSkill_currentIndexChanged(int index);
};

#endif // CONFIGSOBJNEWSKILLDIALOG_H
#ifndef CONFIGSOBJNPCBEHAVIORWIDGET_H
#define CONFIGSOBJNPCBEHAVIORWIDGET_H

#include <QWidget>
#include <vector>

#include "optionscontroller.h"
#include "gameobject.h"
#include "gamedata.h"
#include "gameobject.h"

class OptionsController;
class GameObject;
class GameData;
class GameObject;

namespace Ui {
    class ConfigsObjNpcBehaviorWidget;
}

class ConfigsObjNpcBehaviorWidget : public QWidget
{
    Q_OBJECT

public:
    explicit ConfigsObjNpcBehaviorWidget(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem, QWidget *parent = 0);
    ~ConfigsObjNpcBehaviorWidget();



    void populaCampos();



private:
    Ui::ConfigsObjNpcBehaviorWidget *ui;
    OptionsController *optionsController;
    GameObject *gameObject;
    QListWidgetItem *currentListItem;
    bool ativaMudancaCombo;

private slots:
    void on_spinBoxPeriodicidade_valueChanged(double );
    void on_spinBoxMagicCost_valueChanged(int );
    void on_comboBoxItemEspada_currentIndexChanged(int index);
    void on_spinBoxRaioMovimentacao_valueChanged(int );
    void on_checkBox_toggled(bool checked);
    void on_spinBoxVelocidadeMovimentacao_valueChanged(int );
    void on_comboBoxItemDirecaoPersonagem_currentIndexChanged(int index);
    void on_comboBoxItemDirecaoEstiver_currentIndexChanged(int index);
    void on_spinBoxDanoUsaEspada_valueChanged(int );
    void on_spinBoxDanoEncostaPersonagem_valueChanged(int );
    void on_checkBoxAtacaAtiraItemMagiaDirPers_toggled(bool checked);
    void on_checkBoxAtacaAtiraItemMagiaDirEstiver_toggled(bool checked);
    void on_checkBoxAtacaUsaEspada_toggled(bool checked);
    void on_checkBoxAtacaEncostaNoPersonagem_toggled(bool checked);
    void on_checkBoxDerrotaPulandoSobre_toggled(bool checked);
    void on_checkBoxDerrotaAcertandoEspada_toggled(bool checked);
    void on_checkBoxDerrotaAtirandoItemMagia_toggled(bool checked);
    void on_checkBoxDerrotaEncostandoInimigo_toggled(bool checked);
    void on_comboBoxFormaMovimentacaoNpc_currentIndexChanged(int index);
    void on_spinBoxExperiencePoints_valueChanged(int );
};

#endif // CONFIGSOBJNPCBEHAVIORWIDGET_H



#ifndef CONFIGSOBJPHYSICSWIDGET_H
#define CONFIGSOBJPHYSICSWIDGET_H

#include <QWidget>

#include "optionscontroller.h"
#include "gameobject.h"

class OptionsController;
class GameObject;

namespace Ui {
    class ConfigsObjPhysicsWidget;
}

class ConfigsObjPhysicsWidget : public QWidget
{
    Q_OBJECT

public:
    explicit ConfigsObjPhysicsWidget(OptionsController *optionsController, GameObject *gameObject, QListWidgetItem *currentListItem, QWidget *parent = 0);
    ~ConfigsObjPhysicsWidget();




private:
    Ui::ConfigsObjPhysicsWidget *ui;
    OptionsController *optionsController;
    GameObject *gameObject;
    QListWidgetItem *currentListItem;

private slots:
    void on_spinCarVA_valueChanged(double );
    void on_checkBox_toggled(bool checked);
    void on_spinMouseObjectDA_valueChanged(double );
    void on_spinMouseObjectA_valueChanged(double );
    void on_spinMouseObjectV_valueChanged(double );
    void on_comboFormaMovimentoMouseObject_currentIndexChanged(int index);
    void on_comboTipoMovimentoMouseObject_currentIndexChanged(int index);
    void on_spinBouncingBallVY_valueChanged(double );
    void on_spinBouncingBallVX_valueChanged(double );
    void on_spinPlatformerIntensidadePulo_valueChanged(double );
    void on_spinPlatformerG_valueChanged(double );
    void on_spinPlatformerA_valueChanged(double );
    void on_spinPlatformerV_valueChanged(double );
    void on_comboTipoMovimentoPlatformer_currentIndexChanged(int index);
    void on_spinCarDA_valueChanged(double );
    void on_spinCarA_valueChanged(double );
    void on_spinCarV_valueChanged(double );
    void on_comboTipoMovimento_2_currentIndexChanged(int index);
    void on_spinDay_valueChanged(double );
    void on_spinDax_valueChanged(double );
    void on_spinAy_valueChanged(double );
    void on_spinAx_valueChanged(double );
    void on_spinVy_valueChanged(double );
    void on_spinVx_valueChanged(double );
    void on_comboTipoMovimento_currentIndexChanged(int index);
};

#endif // CONFIGSOBJPHYSICSWIDGET_H



#ifndef CONFIGSTABWIDGET_H
#define CONFIGSTABWIDGET_H

#include <QTabWidget>


#include "optionscontroller.h"
#include "configstilesetwidget.h"
#include "configsobjectswidget.h"
#include "configsgeneralwidget.h"
#include "configsanimations.h"
#include "configsbackgrounds.h"
#include "eventswidget.h"

class OptionsController;
class ConfigsTilesetWidget;
class ConfigsObjectsWidget;
class ConfigsGeneralWidget;
class ConfigsAnimations;
class ConfigsBackgrounds;
class EventsWidget;

namespace Ui {
    class ConfigsTabWidget;
}

class ConfigsTabWidget : public QTabWidget {
    Q_OBJECT
public:
    ConfigsTabWidget(QWidget *parent = 0);
    ~ConfigsTabWidget();

    void setOptionsController(OptionsController *optionsController);
    ConfigsTilesetWidget* getTilesetTab();
    ConfigsObjectsWidget* getObjectTab();
    ConfigsGeneralWidget* getDadosGeraisTab();
    ConfigsAnimations* getAnimationsTab();
    ConfigsBackgrounds* getBackgroundsTab();
    EventsWidget* getEventsTab();

    void selectObject(GameObject *gameObject);
    void selectObjectEvent(int idObject);

protected:
    void changeEvent(QEvent *e);

private:
    Ui::ConfigsTabWidget *ui;

    OptionsController *optionsController;
};

#endif // CONFIGSTABWIDGET_H
#ifndef CONFIGSTABWINDOW_H
#define CONFIGSTABWINDOW_H

#include <QDialog>

#include "configstilesetwidget.h"
#include "configsobjectswidget.h"
#include "configsgeneralwidget.h"
#include "configsanimations.h"
#include "configsbackgrounds.h"
#include "eventswidget.h"

#include "gameobject.h"

#include "optionscontroller.h"
#include "eventseditorcontroller.h"

class ConfigsTilesetWidget;
class ConfigsObjectsWidget;
class ConfigsGeneralWidget;
class ConfigsAnimations;
class ConfigsBackgrounds;
class EventsWidget;

class GameObject;

class OptionsController;
class EventsEditorController;



namespace Ui {
    class ConfigsTabWindow;
}

class ConfigsTabWindow : public QDialog {
    Q_OBJECT
public:
    ConfigsTabWindow(OptionsController *optionsController, EventsEditorController *eventsEditorController, QWidget *parent = 0);
    ~ConfigsTabWindow();

    ConfigsTilesetWidget* getTilesetTab();
    ConfigsObjectsWidget* getObjectTab();
    ConfigsGeneralWidget* getDadosGeraisTab();
    ConfigsAnimations* getAnimationsTab();
    ConfigsBackgrounds* getBackgroundsTab();
    EventsWidget* getEventsTab();


    void selectObject(GameObject *gameObject);

protected:
    void changeEvent(QEvent *e);

private:
    Ui::ConfigsTabWindow *ui;

    OptionsController *optionsController;
};

#endif // CONFIGSTABWINDOW_H
#ifndef CONFIGSTILESETDIALOGADDNEW_H
#define CONFIGSTILESETDIALOGADDNEW_H

#include <QDialog>
#include <QDir>
#include <QListWidgetItem>
#include <QImage>
#include <QPixmap>
#include <QFileDialog>
#include <QStringList>

#include <stdlib.h>

#include "gamedata.h"
#include "optionscontroller.h"
#include "messageboxes.h"

class GameData;
class OptionsController;
class MessageBoxes;

namespace Ui {
    class ConfigsTilesetDialogAddNew;
}

class ConfigsTilesetDialogAddNew : public QDialog {
    Q_OBJECT
public:
    ConfigsTilesetDialogAddNew(OptionsController *optionsController, QWidget *parent = 0);
    ~ConfigsTilesetDialogAddNew();

protected:
    void changeEvent(QEvent *e);

private:
    Ui::ConfigsTilesetDialogAddNew *ui;

    void populaLista();

    OptionsController *optionsController;

private slots:
    void on_botaoSelecionar_clicked();
    void on_botaoCancelar_clicked();
    void on_botaoImportar_clicked();
    void on_listWidget_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_listWidget_itemChanged(QListWidgetItem* item);
};

#endif // CONFIGSTILESETDIALOGADDNEW_H
#ifndef CONFIGSTILESETWIDGET_H
#define CONFIGSTILESETWIDGET_H

#include <stdio.h>
#include <stdlib.h>

#include <QWidget>

#include <vector>
#include <QListWidgetItem>

#include "tileset.h"

#include "configsimportdialog.h"
#include "optionscontroller.h"

#include "tilesetcolmapscene.h"

class ConfigsImportDialog;
class OptionsController;
class TileSet;
class TilesetColMapScene;

namespace Ui {
    class ConfigsTilesetWidget;
}

class ConfigsTilesetWidget : public QWidget {
    Q_OBJECT
public:
    ConfigsTilesetWidget(QWidget *parent = 0);
    ~ConfigsTilesetWidget();

    void setOptionsController(OptionsController *optionsController);

    void populaLista();

protected:
    void changeEvent(QEvent *e);

private:
    Ui::ConfigsTilesetWidget *ui;
    OptionsController *optionsController;


private slots:
    void on_spinBox_valueChanged(int );
    void on_lineEdit_textChanged(QString );
    void on_listWidget_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_pushButton_clicked();
};

#endif // CONFIGSTILESETWIDGET_H
#ifndef EASYNEWGAMEOBJECTDIALOG_H
#define EASYNEWGAMEOBJECTDIALOG_H

#include <QDialog>
#include <QGraphicsPixmapItem>
#include <QGraphicsScene>

#include "gameobject.h"
#include "gamedata.h"
#include "messageboxes.h"
#include "configsobjanimationchooserwindow.h"
#include "optionscontroller.h"

class GameObject;
class GameData;
class MessageBoxes;
class ConfigsObjAnimationChooserWindow;
class OptionsController;

namespace Ui {
    class EasyNewGameObjectDialog;
}

class EasyNewGameObjectDialog : public QDialog
{
    Q_OBJECT

public:
    explicit EasyNewGameObjectDialog(OptionsController *optionsController, QWidget *parent = 0);
    ~EasyNewGameObjectDialog();

    void populaCombosObjetos();
    void habilitaCheckBoxes();

    void preencheComboMovementStyle();


    GameObject* exec();


private slots:
    void on_comboBoxType_currentIndexChanged(int index);

    void on_buttonBox_accepted();

    void on_buttonBox_rejected();

    void on_pushButtonEditGraphics_pressed();

private:
    Ui::EasyNewGameObjectDialog *ui;


    GameObject *gameObject;
    QGraphicsPixmapItem *item;
    QGraphicsScene *scene;
    OptionsController *optionsController;


    static const int MOVEMENT_SSLOW = 0;
    static const int MOVEMENT_SLOW = 1;
    static const int MOVEMENT_FAST = 2;
    static const int MOVEMENT_FFAST = 3;
    static const int MOVEMENT_SFAST = 4;
};

#endif // EASYNEWGAMEOBJECTDIALOG_H
#ifndef EDITORCONSTANTS_H
#define EDITORCONSTANTS_H

class EditorConstants
{
public:
    EditorConstants();

    static const int IMPORT_OPTION_TITLE_SCREEN = 0;
    static const int IMPORT_OPTION_OPTION_SCREEN = 1;
    static const int IMPORT_OPTION_GAME_OVER_SCREEN = 2;


};

#endif // EDITORCONSTANTS_H
#ifndef EVENTATTRIBUTEDATA_H
#define EVENTATTRIBUTEDATA_H


#include <iostream>

#include <string>
#include <list>

class EventAttributeData
{
public:
    EventAttributeData(std::string name, std::list<int> *conditions, std::list<int> *actions);
    EventAttributeData();


    std::list<int> *conditions;
    std::list<int> *actions;

    int id;
    std::string name;

    int type;
    int specialComboType;
    int test1;
    int test2;
    int test3;
    bool showNumberValueCombo;
    bool showVariableValueCombo;
    bool showObjectFieldCombo;
    bool showDirectionInput;
    bool showObject02;
    bool dummy;




    bool isObjectType();
    bool isNothingType();
    bool showValueGroup();


    static const int COMBO_TYPE_NONE            = 0;
    static const int COMBO_TYPE_KEY             = 4;
    static const int COMBO_TYPE_MOUSE           = 5;
    static const int COMBO_TYPE_MUSIC           = 6;
    static const int COMBO_TYPE_SOUND           = 7;
    static const int COMBO_TYPE_MAP             = 8;
    static const int COMBO_TYPE_PROCEDURE             = 9;

};

#endif // EVENTATTRIBUTEDATA_H
#ifndef EVENTCOMBODATAPROVIDER_H
#define EVENTCOMBODATAPROVIDER_H

#include <iostream>
#include <map>
#include <list>
#include <vector>
#include <string>
#include <sstream>
#include <QString>
#include <QList>

#include "eventattributedata.h"
#include "gameobject.h"
#include "specialcombovaluedata.h"
#include "gamedata.h"
#include "map.h"

class EventAttributeData;
class GameObject;
class SpecialComboValueData;
class GameData;
class Map;

class EventComboDataProvider
{
public:

    static EventComboDataProvider* getInstance();

    EventAttributeData* getAttribute(int index);
    QString getConditionString(int index);
    QString getActionString(int index);
    std::list<GameObject*> getSpecialObjectList(int eventType);
    std::list<SpecialComboValueData*> getSpecialComboValueList(int specialType, GameObject *gameObject);

    bool isNoValueAction(int action);
    bool isNoValueCondition(int condition);



    static const int ID_SPECIAL_GLOBAL =    -1;
    static const int ID_SPECIAL_JOYSTICK =  -2;
    static const int ID_SPECIAL_TIMER =     -3;
    static const int ID_SPECIAL_MUSIC =     -4;

    static const int ATT_POSITION_X =       0;
    static const int ATT_POSITION_Y =       1;
    static const int ATT_VELOCITY =         2;
    static const int ATT_VELOCITY_X =       3;
    static const int ATT_VELOCITY_Y =       4;
    static const int ATT_ACCELERATION =     5;
    static const int ATT_ACCELERATION_X =   6;
    static const int ATT_ACCELERATION_Y =   7;

    static const int ATT_GRAVITY =          8;
    static const int ATT_JUMP_INTENSITY =   9;
    static const int ATT_HP =               10;
    static const int ATT_MP =               11;
    static const int ATT_ATK =              12;
    static const int ATT_DEF =              13;
    static const int ATT_INT =              14;

    static const int ATT_DIRECTION =        15;
    static const int ATT_ANIMATION =        16;
    static const int ATT_ROTATION =         17;
    static const int ATT_ZOOM =             18;

    static const int ATT_COLISION =         19;

    static const int ATT_KEY =              20;
    static const int ATT_MOUSE =            21;

    static const int ATT_SOUND =            22;
    static const int ATT_MUSIC =            23;

    static const int ATT_MAP =              24;

    static const int ATT_PROCEDURE =        25;

    static const int ATT_TIMER =                    26;

    static const int ATT_SPECIAL_BOUNCING_BALL =    27; // não implementado
    static const int ATT_SPECIAL_EIGHT_MOVEMENT =   28; // não implementado
    static const int ATT_SPECIAL_PLATFORM_MOVEMENT =    29;

    static const int ATT_MOVEMENT                     =   30;

    static const int ATT_INSTANCE_NUMBER              =   31;

    static const int ATT_THROWER                      =   32;

    static const int ATT_FOLLOWER                     =   33;

    static const int ATT_SIDES                        =   34;

    static const int ATT_GAME_TIMER                     = 35;
    static const int ATT_MAP_TIMER                      = 36;

    static const int ATT_OBJECT_LEVEL                   = 37;


    static const int ATT_VARIABLES                    =  300;

    // adicionar: pontuação




    static const int COND_EQUAL                 = 0;
    static const int COND_DIFFERENT             = 1;
    static const int COND_LESS                  = 2;
    static const int COND_LESS_EQUAL            = 3;
    static const int COND_GREATER               = 4;
    static const int COND_GREATER_EQUAL         = 5;

    static const int COND_DETECT_SIMPLE_COLLISION   = 6;
    static const int COND_DETECT_PIXEL_COLLISION    = 7;

    static const int COND_BUTTON_PRESSED        = 8;
    static const int COND_BUTTON_DOWN           = 9;
    static const int COND_MOUSE_BUTTON_PRESSED  = 10;
    static const int COND_MOUSE_BUTTON_DOWN     = 11;

    static const int COND_IS_MUSIC_PLAYING      = 12;
    static const int COND_IS_SOUND_PLAYING      = 13;

    static const int COND_IS_CURRENT_MAP        = 14;

    static const int COND_EVERY_SECONDS         = 15;

    static const int COND_IS_LEFT_SIDE          = 16;
    static const int COND_IS_UP_SIDE            = 17;
    static const int COND_IS_RIGHT_SIDE         = 18;
    static const int COND_IS_DOWN_SIDE          = 19;



    static const int ACTION_SET_VALUE           = 0;
    static const int ACTION_ADD_VALUE           = 1;
    static const int ACTION_MULT_VALUE          = 2;
    static const int ACTION_DIV_VALUE           = 3;

    static const int ACTION_PLAY_MUSIC          = 4;
    static const int ACTION_TOOGLE_PAUSE_MUSIC  = 5;
    static const int ACTION_STOP_MUSIC          = 6;
    static const int ACTION_PLAY_SOUND          = 7;
    static const int ACTION_TOGGLE_PAUSE_SOUND  = 8;
    static const int ACTION_STOP_SOUND          = 9;

    static const int ACTION_SET_MAP             = 10;
    static const int ACTION_RESET_MAP           = 11;

    static const int ACTION_CALL_PROCEDURE      = 12;

    static const int ACTION_RESET_MAP_TIMER     = 13;
    static const int ACTION_RESET_GAME_TIMER    = 14;

    static const int ACTION_PLATFORM_JUMP       = 15;

    static const int ACTION_BOUNCE              = 16;
    static const int ACTION_BOOST               = 17;

    static const int ACTION_THROW_OBJECT               = 18;

    static const int ACTION_FOLLOW_OBJECT              = 19;
    static const int ACTION_UNFOLLOW_OBJECT             = 20;

    static const int SDLK_UP	= 273;
    static const int SDLK_DOWN  = 274;
    static const int SDLK_RIGHT	= 275;
    static const int SDLK_LEFT	= 276;

    static const int SDLK_a			= 97;
    static const int SDLK_b			= 98;
    static const int SDLK_c			= 99;
    static const int SDLK_d			= 100;
    static const int SDLK_e			= 101;
    static const int SDLK_f			= 102;
    static const int SDLK_g			= 103;
    static const int SDLK_h			= 104;
    static const int SDLK_i			= 105;
    static const int SDLK_j			= 106;
    static const int SDLK_k			= 107;
    static const int SDLK_l			= 108;
    static const int SDLK_m			= 109;
    static const int SDLK_n			= 110;
    static const int SDLK_o			= 111;
    static const int SDLK_p			= 112;
    static const int SDLK_q			= 113;
    static const int SDLK_r			= 114;
    static const int SDLK_s			= 115;
    static const int SDLK_t			= 116;
    static const int SDLK_u			= 117;
    static const int SDLK_v			= 118;
    static const int SDLK_w			= 119;
    static const int SDLK_x			= 120;
    static const int SDLK_y			= 121;
    static const int SDLK_z			= 122;

    static const int SDLK_ESCAPE		= 27;
    static const int SDLK_RETURN		= 13;
    static const int SDLK_SPACE                 = 32;
    static const int SDLK_RSHIFT		= 303;
    static const int SDLK_LSHIFT		= 304;
    static const int SDLK_RCTRL                 = 305;
    static const int SDLK_LCTRL                 = 306;
    static const int SDLK_RALT                  = 307;
    static const int SDLK_LALT                  = 308;



private:
    EventComboDataProvider();
    void pushAttributeData(int id, QString name, std::list<int> *conditions, std::list<int> *actions,
                           bool showNumberValueCombo, bool showVariableValueCombo,
                           bool showObjectFieldCombo, bool showDirectionInput,
                           bool showObject02, int specialComboType);
    void pushConditionData(int id, QString name);
    void pushActionData(int id, QString name);

    void pushSpecialComboData(std::list<SpecialComboValueData*> *list, int code, std::string string);

    std::map<int, EventAttributeData*> eventMap;
    std::map<int, std::string> conditionMap;
    std::map<int, std::string> actionMap;

    std::list<GameObject*> specialObjectList;

    static EventComboDataProvider *singleton;

};

#endif // EVENTCOMBODATAPROVIDER_H
#ifndef EVENTDATA_H
#define EVENTDATA_H

#include <string>
#include <list>
#include <sstream>

#include <QString>
#include <QIcon>

#include "eventcombodataprovider.h"
#include "gamedata.h"

class EventComboDataProvider;
class GameData;

class EventData
{
public:
    EventData();

    EventData* parent;

    bool newEvent;
    int type;
    int conditionType;


    int opcode;
    int idObject01;
    int instanceTypeObject01;
    int idAssociatedVariable;
    int idObject02;
    int instanceTypeObject02;
    float value01;
    float value02;
    float value03;
    std::string expression;
    std::string stringValue;

    int valueType;

    std::list<EventData*> subEvents;

    EventComboDataProvider *eventComboDataProvider;

    QString getEventString(GameObject *currentGameObject);
    QIcon getEventIcon();
    QIcon getObject01Icon();
    QIcon getObject02Icon();

    void addChild(EventData *child);


    static const int TYPE_CONDITION = 0;
    static const int TYPE_ACTION = 1;

    static const int VALUE_TYPE_NUMBER = 0;
    static const int VALUE_TYPE_VARIABLE = 1;
    static const int VALUE_TYPE_OBJECT_ATTRIBUTE = 2;
    static const int VALUE_TYPE_SPECIAL = 3;
    static const int VALUE_TYPE_OBJECT2 = 4;

    static const int TYPE_CONDITION_IF = 0;
    static const int TYPE_CONDITION_IF_ELSE = 1;
    static const int TYPE_CONDITION_ELSE = 2;
    static const int TYPE_CONDITION_WHILE = 3;
    static const int TYPE_CONDITION_FOR = 4;
};

#endif // EVENTDATA_H
#ifndef EVENTSEDITORCONTROLLER_H
#define EVENTSEDITORCONTROLLER_H

#include <list>

#include "maincontroller.h"

#include "gamedata.h"
#include "eventdata.h"
#include "neweventdialog.h"
#include "eventcombodataprovider.h"
#include "eventattributedata.h"
#include "gameobject.h"
#include "proceduredata.h"
#include "map.h"

class MainController;

class GameData;
class EventData;
class NewEventDialog;
class EventComboDataProvider;
class EventAttributeData;
class GameObject;
class ProcedureData;
class Map;

class EventsEditorController
{
public:
    EventsEditorController();

    void setMainController(MainController*);
    void openNewConditionWindow(EventData *eventData, GameObject *gameObject);
    void openNewActionWindow(EventData *eventData, GameObject *gameObject);
    void openEditEventWindow(EventData *eventData, GameObject *gameObject);

    ProcedureData* addProcedure();
    ProcedureData* addProcedure(GameObject *gameObject);
    ProcedureData* addProcedure(Map *map);

    std::list<EventAttributeData*> getComboAttributes(GameObject *gameObject, int eventType);
    QString getComboConditionString(int index);
    QString getComboActionString(int index);
    std::vector<GameObject*> getContextObjects(EventData *eventData);
    std::list<GameObject*> getSpecialGameObjects(int eventType);
    std::list<SpecialComboValueData*> getSpecialComboValueList(int specialType, GameObject *gameObject);

    bool isNoValueAction(int action);
    bool isNoValueCondition(int condition);




private:
    ProcedureData* addProcedure(GameObject *gameObject, Map *map);


    MainController *mainController;
    EventComboDataProvider *eventComboDataProvider;
};

#endif // EVENTSEDITORCONTROLLER_H
#ifndef EVENTSWIDGET_H
#define EVENTSWIDGET_H

#include <QWidget>
#include <QTreeWidgetItem>
#include <QListWidgetItem>
#include <QMenu>
#include <QAction>

#include "gamedata.h"
#include "gameobject.h"
#include "eventseditorcontroller.h"
#include "newvariabledialog.h"

class GameData;
class GameObject;

class EventsEditorController;
class NewVariableDialog;


namespace Ui {
    class EventsWidget;
}

class EventsWidget : public QWidget
{
    Q_OBJECT

public:
    explicit EventsWidget(QWidget *parent = 0);
    ~EventsWidget();

    void setEventsEditorController(EventsEditorController *eventsEditorController);


    void selectObject(int idObject);

private:
    Ui::EventsWidget *ui;


    void populaComboTarget();
    void populaListaProcedures();
    void populaEventTree();
    void populaVariableList();
    void setTreeWidgetItemData(QTreeWidgetItem *widgetItem, EventData* eventData);
    void populaSubEventTree(QTreeWidgetItem *parent, std::list<EventData*> *events);


    void activateNewEventItemMenu(QTreeWidgetItem *item);
    void activateCreatedEventItemMenu(QTreeWidgetItem *item);




    EventsEditorController *eventsEditorController;


private slots:
    void on_treeWidgetEvents_itemDoubleClicked(QTreeWidgetItem* item, int column);
    void on_listWidgetProcedures_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_comboBoxTarget_currentIndexChanged(int index);
    void on_pushButtonNewProc_pressed();
    void on_lineEditProcedureName_textChanged(QString );
    void on_pushButtonNewVar_pressed();
    void on_pushButtonEditVar_pressed();
};

#endif // EVENTSWIDGET_H

#ifndef GAMEDATA_H
#define GAMEDATA_H

#include <string>
#include <vector>
#include <iostream>
#include <sstream>

#include <stdio.h>
#include <stdlib.h>

#include <QDir>

#include "map.h"
#include "tileset.h"
#include "gameobject.h"
#include "titlescreendata.h"
#include "animationdata.h"
#include "background.h"
#include "skill.h"
#include "proceduredata.h"
#include "variabledata.h"
#include "eventdata.h"


class Map;
class TileSet;
class GameObject;
class TitleScreenData;
class AnimationData;
class Background;
class Skill;
class ProcedureData;
class VariableData;
class EventData;


class GameData
{
public:

    virtual ~GameData();
    static GameData *getInstance();

    static int MAGIC_NUMBER;


    std::string *gameName;
    int resWidth, resHeight;

    static GameData *singleton;


    /* lista de tilesets */
    std::vector<TileSet*> *tileSetList;
    /* lista de mapas */
    std::vector<Map*> *mapList;
    /* lista de objetos */
    std::vector<GameObject*> *objectList;
    /* lista de animations */
    std::vector<AnimationData*> *animationDataList;
    /* lista de backgrounds */
    std::vector<Background*> *backgroundList;
    /* lista de variáveis globais */
    std::vector<VariableData*> *variableList;



    ProcedureData *procedureGlobalAlways;
    ProcedureData *procedureGlobalStart;
    ProcedureData *procedureGlobalEnd;

    std::vector<ProcedureData*> *procedureList;




    std::vector<Skill*> *skillList;

    Map *editingMap;

    int idFirstMap;

    TitleScreenData titleScreenData;
    std::string optionsScreenFile;
    std::string gameoverScreenFile;

    std::string titleScreenMusic;
    int loopTitleScreenMusic;
    std::string optionsScreenMusic;
    int loopOptionsScreenMusic;
    std::string gameOverScreenMusic;
    int loopGameOverScreenMusic;

    void createInstance(std::string gameName, std::string folderName);
    void erase();

    bool load(std::string fileName);
    bool save(std::string fileName);



    std::string getProjectDirectory();

    void addTileset(TileSet *tileSet);
    void addAnimation(AnimationData *animationData);
    void addGameObject(GameObject *gameObject);
    void addBackground(Background *background);
    void addProcedure(ProcedureData *procedureData);
    void addVariable(VariableData *variableData);

    void setTitleScreenFile(std::string fileName);
    void setOptionsScreenFile(std::string fileName);
    void setGameOverScreenFile(std::string fileName);

    TileSet* searchTilesetById(int id);
    GameObject* searchGameObjectById(int id);
    AnimationData* searchAnimationDataById(int id);
    Background* searchBackgroundById(int id);
    Skill* searchSkillById(int id);
    ProcedureData* getProcedureById(int id);
    VariableData* getVariableById(int id);



    /* os parametros abaixo nao devem ser gravados */
    std::string filePath;
    int generateNewMapId();

private:
    GameData();
    void createDirectoryStructure(std::string *filePath);
    void createSubDirectory(std::string *filePath, std::string dir);
    int generateNewTilesetId();
    int generateNewAnimationId();
    int generateNewGameObjectId();
    int generateNewBackgroundId();
    int generateNewProcedureId();
    int generateNewVariableId();

    int generateNewMapIdPercorreArvore(std::vector<Map*> *mapList, int id);

    char* loadString(FILE *fp);
    void saveString(std::string *string, FILE *fp);

    bool saveTilesetList(FILE *fp);
    bool loadTilesetList(FILE *fp);



    bool saveMapList(FILE *fp, std::vector<Map*>* list);
    std::vector<Map*>* loadMapList(FILE *fp);

    bool saveObjectList(FILE *fp);
    bool loadObjectList(FILE *fp);

    bool saveObjectSkills(FILE *fp);
    bool loadObjectSkills(FILE *fp);

    bool saveAnimationDataList(FILE *fp);
    bool loadAnimationDataList(FILE *fp);

    bool saveBackgroundList(FILE *fp);
    bool loadBackgroundList(FILE *fp);

    bool saveProcedureList(FILE *fp, std::vector<ProcedureData*> *procedureList);
    std::vector<ProcedureData*>* loadProcedureList(FILE *fp);

    bool saveProcedure(ProcedureData *procedureData, FILE *fp);
    ProcedureData *loadProcedure(FILE *fp);

    bool saveAllEvents(FILE *fp);
    bool loadAllEvents(FILE *fp);

    bool saveVariable(VariableData *variable, FILE *fp);
    VariableData* loadVariable(FILE *fp);

    bool saveAllVariableLists(FILE *fp);
    bool loadAllVariableLists(FILE *fp);

    bool saveEventList(FILE *fp, std::list<EventData*>* eventFunctionList);
    std::list<EventData*> loadEventList(FILE *fp, EventData *parent = 0);

};

#endif // GAMEDATA_H
#ifndef GAMEOBJECTANIMATION_H
#define GAMEOBJECTANIMATION_H

#include <string>
#include <vector>

#include <stdio.h>

#include "sprite.h"
#include "animationdata.h"
#include "point.h"

class Sprite;
class AnimationData;
class Point;

class GameObjectAnimation
{
public:
    GameObjectAnimation();

    int id;
    int type;

    std::string name;

    std::vector<Sprite*> *sprites;
    std::vector<AnimationData*> *animations;
    std::vector<int> *types;
    std::vector<bool> horizontalInvert;
    std::vector<bool> verticalInvert;
    std::vector<Point> adjustments;


    int numDirectionFactor;


    static const int STATIC = 1;
    static const int ANIMATED = 2;
};

#endif // GAMEOBJECTANIMATION_H
#ifndef GAMEOBJECT_H
#define GAMEOBJECT_H

#include <string>
#include <vector>
#include <QPixmap>
#include <QImage>

#include "gamedata.h"
#include "sprite.h"
#include "gameobjectanimation.h"
#include "skilldata.h"
#include "proceduredata.h"
#include "variabledata.h"

class GameData;
class Sprite;
class GameObjectAnimation;
class SkillData;
class ProcedureData;
class VariableData;

class GameObject
{
public:
    GameObject();
    GameObject(int specialId);


    static const int EIGHT_MOVEMENT_OBJECT = 0;
    static const int CAR_MOVEMENT_OBJECT = 1;
    static const int PLATFORM_MOVEMENT_OBJECT = 2;
    static const int FIGHTING_MOVEMENT_OBJECT = 3;
    static const int PONG_BALL_OBJECT = 4;
    static const int MOUSE_MOVEMENT_OBJECT = 5;
    static const int STATIC_OBJECT = 6;
    static const int NPC = 7;
    static const int INIMIGO = 8;
    static const int ITEM = 9;
    static const int SPECIAL = 10;


    int id;
    std::string name;
    std::string specialIconPath;
    int type;


    bool isObjetoUnico;
    int formaGrafica;
    int tipoMovimento;
    int formaMovimentoMouse;
    float vx, vy, ax, ay, dax, day;
    float gravidade, intensidadePulo;
    bool evolucaoPorNivel;

    std::vector<GameObjectAnimation*> *gameObjectAnimations;

    std::string getIconString();
    QImage getIconImage();


    /* novos dados - atributos - pendentes de gravacao */
    int hp, mp, atk, def, intelig;
    int levelInicial, levelMax;
    int velocidadeEvolucao;
    bool resolveCollision;

    bool movimentaApenasDentroTela;

    /* para uso comum de Item, NPC e Inimigo  */
    int formaMovimentacaoNpcItem;
    int raioMovimentacao;

    /* comportamento Inimigo */

    bool derrotaEncostandoInimigo;
    bool derrotaAtirandoItemMagiaInimigo;
    bool derrotaAcertandoEspadaSobreInimigo;
    bool derrotaPulandoSobreInimigo;
    bool atacaEncostaPersonagem;
    int atacaEncostaPersonagemDano;
    bool atacaUsandoEspada;
    int espadaItemId;
    int atacaUsandoEspadaDano;

    bool atiraItemMaginaDirecaoEstiver;
    int atiraItemMaginaDirecaoEstiverIdItem;
    int atiraItemMaginaDirecaoEstiverDano;

    bool atiraItemMagiaDirecaoPersonagem;
    int atiraItemMagiaDirecaoPersonagemIdItem;
    int atiraItemMagiaDirecaoPersonagemDano;

    int experiencePoints;


    int magicCost;
    float tempoAtaque;

    /* apenas NPC */
    int nroFalas;

    /* dados Item */
    bool concedePontos;
    int concedePontosValor;
    bool ganhaPerdeVida;
    int ganhaPerdeVidaValor;
    bool ganhaPerdeMagia;
    int ganhaPerdeMagiaValor;
    bool incrementaVariavel;
    int incrementaVariavelIdVariavel;
    int incrementaVariavelValor;
    bool ativaEvento;
    int ativaEventoIdEvento;
    bool concedeHabilidade;
    int concedeHabilidadeIdHabilidade;

    int comportamentoEncostarPersonagem;
    bool desapareceEncostarPersonagem;
    bool desapareceEncostarParede;



    /* geral */
    std::vector<SkillData*> listaHabilidades;

    bool possuiEventos;



    ProcedureData *procedureGlobalAlways;
    ProcedureData *procedureGlobalStart;
    ProcedureData *procedureGlobalEnd;

    std::vector<ProcedureData*> *procedureList;
    std::vector<VariableData*> *variableList;


    void addProcedure(ProcedureData *procedureData);
    void addVariable(VariableData *variableData);
    ProcedureData *getProcedureById(int id);
    VariableData *getVariableById(int id);




private:
    int generateNewProcedureId();
    int generateNewVariableId();

};

#endif // GAMEOBJECT_H
#ifndef GAMEOBJECTINSTANCE_H
#define GAMEOBJECTINSTANCE_H

#include "gameobject.h"

class GameObject;

class GameObjectInstance
{
public:
    GameObjectInstance(GameObject* gameObject);

    unsigned int id;
    GameObject *gameObject;

    int x, y;

    int nroEventos;
    int nroFalas;

    /* modificacoes M01 */
    bool isCenter;
    bool isMainObject;
};

#endif // GAMEOBJECTINSTANCE_H
#ifndef IMAGEITEM_H
#define IMAGEITEM_H

#include <QGraphicsRectItem>
#include <QImage>

class ImageItem : public QGraphicsRectItem
{
public:
    ImageItem(QImage *image, int posx, int posy);
};

#endif // IMAGEITEM_H
#ifndef MAINCONTROLLER_H
#define MAINCONTROLLER_H

#include <QSplashScreen>
#include <QPixmap>
#include <QVBoxLayout>
#include <QPushButton>
#include <QMessageBox>
#include <QProcess>

#include <string>


#include "mapeditorcontroller.h"
#include "optionscontroller.h"
#include "wizardcontroller.h"
#include "eventseditorcontroller.h"
#include "mainwindow.h"
#include "newprojectwindow.h"
#include "gamedata.h"

class MapEditorController;
class OptionsController;
class WizardController;
class EventsEditorController;
class MainWindow;
class NewProjectWindow;



class MainController
{
public:
    MainController();

    void setMapEditorController(MapEditorController*);
    void setOptionsController(OptionsController*);
    void setWizardController(WizardController*);
    void setEventsEditorController(EventsEditorController*);

    void setEditorMode(int mode);
    void setEditorModeIconEnabled(int mode);
    void setEditorDrawMode(int mode);

    void openNewProjectWindow();
    void openConfigsTabWindow();
    void openConfigsTabWindow(GameObject* gameObject);
    void openNewProject(std::string nomeJogo, std::string nomePasta);
    void changeWindowTitle();
    void loadProject(std::string fileName);
    void saveProject();
    void runRuntime();

    void reloadEditorInterface();

    void openEasyNewGameObjectDialog();


    void init();
private:
    MapEditorController *mapEditorController;
    OptionsController *optionsController;
    WizardController *wizardController;
    EventsEditorController *eventsEditorController;

    MainWindow *mainWindow;
    NewProjectWindow *newProjectWindow;

    QVBoxLayout *layout;
};

#endif // MAINCONTROLLER_H
#ifndef MAIN_H
#define MAIN_H

class Main
{
public:
    Main();
};

#endif // MAIN_H
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <stdlib.h>

#include <QtGui/QMainWindow>
#include <QDesktopWidget>
#include <QRect>
#include <QPoint>

#include <QFileDialog>

#include "maincontroller.h"
#include "mapeditorcontroller.h"

class MainController;
class MapEditorController;

namespace Ui {
    class MainWindow;
}

class MainWindow : public QMainWindow {
    Q_OBJECT
public:
    MainWindow(QWidget *parent = 0, MainController *mainController = NULL);
    ~MainWindow();

    void moveToCenter();
    QWidget* getMainWindowWidget();

    void enableMainButtons();

    void setEditorModeIconEnabled(int mode);

protected:
    void changeEvent(QEvent *e);

private:
    Ui::MainWindow *m_ui;
    MainController *mainController;

private slots:
    void on_actionEventMode_triggered(bool checked);
    void on_actionObjectMode_triggered(bool checked);
    void on_actionMapMode_triggered(bool checked);
    void on_actionRodar_triggered();
    void on_actionSalvar_Projeto_triggered();
    void on_actionAbrir_Projeto_triggered();
    void on_actionConfiguracoes_triggered();
    void on_actionSelecaoCirculo_activated();
    void on_actionSelecionaQuadrado_activated();
    void on_actionPintaCirculo_activated();
    void on_actionPintaBloco_activated();
    void on_actionPintaQuadrado_activated();
    void on_actionPintaBloco_triggered();
    void on_actionPintaTile_activated();
    void on_actionNovo_Projeto_triggered();
    void on_actionApagaBloco_activated();
};

#endif // MAINWINDOW_H
#ifndef MAINWINDOWWIDGET_H
#define MAINWINDOWWIDGET_H

#include <QWidget>

class MainWindowWidget : public QWidget
{
    Q_OBJECT
public:
    MainWindowWidget(QWidget *parent);
};

#endif // MAINWINDOWWIDGET_H
#ifndef MAPEDITORCONTROLLER_H
#define MAPEDITORCONTROLLER_H

#include <QVBoxLayout>
#include <QScrollBar>
#include <stdio.h>
#include <stdlib.h>
#include <QInputDialog>

#include <list>
#include <algorithm>
#include <QList>

#include "maincontroller.h"
#include "tilesetdock.h"
#include "mapselectdock.h"
#include "mainwindow.h"
#include "tilemapview.h"
#include "tilemapscene.h"
#include "objectsdock.h"
#include "tileitem.h"
#include "newmapwindow.h"
#include "gamedata.h"
#include "map.h"
#include "tileset.h"
#include "gameobject.h"


class TilesetDock;
class ObjectsDock;
class MapSelectDock;
class MainController;
class TilemapScene;
class MainWindow;
class NewMapWindow;
class GameData;
class Map;
class Tileset;
class GameObject;


class MapEditorController
{
public:
    MapEditorController();

    void setMainController(MainController*);

    void init(MainWindow *mainWindow, QWidget *parent, QVBoxLayout *layout);

    void initMapScene();
    void initTileScene();
    void initMapSelectScene();
    void initObjectsDock();

    void reloadEditorInterface();



    void setDrawTile(int iDrawTile, int jDrawTile, int diDrawTile, int djDrawTile);
    void changeTile(int i, int j);
    void changeTiles(int iStart, int jStart, int iEnd, int jEnd);
    void floodFill(int nodeI, int nodeJ, int targetI, int targetJ, int replacementI, int replacementJ);
    void floodFillBrute(int nodeI, int nodeJ, int targetI, int targetJ, TileSet *targetTileset, int replacementI, int replacementJ, TileSet *replacementTileset);
    void openNewMapWindow();
    void openEditMapWindow(Map *map);
    void createNewMap(Map *newMap);
    void refreshMapWidgets();
    void createFolder();
    void selectMap(Map *map);
    void setCurrentObjectAtCursor();

    void selectDefaultMap();
    void setEditorMode(int mode);
    void setEditorDrawMode(int mode);

    int setMapEditorLayer(int layer);

    void openConfigsTabWindow(GameObject* gameObject);
    void openEasyNewGameObjectDialog();

    Map* getSelectedMap();
    GameObject* getSelectedObject();


    int iDrawTile, jDrawTile, diDrawTile, djDrawTile;
    int iClick, jClick;

    TileSet *drawTileset;

    bool mapSceneInitializated;
    bool tileSceneInitializated;
    bool mapSelectSceneInitializated;
    bool objectsDockInitializated;


    int editorMode;
    int drawMode;
    static const int MODE_MAP = 0;
    static const int MODE_OBJECT = 1;
    static const int MODE_EVENT = 3;


    static const int DRAW_MODE_PENCIL = 0;
    static const int DRAW_MODE_ERASER = 1;
    static const int DRAW_MODE_PAINT =  2;
    static const int DRAW_MODE_SQUARE = 3;
    static const int DRAW_MODE_CIRCLE = 4;
    static const int DRAW_MODE_SELECT_SQUARE = 5;
    static const int DRAW_MODE_SELECT_CIRCLE = 6;

private:
    MainController *mainController;

    MainWindow *mainWindow;

    TilesetDock *tilesetDock;
    MapSelectDock *mapSelectDock;
    ObjectsDock *objectsDock;

    TilemapView *tilemapView;
    TilemapScene *tilemapScene;

    NewMapWindow *newMapWindow;

    int editorLayer;



};

#endif // MAPEDITORCONTROLLER_H
#ifndef MAP_H
#define MAP_H

#include <string>
#include <stdio.h>
#include <stdlib.h>
#include <boost/multi_array.hpp>
#include <boost/multi_array/iterator.hpp>
#include <stdio.h>

#include <vector>

#include "point.h"
#include "tileset.h"
#include "gameobject.h"
#include "gameobjectinstance.h"
#include "teleportarea.h"
#include "background.h"

class Point;
class TileSet;
class GameObject;
class GameObjectInstance;
class TeleportArea;
class Background;

using namespace boost;

class Map
{
public:
    Map();
    Map(std::string mapName, int width, int height, int layers);
    Map(std::string folderName, std::vector<Map *> *mapasFilhos);

    void extent(int width, int height, int layers);
    void extent(int layers);
    void setTile(int i, int j, int layer, int xvalue, int yvalue);
    bool isFolder();

    bool verifyTileFilled(int layer);

    std::vector<Map *> *filhos;

    std::string mapName;
    int key;

    multi_array<Point, 3> map;
    std::vector<TileSet *> *tileSets;
    std::vector<GameObject *> *gameObjects;

    int **tileMap;
    int width, height, layers;


    std::string music;
    std::string sound;
    int loopMusic;
    int loopSound;
    int idFundo;
    std::vector<GameObjectInstance *> *gameObjectInstances;



    std::vector<TeleportArea*> *teleportAreas;

    /* pendentes de gravacao: */
    Background *background;


};

#endif // MAP_H
#ifndef MAPSELECTDOCK_H
#define MAPSELECTDOCK_H

#include <QObject>
#include <QDockWidget>
#include <QTreeView>
#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QList>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QStringListModel>
#include <QPushButton>

#include <vector>

#include <stdio.h>
#include <stdlib.h>

#include "mapeditorcontroller.h"
#include "gamedata.h"
#include "map.h"

class MapEditorController;
class GameData;
class Map;


class MapSelectDock : public QDockWidget
{
    Q_OBJECT
public:
    MapSelectDock(QWidget *parent, MapEditorController *mapEditorController);

    MapEditorController *mapEditorController;

    QTreeView *treeView;
    QTreeWidget *treeWidget;
    QVBoxLayout *vboxLayout;
    QHBoxLayout *hboxLayout;
    QStringListModel *model;

    QPushButton *botaoCriaMapa, *botaoEditaMapa, *botaoDeletaMapa, *botaoCriaPasta;

    QWidget *widget;

    void initMapSelectScene();

    void populaArvore();
    Map* getMapaSelecionado();

    void selectDefaultMap();


private:
    void populaSubpastas(std::vector<Map*> *subarvore, QTreeWidgetItem* item);

private slots:
    void botaoCriaMapaClicked();
    void botaoCriaPastaClicked();
    void botaoEditaMapaClicked();
    void treeWidgetItemClicked(QTreeWidgetItem*,int);

};

#endif // MAPSELECTDOCK_H
#ifndef MESSAGEBOXES_H
#define MESSAGEBOXES_H

#include <QMessageBox>
#include <string>

class MessageBoxes
{
public:
    MessageBoxes();


    static void showMessageBox(std::string message);
    static void showMessageBox(QString message);
    static bool showConfirmBox(std::string message);

};

#endif // MESSAGEBOXES_H
#ifndef NEWEVENTAREADIALOG_H
#define NEWEVENTAREADIALOG_H

#include <QDialog>

namespace Ui {
    class NewEventAreaDialog;
}

class NewEventAreaDialog : public QDialog
{
    Q_OBJECT

public:
    explicit NewEventAreaDialog(QWidget *parent = 0);
    ~NewEventAreaDialog();

private:
    Ui::NewEventAreaDialog *ui;
};

#endif // NEWEVENTAREADIALOG_H
#ifndef NEWEVENTDIALOG_H
#define NEWEVENTDIALOG_H

#include <QDialog>
#include <QListWidgetItem>

#include <vector>
#include <list>
#include <utility>
#include <algorithm>
#include <sstream>

#include "gamedata.h"
#include "gameobject.h"
#include "eventseditorcontroller.h"
#include "eventattributedata.h"
#include "messageboxes.h"
#include "eventdata.h"

class GameData;
class GameObject;
class EventsEditorController;
class EventAttributeData;
class MessageBoxes;
class EventData;

namespace Ui {
    class NewEventDialog;
}

class NewEventDialog : public QDialog
{
    Q_OBJECT

public:
    explicit NewEventDialog(EventsEditorController *eventsEditorController, EventData *eventData, GameObject *gameObject, int type, int conditionType = 0, QWidget *parent = 0);
    ~NewEventDialog();

    void populaListaObjects();
    void populaComboAtributos();
    void populaComboConditions();
    void populaComboActions();
    void habilitaGroupValues();
    void populaComboVariables();
    void populaComboSpecial(int type);
    void populaComboAtributosObject02();
    void preencheCampos();

    void freeAttributeData();

private slots:
    void on_listWidgetObject1_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);

    void on_comboBoxAttrib_currentIndexChanged(int index);

    void on_comboBoxCondit_currentIndexChanged(int index);

    void on_listWidgetObject2_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);

    void on_checkBoxNumber_toggled(bool checked);

    void on_checkBoxVariable_toggled(bool checked);

    void on_checkBoxFieldObject02_toggled(bool checked);

    void on_buttonBox_2_accepted();

    void on_buttonBox_2_rejected();

private:
    Ui::NewEventDialog *ui;
    EventsEditorController *eventsEditorController;
    EventData *eventData;
    GameObject *gameObject;
    int type;
    int conditionType;
};

#endif // NEWEVENTDIALOG_H

#ifndef NEWMAPWINDOWGENERALWIDGET_H
#define NEWMAPWINDOWGENERALWIDGET_H

#include <QWidget>

#include "map.h"
#include "soundpickerdialog.h"
#include "backgroundpickerdialog.h"
#include "gamedata.h"
#include "messageboxes.h"
#include "background.h"

class Map;
class SoundPickerDialog;
class BackgroundPickerDialog;
class GameData;
class MessageBoxes;
class Background;

namespace Ui {
    class NewMapWindowGeneralWidget;
}

class NewMapWindowGeneralWidget : public QWidget {
    Q_OBJECT
public:
    NewMapWindowGeneralWidget(QWidget *parent = 0);
    ~NewMapWindowGeneralWidget();

    QString getNomeMapa();
    int getTamanhoWidth();
    int getTamanhoHeight();

    void preencheDados();



    Map *map;
protected:
    void changeEvent(QEvent *e);


private:
    Ui::NewMapWindowGeneralWidget *ui;

private slots:
    void on_toolButtonRemoveSound_pressed();
    void on_toolButtonRemoveMusic_pressed();
    void on_toolButtonRemoveBackground_pressed();
    void on_toolButtonBackgroundChooser_pressed();
    void on_toolButtonSound_clicked();
    void on_toolButtonMusic_clicked();
};

#endif // NEWMAPWINDOWGENERALWIDGET_H
#ifndef NEWMAPWINDOW_H
#define NEWMAPWINDOW_H

#include <QDialog>

#include "map.h"
#include "mapeditorcontroller.h"

class Map;
class MapEditorController;

namespace Ui {
    class NewMapWindow;
}

class NewMapWindow : public QDialog {
    Q_OBJECT
public:
    NewMapWindow(MapEditorController *mapEditorController, Map *map = NULL, QWidget *parent = 0);
    ~NewMapWindow();

    Map *map;


protected:
    void changeEvent(QEvent *e);

private:
    Ui::NewMapWindow *ui;
    MapEditorController *mapEditorController;

    int mode;

    const static int MODE_NEW = 0;
    const static int MODE_EDIT = 1;

private slots:
    void on_buttonBox_accepted();
};

#endif // NEWMAPWINDOW_H
#ifndef NEWMAPWINDOWOBJECTWIDGET_H
#define NEWMAPWINDOWOBJECTWIDGET_H

#include <stdlib.h>

#include <QWidget>
#include <QListWidgetItem>
#include <vector>


#include "gamedata.h"
#include "gameobject.h"
#include "map.h"

class GameData;
class GameObject;

namespace Ui {
    class NewMapWindowObjectWidget;
}

class NewMapWindowObjectWidget : public QWidget
{
    Q_OBJECT

public:
    explicit NewMapWindowObjectWidget(QWidget *parent = 0);
    ~NewMapWindowObjectWidget();

    void populaListaObjetosDisponiveis();
    void populaListObjetosEscolhidos();
    Map *map;

private:
    Ui::NewMapWindowObjectWidget *ui;


private slots:
    void on_pushButton_clicked();
};

#endif // NEWMAPWINDOWOBJECTWIDGET_H
#ifndef NEWMAPWINDOWTILESETWIDGET_H
#define NEWMAPWINDOWTILESETWIDGET_H

#include <QWidget>
#include <vector>

#include "gamedata.h"
#include "tileset.h"
#include "map.h"

#include "boost/foreach.hpp"

class GameData;
class TileSet;
class Map;

namespace Ui {
    class NewMapWindowTilesetWidget;
}

class NewMapWindowTilesetWidget : public QWidget {
    Q_OBJECT
public:
    NewMapWindowTilesetWidget(QWidget *parent = 0);
    ~NewMapWindowTilesetWidget();


    void populaListaDisponiveis();
    void populaListaEscolhidos();

    Map *map;

protected:
    void changeEvent(QEvent *e);

private:
    Ui::NewMapWindowTilesetWidget *ui;

private slots:
    void on_pushButton_clicked();
};

#endif // NEWMAPWINDOWTILESETWIDGET_H
#ifndef NEWPROJECTWINDOW_H
#define NEWPROJECTWINDOW_H

#include <QDialog>
#include <stdlib.h>

#include "maincontroller.h"
#include "messageboxes.h"

class MainController;
class MessageBoxes;

namespace Ui {
    class NewProjectWindow;
}

class NewProjectWindow : public QDialog {
    Q_OBJECT
public:
    NewProjectWindow(QWidget *parent = 0, MainController *mainController = NULL);
    ~NewProjectWindow();

protected:
    void changeEvent(QEvent *e);

private:
    Ui::NewProjectWindow *ui;
    MainController *mainController;

    bool textNomeJogoChanged;
    bool textNomePastaChanged;

private slots:
    void on_textNomeJogo_textEdited(QString );
    void on_textNomePasta_textEdited(QString );
    void on_textNomeJogo_textChanged(QString );
    void on_textNomePasta_textChanged(QString );
    void on_buttonBox_rejected();
    void on_buttonBox_accepted();
};

#endif // NEWPROJECTWINDOW_H
#ifndef NEWTELEPORTAREADIALOG_H
#define NEWTELEPORTAREADIALOG_H

#include <QDialog>
#include <vector>
#include <string>
#include <sstream>

#include "gamedata.h"
#include "map.h"
#include "teleportarea.h"

class GameData;
class Map;
class TeleportArea;

namespace Ui {
    class NewTeleportAreaDialog;
}

class NewTeleportAreaDialog : public QDialog
{
    Q_OBJECT

public:
    explicit NewTeleportAreaDialog(QWidget *parent = 0);
    explicit NewTeleportAreaDialog(TeleportArea *teleportArea, QWidget *parent = 0);
    ~NewTeleportAreaDialog();

    void populaComboMapa();
    void populaComboMapaPercorreArvore(std::vector<Map*> *mapList, std::string prefix);

    TeleportArea* exec();

private:
    Ui::NewTeleportAreaDialog *ui;
    TeleportArea *teleportArea;
};

#endif // NEWTELEPORTAREADIALOG_H
#ifndef NEWVARIABLEDIALOG_H
#define NEWVARIABLEDIALOG_H

#include <QDialog>

#include "variabledata.h"
#include "messageboxes.h"

class VariableData;
class MessageBoxes;

namespace Ui {
    class NewVariableDialog;
}

class NewVariableDialog : public QDialog
{
    Q_OBJECT

public:
    explicit NewVariableDialog(VariableData *variableData, QWidget *parent = 0);
    ~NewVariableDialog();

    void habilitaElementos();
    void preencheCampos();

    VariableData* exec();

private slots:
    void on_buttonBox_accepted();

    void on_comboBoxVariableType_currentIndexChanged(int index);

private:
    Ui::NewVariableDialog *ui;
    VariableData *variableData;
};

#endif // NEWVARIABLEDIALOG_H
#ifndef OBJECTGRAPHICSITEM_H
#define OBJECTGRAPHICSITEM_H

#include <QGraphicsRectItem>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QRectF>
#include <QGraphicsScene>
#include <QGraphicsSceneMouseEvent>
#include <QGraphicsEffect>
#include <QMenu>
#include <QAction>

#include <stdlib.h>
#include <vector>

#include "gameobject.h"
#include "gameobjectinstance.h"
#include "gamedata.h"
#include "messageboxes.h"
#include "mapeditorcontroller.h"


class GameObject;
class GameObjectInstance;
class GameData;
class MessageBoxes;
class MapEditorController;

class ObjectGraphicsItem : public QGraphicsRectItem
{
public:
    ObjectGraphicsItem(GameObjectInstance *gameObjectInstance,
                       std::vector<GameObjectInstance*> *mapGameObjectInstances,
                       MapEditorController *mapEditorController);



    void setVisible(bool visible);
    void setColorizeEffect(bool value);
    void updateObjectInstancePosition();
    QGraphicsColorizeEffect *colorizeEffect;

private:
    QImage *image;
    bool visible;
    float width, height;
    GameObjectInstance *gameObjectInstance;
    std::vector<GameObjectInstance*> *mapGameObjectInstances;
    MapEditorController *mapEditorController;


protected:
    void paint( QPainter *, const QStyleOptionGraphicsItem *option, QWidget *widget );
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
    void contextMenuEvent(QGraphicsSceneContextMenuEvent *event);
};

#endif // OBJECTGRAPHICSITEM_H
#ifndef OBJECTSDOCK_H
#define OBJECTSDOCK_H

#include <vector>

#include <QDockWidget>
#include <QCursor>

#include "mapeditorcontroller.h"
#include "gamedata.h"
#include "gameobject.h"
#include "easynewgameobjectdialog.h"

class MapEditorController;
class GameData;
class GameObject;
class EasyNewGameObjectDialog;

namespace Ui {
    class ObjectsDock;
}

class ObjectsDock : public QDockWidget
{
    Q_OBJECT

public:
    explicit ObjectsDock(MapEditorController *mapEditorController, QWidget *parent = 0);
    ~ObjectsDock();

    void populaArvoreObjetos();

    void initDockScene();
    GameObject* getCurrentObject();

private:
    Ui::ObjectsDock *ui;
    MapEditorController *mapEditorController;

private slots:
    void on_treeWidget_customContextMenuRequested(QPoint pos);
    void on_treeWidget_itemClicked(QTreeWidgetItem* item, int column);
    void on_pushButtonCreateObject_pressed();
};

#endif // OBJECTSDOCK_H
#ifndef OPTIONSCONTROLLER_H
#define OPTIONSCONTROLLER_H

#include <QFile>

#include <stdlib.h>
#include <sstream>
#include <string>

#include "maincontroller.h"
#include "eventseditorcontroller.h"
#include "configstabwindow.h"
#include "tileset.h"
#include "gameobject.h"
#include "background.h"
#include "easynewgameobjectdialog.h"

#include "editorconstants.h"



class MainController;
class EventsEditorController;
class ConfigsTabWindow;
class TileSet;
class GameObject;
class EditorConstants;
class Background;
class EasyNewGameObjectDialog;

class OptionsController
{
public:
    OptionsController();

    void setMainController(MainController*);
    void setEventsEditorController(EventsEditorController *eventsEditorController);
    void openConfigsTabWindow(QWidget *parent);
    void openConfigsTabWindow(QWidget *parent, GameObject *gameObject);

    void setGameScreen(std::string fileName, int option);

    void importResource(std::string filePathToImport, int importType);
    void addTileset(std::string fileName);
    void addAnimation(std::string animation, int animationImportPattern);
    void addBackground(std::string background);

    void addObjectSkill(GameObject *gameObject, SkillData *skillData);
    void removeObjectSkill(GameObject *gameObject, SkillData *skillData);

    void determinaValorResolucaoCombo(int index);



    void addObject(std::string name, int type);

    void openEasyNewGameObjectDialog();
private:
    MainController *mainController;
    EventsEditorController *eventsEditorController;

    ConfigsTabWindow *configsTabWindow;
};

#endif // OPTIONSCONTROLLER_H
#ifndef POINT_H
#define POINT_H

#include "tileset.h"

class TileSet;

class Point
{
public:
    Point();
    Point(int x, int y);
    int x, y;
    TileSet* z;
};

#endif // POINT_H
#ifndef PROCEDUREDATA_H
#define PROCEDUREDATA_H

#include <list>
#include <string>

#include "eventdata.h"

class EventData;

class ProcedureData
{
public:
    ProcedureData();


    int id;
    std::string name;
    bool nameEditable;

    std::list<EventData*> events;
};

#endif // PROCEDUREDATA_H
#ifndef PROJECT_H
#define PROJECT_H

#include <stdlib.h>

#include "gamedata.h"

class GameData;

class Project
{
public:
    Project();

    Project* getInstance();
    void newProject();


    GameData *gameData;

    static Project *singleton;
};

#endif // PROJECT_H
#ifndef SKILLDATA_H
#define SKILLDATA_H

#include "skill.h"
#include "gameobject.h"

class Skill;
class GameObject;

class SkillData
{
public:
    SkillData();

    int id;
    Skill *skill;

    GameObject *skillObject;
    GameObject *skillProvider;

    int level;
    int intensity;
    int magicCost;


};

#endif // SKILLDATA_H
#ifndef SKILL_H
#define SKILL_H

#include <string>
#include <vector>

#include <stdarg.h>

#include "gameobject.h"

class GameObject;

class Skill
{
public:
    Skill(int id, std::string name, std::string description, std::vector<int> objectTypes, bool hasObject, bool hasIntensity);

    int id;
    std::string name;
    std::string description;
    std::vector<int> objectTypes;

    bool hasObject, hasIntensity;

    bool containsObjectType(int type);

    static std::vector<Skill*>* getEditorSkills();

    static const int SKILL_THROW_OBJECT = 0;
    static const int SKILL_THROW_OBJECT_CLICK = 1;
    static const int SKILL_USE_SWORD = 2;
    static const int SKILL_JUMP = 3;
    static const int SKILL_DOUBLE_JUMP = 4;
    static const int SKILL_RUN = 5;
    static const int SKILL_WALL_KICK = 6;
    static const int SKILL_GLIDE = 7;
    static const int SKILL_FLY = 8;

private:
    static Skill* createSkill(int id, std::string name, std::string description, bool hasObject, bool hasIntensity, int objectType, ...);
};

#endif // SKILL_H
#ifndef SOUNDPICKERDIALOG_H
#define SOUNDPICKERDIALOG_H

#include <iostream>
#include <stdlib.h>

#include <QDialog>
#include <QDir>
#include <QFileDialog>
#include <QListWidgetItem>
#include <QSound>


#include "gamedata.h"

class GameData;

namespace Ui {
    class SoundPickerDialog;
}

class SoundPickerDialog : public QDialog
{
    Q_OBJECT

public:
    explicit SoundPickerDialog(int tipo, QWidget *parent = 0);
    ~SoundPickerDialog();

    void populaListaMusica();
    void populaListaSom();



    std::string getSelectedFile();
    bool okPressed();

    int type;
    bool ok;
    static const int MUSICA = 0;
    static const int SOM = 1;

    QSound *sound;

private:
    Ui::SoundPickerDialog *ui;
    std::string selectedSoundFile;
    std::string selectedMusicFile;

private slots:
    void on_listWidgetSound_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_listWidgetMusic_currentItemChanged(QListWidgetItem* current, QListWidgetItem* previous);
    void on_pushButton_2_clicked();
    void on_pushButton_3_clicked();
    void on_pushButton_clicked();
    void on_pushButton_6_clicked();
    void on_pushButton_5_clicked();
    void on_pushButton_4_clicked();
};

#endif // SOUNDPICKERDIALOG_H
#ifndef SPECIALCOMBOVALUEDATA_H
#define SPECIALCOMBOVALUEDATA_H

#include <string>

class SpecialComboValueData
{
public:
    SpecialComboValueData();

    int code;
    std::string string;
};

#endif // SPECIALCOMBOVALUEDATA_H
#ifndef SPRITE_H
#define SPRITE_H

#include <string>

class Sprite
{
public:
    Sprite();

    int id;
    std::string spriteFileName;
    int direction;

    /* dados pendentes de gravacao */
    bool hascolorkey;
    int r_colorkey;
    int b_colorkey;
    int g_colorkey;

    bool activated;
};

#endif // SPRITE_H
#ifndef TELEPORTAREAGRAPHICSITEM_H
#define TELEPORTAREAGRAPHICSITEM_H

#include <QGraphicsRectItem>
#include <QGraphicsScene>
#include <QMenu>
#include <QAction>
#include <QGraphicsSceneContextMenuEvent>

#include <iostream>

#include "teleportarea.h"
#include "newteleportareadialog.h"
#include "gamedata.h"
#include "messageboxes.h"

class TeleportArea;
class NewTeleportAreaDialog;
class GameData;
class MessageBoxes;

class TeleportAreaGraphicsItem : public QGraphicsRectItem
{
public:
    TeleportAreaGraphicsItem();
    void addLittleBoxAtTopLeftMarkToScene(QGraphicsScene *graphicsScene);

    QGraphicsRectItem *littleBoxAtTopLeft;
    QGraphicsTextItem *rectText;
    TeleportArea *teleportArea;

protected:
    void contextMenuEvent(QGraphicsSceneContextMenuEvent *event);
};

#endif // TELEPORTAREAGRAPHICSITEM_H
#ifndef TELEPORTAREA_H
#define TELEPORTAREA_H

class TeleportArea
{
public:
    TeleportArea();

    int id;
    int x, y, w, h;

    int mapId, mapPosX, mapPosY;
    bool mapPositionDetermined;
    bool showVictoryAnimation;
};

#endif // TELEPORTAREA_H
#ifndef TILEITEM_H
#define TILEITEM_H

#include <QGraphicsRectItem>
#include <QImage>
#include <QPainter>


#include "tilemapgridvisual.h"
#include "tileset.h"
#include "gamedata.h"

class TilemapGridVisual;
class TileSet;
class GameData;

class TileItem : public QObject, public QGraphicsRectItem
{
    Q_OBJECT
public:
    TileItem(TilemapGridVisual *mapGridVisual, int i, int j);
    TileItem(QImage *image, int size, int i, int j);

    void updateTile(int i, int j, TileSet *tileset);
    void updateTileset(TileSet *tileset);

    bool isVisible();
    void setVisible(bool visibility);

private:
    QImage *image;
    int size, i, j;
    bool visible;

    bool existance;

protected:
    void paint( QPainter *, const QStyleOptionGraphicsItem *option, QWidget *widget );

};

#endif // TILEITEM_H
#ifndef TilemapGridVisual_H
#define TilemapGridVisual_H

#include <QImage>
#include <QGraphicsScene>

#include <stdio.h>
#include <stdlib.h>

#include <boost/multi_array.hpp>

#include "tileitem.h"
#include "tilesetlinesgenerator.h"
#include "tilesetdock.h"
#include "gamedata.h"
#include "tileset.h"

class TilesetDock;
class TileItem;
class GameData;
class TileSet;

using namespace boost;

class TilemapGridVisual
{
public:
    TilemapGridVisual(QGraphicsScene *scene, QImage *image,
                    int tileSize, int width, int height, int layers);

    void addTilesToScene();
    void changeTile(int i, int j, int tileI, int tileJ, int layer, TileSet *tileset);

    bool isVisible();
    void setVisible(bool visibility);
    void setOpacity(float opacity);
    void expandLayer();

    int getLayerCount();


    QImage *image;
    int tileSize, width, height;
    QGraphicsScene *scene;


    multi_array<TileItem*, 3> tileMap;

    TilesetLinesGenerator *linesGenerator;
    TilesetDock *tilesetDock;
private:
    bool visible;
    int layers;
};

#endif // TilemapGridVisual_H
#ifndef TILEMAPSCENE_H
#define TILEMAPSCENE_H

#include <QGraphicsScene>
#include <QAbstractGraphicsShapeItem>
#include <QGraphicsSceneMouseEvent>
#include <QGraphicsSceneWheelEvent>
#include <QAction>
#include <QMenu>
#include <math.h>


#include <algorithm>
#include <iostream>
#include <typeinfo>
#include <stdlib.h>

#include "tilemapgridvisual.h"
#include "mapeditorcontroller.h"
#include "tileset.h"
#include "gameobject.h"
#include "gamedata.h"
#include "objectgraphicsitem.h"
#include "newteleportareadialog.h"
#include "neweventareadialog.h"
#include "teleportarea.h"
#include "teleportareagraphicsitem.h"

class TilemapGridVisual;
class MapEditorController;
class Tileset;
class GameData;
class GameObject;
class ObjectGraphicsItem;
class NewTeleportAreaDialog;
class NewEventAreaDialog;
class TeleportArea;
class TeleportAreaGraphicsItem;


class TilemapScene : public QGraphicsScene
{
    Q_OBJECT
public:
    TilemapScene(int size, int width, int height, int layers, MapEditorController *mapEditorController);

    QGraphicsRectItem *shape1, *shape2;
    QGraphicsRectItem *objectSelectionShape;
    QGraphicsRectItem *layerRect;

    QPointF objectSelectionStartPosition, objectSelectionEndPosition;
    QPointF squareCircleDrawStartPosition, squareCircleDrawEndPosition;


    void drawObjectSelectionRectangle();
    void cleanColorizeSelectedItems();
    void colorizeSelectedItems();

    void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
    void mousePressEvent(QGraphicsSceneMouseEvent *event);
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
    void wheelEvent(QGraphicsSceneWheelEvent *event);

    void changeTile(int i, int j, int tileI, int tileJ, int layer, TileSet *tileSet);

    void setSelectionRectangleSize(int di, int dj);
    void setCurrentObjectAtCursor();
    void setEditorMode(int mode);
    void setEditionLayer(int layer);

    TilemapGridVisual *mapGridVisual;
    MapEditorController *mapEditorController;
    QGraphicsPixmapItem *currentObjectItem;
    bool mousePressed;
    bool squareCreating;

    std::vector<GameObjectInstance*> *gameObjectInstances;
    std::vector<TeleportAreaGraphicsItem*> *teleportAreaGraphicsItems;



};

#endif // TILEMAPSCENE_H
#ifndef TILEMAPVIEW_H
#define TILEMAPVIEW_H

#include <QGraphicsView>

class TilemapView : public QGraphicsView
{
    Q_OBJECT
public:
    TilemapView(QWidget *parent);
};

#endif // TILEMAPVIEW_H
#ifndef TILESETCOLMAPSCENE_H
#define TILESETCOLMAPSCENE_H

#include <math.h>

#include <QGraphicsScene>
#include <QGraphicsPixmapItem>
#include <QGraphicsDropShadowEffect>
#include <QGraphicsSceneMouseEvent>

#include <boost/multi_array.hpp>
#include "tilesetlinesgenerator.h"

#include "tileset.h"

class TileSet;
class TilesetLinesGenerator;

class TilesetColMapScene : public QGraphicsScene
{
    Q_OBJECT
public:
    explicit TilesetColMapScene(TileSet *tileset, QObject *parent = 0);


    void mousePressEvent(QGraphicsSceneMouseEvent *event);

    QGraphicsPixmapItem *tilesetPixmapItem;
    TileSet *tileset;

    boost::multi_array<QGraphicsTextItem*, 2> textArray;

signals:

public slots:

};

#endif // TILESETCOLMAPSCENE_H
#ifndef TILESETDOCK_H
#define TILESETDOCK_H


#include <QDockWidget>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QSpacerItem>
#include <QTabWidget>
#include <QSlider>

#include <vector>
#include <sstream>

#include "tilesetview.h"
#include "tilesetscene.h"
#include "mapeditorcontroller.h"
#include "gamedata.h"
#include "tileset.h"

class MapEditorController;
class TilesetScene;
class GameData;
class TileSet;

class TilesetDock : public QDockWidget
{
    Q_OBJECT
public:
    TilesetDock(QWidget *parent, MapEditorController *mapEditorController);

    void setDrawTile(int iTile, int jTile, int diTile, int djTile);
    void setEditorMode(int mode);
    void initTileSetScene();

    QTabWidget *tabWidget;
    QWidget *widget;
    QSlider *layerSlider;

    TileSet* getSelectedTileset();

private:
    MapEditorController *mapEditorController;
    TilesetView *tilesetView;
    TilesetScene *tilesetScene;
    QVBoxLayout *layout;

private slots:
    void layerSliderMudada(int valor);
};

#endif // TILESETDOCK_H
#ifndef TilesetGridVisual_H
#define TilesetGridVisual_H

#include <math.h>
#include <stdio.h>
#include <boost/multi_array.hpp>

#include "tileitem.h"
#include "tilesetlinesgenerator.h"

class TileItem;
class TilesetLinesGenerator;

using namespace boost;

class TilesetGridVisual
{
public:
    TilesetGridVisual(QGraphicsScene *scene, QImage *image, int tileSize);

    void addTilesToScene();


    QImage *image;
    int tileSize, width, height;
    QGraphicsScene *scene;

    multi_array<TileItem*, 2> tileMap;

    TilesetLinesGenerator *linesGenerator;


};

#endif // TilesetGridVisual_H
#ifndef TILESET_H
#define TILESET_H

#include <string>
#include <QImage>
#include <boost/multi_array.hpp>

#include "gamedata.h"

class GameData;

#define NO_COLLISION        0
#define BLOCK_COLLISION     1
#define PIXEL_COLLISION     2
#define LAYER_UP            3

using namespace boost;

class TileSet
{
public:
    TileSet();
    TileSet(std::string file, int tileSize);
    void setCollision(int tileI, int tileJ, int collisionType);

    void reloadTilesetImage();


    QImage *tilesetImage;

    multi_array<int, 2> collisionMatrix;
    std::string file;
    std::string name;
    int tileSize;
    int width, height, maxX, maxY;
    int id;


};

#endif // TILESET_H
#ifndef TILESETLINESGENERATOR_H
#define TILESETLINESGENERATOR_H

#include <QGraphicsLineItem>
#include <QGraphicsScene>

class TilesetLinesGenerator
{
public:
    TilesetLinesGenerator(QGraphicsScene *scene, int size, int width, int height, Qt::PenStyle penStyle);

    void addLinesToScene();

    QGraphicsLineItem **lines;
    QGraphicsScene *scene;

    int width, height;
};

#endif // TILESETLINESGENERATOR_H
#ifndef TILESETSCENE_H
#define TILESETSCENE_H

#include <QGraphicsScene>
#include <QGraphicsSceneMouseEvent>
#include <QGraphicsRectItem>
#include <math.h>

#include "tilesetgridvisual.h"
#include "tilesetdock.h"
#include "tileset.h"
#include "gamedata.h"

class TilesetDock;
class TileSet;
class GameData;

class TilesetGridVisual;

class TilesetScene : public QGraphicsScene
{
    Q_OBJECT
public:
    TilesetScene(TilesetDock *tilesetDock, TileSet *tileset);

    QGraphicsRectItem *shape1, *shape2, *shape3, *shape4;

    int size, iAnt, jAnt;

    /* variaveis para desenho extensivel do shape */
    int iInicial, jInicial;


    TilesetDock *tilesetDock;
    TilesetGridVisual *gridVisual;

    TileSet *tileSet;

    bool mousePressed;

    void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
    void mousePressEvent(QGraphicsSceneMouseEvent *event);
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
};

#endif // TILESETSCENE_H
#ifndef TILESETVIEW_H
#define TILESETVIEW_H

#include <QGraphicsView>

class TilesetView : public QGraphicsView
{
    Q_OBJECT
public:
    TilesetView(QWidget *parent);
};

#endif // TILESETVIEW_H
#ifndef TITLESCREENDATA_H
#define TITLESCREENDATA_H

#include <string>

class TitleScreenData
{
public:
    TitleScreenData();

    std::string backgroundFile;
};

#endif // TITLESCREENDATA_H
#ifndef VARIABLEDATA_H
#define VARIABLEDATA_H

#include <string>

class VariableData
{
public:
    VariableData();

    int id;
    std::string name;
    int type;
    float value;


    static const int TYPE_NUMBER = 0;
    static const int TYPE_FLAG = 1;
};

#endif // VARIABLEDATA_H
#ifndef WIZARDCONTROLLER_H
#define WIZARDCONTROLLER_H

#include "maincontroller.h"

class MainController;

class WizardController
{
public:
    WizardController();

    void setMainController(MainController*);
private:
    MainController *mainController;
};

#endif // WIZARDCONTROLLER_H
